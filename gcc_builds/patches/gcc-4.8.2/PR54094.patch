From bffcae34bdf0412048ac450875a05b850eee5083 Mon Sep 17 00:00:00 2001
From: grosser <grosser@138bc75d-0d04-0410-961f-82ee72b054a4>
Date: Sun, 14 Jul 2013 06:45:08 +0000
Subject: [PATCH] graphite: Do not depend on 2D + 1 form in parallelism check

    PR tree-optimization/54094
    * graphite-clast-to-gimple.c (translate_clast_for_loop): Derive the
      scheduling dimension for the parallelism check from the polyhedral
      information in the AST.
    * graphite-dependences.c (carries_deps): Do not assume the schedule is
      in 2D + 1 form.

git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/trunk@200946 138bc75d-0d04-0410-961f-82ee72b054a4
---
 gcc/ChangeLog                           |  9 +++++++++
 gcc/graphite-clast-to-gimple.c          |  5 ++++-
 gcc/graphite-dependences.c              |  9 ++++-----
 gcc/testsuite/gcc.dg/graphite/pr54094.c | 10 ++++++++++
 4 files changed, 27 insertions(+), 6 deletions(-)
 create mode 100644 gcc/testsuite/gcc.dg/graphite/pr54094.c

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 1bcd994..bdc674d 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -7,6 +7,13 @@
 	* configure.ac: Also allow ISL 0.12.
 	* configure: Regenerated.
 
+	PR tree-optimization/54094
+	* graphite-clast-to-gimple.c (translate_clast_for_loop): Derive the
+	  scheduling dimension for the parallelism check from the polyhedral
+	  information in the AST.
+	* graphite-dependences.c (carries_deps): Do not assume the schedule is
+	  in 2D + 1 form.
+
 2013-05-31  Release Manager
 
 	* GCC 4.8.1 released.
diff --git a/gcc/graphite-clast-to-gimple.c b/gcc/graphite-clast-to-gimple.c
index 82cae2f..663cc82 100644
--- a/gcc/graphite-clast-to-gimple.c
+++ b/gcc/graphite-clast-to-gimple.c
@@ -1181,8 +1181,11 @@ struct clast_index_hasher
   redirect_edge_succ_nodup (next_e, after);
   set_immediate_dominator (CDI_DOMINATORS, next_e->dest, next_e->src);
 
+  isl_set *domain = isl_set_from_cloog_domain (stmt->domain);
+  int scheduling_dim = isl_set_n_dim (domain);
+
   if (flag_loop_parallelize_all
-      && loop_is_parallel_p (loop, bb_pbb_mapping, level))
+      && loop_is_parallel_p (loop, bb_pbb_mapping, scheduling_dim))
     loop->can_be_parallel = true;
 
   return last_e;
diff --git a/gcc/graphite-dependences.c b/gcc/graphite-dependences.c
index 366588b..7fd4081 100644
--- a/gcc/graphite-dependences.c
+++ b/gcc/graphite-dependences.c
@@ -298,7 +298,7 @@ struct extend_schedule_str {
 	      int depth)
 {
   bool res;
-  int idx, i;
+  int i;
   isl_space *space;
   isl_map *lex, *x;
   isl_constraint *ineq;
@@ -313,13 +313,12 @@ struct extend_schedule_str {
   space = isl_map_get_space (x);
   ineq = isl_inequality_alloc (isl_local_space_from_space (space));
 
-  idx = 2 * depth + 1;
-  for (i = 0; i < idx; i++)
+  for (i = 0; i < depth - 1; i++)
     lex = isl_map_equate (lex, isl_dim_in, i, isl_dim_out, i);
 
   /* in + 1 <= out  */
-  ineq = isl_constraint_set_coefficient_si (ineq, isl_dim_out, idx, 1);
-  ineq = isl_constraint_set_coefficient_si (ineq, isl_dim_in, idx, -1);
+  ineq = isl_constraint_set_coefficient_si (ineq, isl_dim_out, depth - 1, 1);
+  ineq = isl_constraint_set_coefficient_si (ineq, isl_dim_in, depth - 1, -1);
   ineq = isl_constraint_set_constant_si (ineq, -1);
   lex = isl_map_add_constraint (lex, ineq);
   x = isl_map_intersect (x, lex);
diff --git a/gcc/testsuite/gcc.dg/graphite/pr54094.c b/gcc/testsuite/gcc.dg/graphite/pr54094.c
new file mode 100644
index 0000000..ee99110b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/graphite/pr54094.c
@@ -0,0 +1,10 @@
+/* { dg-options "-O2 -floop-parallelize-all -floop-nest-optimize" } */
+void dwt_deinterleave_h(int *a, int *b, int dn, int sn, int cas)
+{
+  int i;
+  for (i=0; i<sn; i++)
+    b[i]=a[2*i+cas];
+  for (i=0; i<dn; i++)
+    b[sn+i]=a[(2*i+1-cas)];
+}
+
-- 
1.8.5.1

