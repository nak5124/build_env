diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 40c1bc9..0c4dc21 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,140 @@
+2014-03-06  Matthias Klose  <doko@ubuntu.com>
+
+	* Makefile.in (s-mlib): Only pass MULTIARCH_DIRNAME if
+	MULTILIB_OSDIRNAMES is not defined.
+
+2014-03-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/60276
+	* tree-vect-data-refs.c (vect_analyze_data_ref_dependence): Avoid
+	a -Wsign-compare warning.
+
+	* Makefile.in (tree-ssa-uninit.o): Depend on $(PARAMS_H).
+
+	Backport from mainline
+	2014-02-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/56490
+	* params.def (PARAM_UNINIT_CONTROL_DEP_ATTEMPTS): New param.
+	* tree-ssa-uninit.c: Include params.h.
+	(compute_control_dep_chain): Add num_calls argument, return false
+	if it exceed PARAM_UNINIT_CONTROL_DEP_ATTEMPTS param, pass
+	num_calls to recursive call.
+	(find_predicates): Change dep_chain into normal array, add num_calls
+	variable and adjust compute_control_dep_chain caller.
+	(find_def_preds): Likewise.
+
+	2014-02-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/43546
+	* expr.c (compress_float_constant): If x is a hard register,
+	extend into a pseudo and then move to x.
+
+	2014-02-11  Richard Henderson  <rth@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/59776
+	* tree-sra.c (load_assign_lhs_subreplacements): Add VIEW_CONVERT_EXPR
+	around drhs if type conversion to lacc->type is not useless.
+
+	2014-02-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/60026
+	* ipa-cp.c (determine_versionability): Fail at -O0
+	or __attribute__((optimize (0))) or -fno-ipa-cp functions.
+	* tree-sra.c (ipa_sra_preliminary_function_checks): Similarly.
+
+	2014-02-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/60062
+	* tree.h (opts_for_fn): New inline function.
+	(opt_for_fn): Define.
+	* config/i386/i386.c (ix86_function_regparm): Use
+	opt_for_fn (decl, optimize) instead of optimize.
+
+	2014-02-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/57499
+	* tree-eh.c (cleanup_empty_eh): Bail out on totally empty
+	bb with no successors.
+
+2014-03-04  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/60382
+	* tree-vect-loop.c (vect_is_simple_reduction_1): Do not consider
+	dead PHIs a reduction.
+
+2014-02-25  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-02-21  Richard Biener  <rguenther@suse.de>
+
+        PR tree-optimization/60276
+        * tree-vectorizer.h (struct _stmt_vec_info): Add min_neg_dist field.
+        (STMT_VINFO_MIN_NEG_DIST): New macro.
+        * tree-vect-data-refs.c (vect_analyze_data_ref_dependence): Record
+        STMT_VINFO_MIN_NEG_DIST.
+        * tree-vect-stmts.c (vectorizable_load): Verify if assumptions
+        made for negative dependence distances still hold.
+
+2014-02-25  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-02-21  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/60291
+	* tree-ssa-live.c (mark_all_vars_used_1): Do not walk
+	DECL_INITIAL for globals not in the current function context.
+
+	2014-02-20  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/60221
+	* tree-eh.c (execute_cleanup_eh_1): Also cleanup empty EH
+	regions at -O0.
+
+	2014-02-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/60183
+	* tree-ssa-phiprop.c (propagate_with_phi): Avoid speculating
+	loads.
+	(tree_ssa_phiprop): Calculate and free post-dominators.
+
+2014-02-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/55426
+	* config/arm/arm.h (CANNOT_CHANGE_MODE_CLASS): Allow 128 to 64-bit
+	conversions.
+
+2014-02-24  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (pa_output_move_double): Don't valididate when
+	adjusting offsetable addresses.
+
+2014-02-23  David Holsgrove <david.holsgrove@xilinx.com>
+
+	* config/microblaze/microblaze.md: Correct ashrsi_reg / lshrsi_reg names
+
+2014-02-23  Edgar E. Iglesias <edgar.iglesias@xilinx.com>
+
+	* config/microblaze/microblaze.h: Remove SECONDARY_MEMORY_NEEDED
+	definition.
+
+2014-02-23  David Holsgrove <david.holsgrove@xilinx.com>
+
+	* /config/microblaze/microblaze.c: Add microblaze_asm_output_mi_thunk
+	and define TARGET_ASM_OUTPUT_MI_THUNK and
+	TARGET_ASM_CAN_OUTPUT_MI_THUNK.
+
+2014-02-23  David Holsgrove <david.holsgrove@xilinx.com>
+
+	* config/microblaze/predicates.md: Add cmp_op predicate.
+	* config/microblaze/microblaze.md: Add branch_compare instruction 
+	which uses cmp_op predicate and emits cmp insn before branch.
+	* config/microblaze/microblaze.c (microblaze_emit_compare): Rename 
+	to microblaze_expand_conditional_branch and consolidate logic.
+	(microblaze_expand_conditional_branch): emit branch_compare
+	insn instead of handling cmp op separate from branch insn.
+
 2014-02-21  Martin Jambor  <mjambor@suse.cz>
 
 	PR ipa/55260
diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index 2194dd4..3378412 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -1827,7 +1827,7 @@ s-mlib: $(srcdir)/genmultilib Makefile
 	    "$(MULTILIB_EXCLUSIONS)" \
 	    "$(MULTILIB_OSDIRNAMES)" \
 	    "$(MULTILIB_REQUIRED)" \
-	    "$(MULTIARCH_DIRNAME)" \
+	    "$(if $(MULTILIB_OSDIRNAMES),,$(MULTIARCH_DIRNAME))" \
 	    "$(MULTILIB_REUSE)" \
 	    "@enable_multilib@" \
 	    > tmp-mlib.h; \
@@ -2256,7 +2256,7 @@ tree-ssa-uninit.o : tree-ssa-uninit.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
    $(FUNCTION_H) $(TM_H) coretypes.h \
    $(TREE_PASS_H) $(BASIC_BLOCK_H) $(BITMAP_H) \
    $(FLAGS_H) $(HASHTAB_H) pointer-set.h \
-   $(GIMPLE_H) $(TREE_INLINE_H) $(GIMPLE_PRETTY_PRINT_H)
+   $(GIMPLE_H) $(TREE_INLINE_H) $(GIMPLE_PRETTY_PRINT_H) $(PARAMS_H)
 tree-ssa.o : tree-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
    $(TREE_H) $(TM_P_H) $(EXPR_H) $(DIAGNOSTIC_H) \
    toplev.h $(FUNCTION_H) $(TM_H) coretypes.h \
diff --git a/gcc/c-family/ChangeLog b/gcc/c-family/ChangeLog
index 7b783e4..a18bb5c 100644
--- a/gcc/c-family/ChangeLog
+++ b/gcc/c-family/ChangeLog
@@ -1,3 +1,21 @@
+2014-03-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2014-02-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/37743
+	* c-common.c (c_common_nodes_and_builtins): When initializing
+	c_uint{16,32,64}_type_node, also set corresponding
+	uint{16,32,64}_type_node to the same value.
+
+	2014-02-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/60101
+	* c-common.c (merge_tlist): If copy is true, call new_tlist,
+	if false, add ADD itself, rather than vice versa.
+	(verify_tree): For COND_EXPR, don't call merge_tlist with non-zero
+	copy.  For SAVE_EXPR, only call merge_tlist once.
+
 2013-11-29  Jakub Jelinek  <jakub@redhat.com>
 
 	PR c/59280
diff --git a/gcc/c-family/c-common.c b/gcc/c-family/c-common.c
index 67a5762..b7c68d7 100644
--- a/gcc/c-family/c-common.c
+++ b/gcc/c-family/c-common.c
@@ -2894,7 +2894,7 @@ struct tlist_cache
 	  }
       if (!found)
 	{
-	  *end = copy ? add : new_tlist (NULL, add->expr, add->writer);
+	  *end = copy ? new_tlist (NULL, add->expr, add->writer) : add;
 	  end = &(*end)->next;
 	  *end = 0;
 	}
@@ -3052,7 +3052,7 @@ struct tlist_cache
       verify_tree (TREE_OPERAND (x, 0), &tmp_before, &tmp_list2, NULL_TREE);
       warn_for_collisions (tmp_list2);
       merge_tlist (pbefore_sp, tmp_before, 0);
-      merge_tlist (pbefore_sp, tmp_list2, 1);
+      merge_tlist (pbefore_sp, tmp_list2, 0);
 
       tmp_list3 = tmp_nosp = 0;
       verify_tree (TREE_OPERAND (x, 1), &tmp_list3, &tmp_nosp, NULL_TREE);
@@ -3156,12 +3156,7 @@ struct tlist_cache
 	    warn_for_collisions (tmp_nosp);
 
 	    tmp_list3 = 0;
-	    while (tmp_nosp)
-	      {
-		struct tlist *t = tmp_nosp;
-		tmp_nosp = t->next;
-		merge_tlist (&tmp_list3, t, 0);
-	      }
+	    merge_tlist (&tmp_list3, tmp_nosp, 0);
 	    t->cache_before_sp = tmp_before;
 	    t->cache_after_sp = tmp_list3;
 	  }
@@ -5511,13 +5506,13 @@ enum c_builtin_type
     uint8_type_node =
       TREE_TYPE (identifier_global_value (c_get_ident (UINT8_TYPE)));
   if (UINT16_TYPE)
-    c_uint16_type_node =
+    c_uint16_type_node = uint16_type_node =
       TREE_TYPE (identifier_global_value (c_get_ident (UINT16_TYPE)));
   if (UINT32_TYPE)
-    c_uint32_type_node =
+    c_uint32_type_node = uint32_type_node =
       TREE_TYPE (identifier_global_value (c_get_ident (UINT32_TYPE)));
   if (UINT64_TYPE)
-    c_uint64_type_node =
+    c_uint64_type_node = uint64_type_node =
       TREE_TYPE (identifier_global_value (c_get_ident (UINT64_TYPE)));
   if (INT_LEAST8_TYPE)
     int_least8_type_node =
diff --git a/gcc/config/arm/arm.h b/gcc/config/arm/arm.h
index 05aea35..14340eb 100644
--- a/gcc/config/arm/arm.h
+++ b/gcc/config/arm/arm.h
@@ -1213,11 +1213,15 @@ enum reg_class
    VFPv2.
    In big-endian mode, modes greater than word size (i.e. DFmode) are stored in
    VFP registers in little-endian order.  We can't describe that accurately to
-   GCC, so avoid taking subregs of such values.  */
-#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)	\
-  (TARGET_VFP && TARGET_BIG_END				\
-   && (GET_MODE_SIZE (FROM) > UNITS_PER_WORD		\
-       || GET_MODE_SIZE (TO) > UNITS_PER_WORD)		\
+   GCC, so avoid taking subregs of such values.
+   The only exception is going from a 128-bit to a 64-bit type.  In that case
+   the data layout happens to be consistent for big-endian, so we explicitly allow
+   that case.  */
+#define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)		\
+  (TARGET_VFP && TARGET_BIG_END					\
+   && !(GET_MODE_SIZE (FROM) == 16 && GET_MODE_SIZE (TO) == 8)	\
+   && (GET_MODE_SIZE (FROM) > UNITS_PER_WORD			\
+       || GET_MODE_SIZE (TO) > UNITS_PER_WORD)			\
    && reg_classes_intersect_p (VFP_REGS, (CLASS)))
 
 /* The class value for index registers, and the one for base regs.  */
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index bec7450..a6414c4 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -5176,7 +5176,12 @@ static section * x86_64_elf_select_section (tree, int, unsigned HOST_WIDE_INT)
   /* Use register calling convention for local functions when possible.  */
   if (decl
       && TREE_CODE (decl) == FUNCTION_DECL
-      && optimize
+      /* Caller and callee must agree on the calling convention, so
+	 checking here just optimize means that with
+	 __attribute__((optimize (...))) caller could use regparm convention
+	 and callee not, or vice versa.  Instead look at whether the callee
+	 is optimized or not.  */
+      && opt_for_fn (decl, optimize)
       && !(profile_flag && !flag_fentry))
     {
       /* FIXME: remove this CONST_CAST when cgraph.[ch] is constified.  */
diff --git a/gcc/config/microblaze/microblaze.c b/gcc/config/microblaze/microblaze.c
index 058ba72..89793b0 100644
--- a/gcc/config/microblaze/microblaze.c
+++ b/gcc/config/microblaze/microblaze.c
@@ -3071,6 +3071,73 @@ enum reg_class microblaze_regno_to_class[] =
   return result;
 }
 
+static void
+microblaze_asm_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,
+        HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,
+        tree function)
+{
+  rtx this_rtx, insn, funexp;
+
+  reload_completed = 1;
+  epilogue_completed = 1;
+
+  /* Mark the end of the (empty) prologue.  */
+  emit_note (NOTE_INSN_PROLOGUE_END);
+
+  /* Find the "this" pointer.  If the function returns a structure,
+     the structure return pointer is in MB_ABI_FIRST_ARG_REGNUM.  */
+  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))
+    this_rtx = gen_rtx_REG (Pmode, (MB_ABI_FIRST_ARG_REGNUM + 1));
+  else
+    this_rtx = gen_rtx_REG (Pmode, MB_ABI_FIRST_ARG_REGNUM);
+
+  /* Apply the constant offset, if required.  */
+  if (delta)
+    emit_insn (gen_addsi3 (this_rtx, this_rtx, GEN_INT (delta)));
+
+  /* Apply the offset from the vtable, if required.  */
+  if (vcall_offset)
+  {
+    rtx vcall_offset_rtx = GEN_INT (vcall_offset);
+    rtx temp1 = gen_rtx_REG (Pmode, MB_ABI_TEMP1_REGNUM);
+
+    emit_move_insn (temp1, gen_rtx_MEM (Pmode, this_rtx));
+
+    rtx loc = gen_rtx_PLUS (Pmode, temp1, vcall_offset_rtx);
+    emit_move_insn (temp1, gen_rtx_MEM (Pmode, loc));
+
+    emit_insn (gen_addsi3 (this_rtx, this_rtx, temp1));
+  }
+
+  /* Generate a tail call to the target function.  */
+  if (!TREE_USED (function))
+  {
+    assemble_external (function);
+    TREE_USED (function) = 1;
+  }
+
+  funexp = XEXP (DECL_RTL (function), 0);
+  rtx temp2 = gen_rtx_REG (Pmode, MB_ABI_TEMP2_REGNUM);
+
+  if (flag_pic)
+    emit_move_insn (temp2, expand_pic_symbol_ref (Pmode, funexp));
+  else
+    emit_move_insn (temp2, funexp);
+
+  emit_insn (gen_indirect_jump (temp2));
+
+  /* Run just enough of rest_of_compilation.  This sequence was
+     "borrowed" from rs6000.c.  */
+  insn = get_insns ();
+  shorten_branches (insn);
+  final_start_function (insn, file, 1);
+  final (insn, file, 1);
+  final_end_function ();
+
+  reload_completed = 0;
+  epilogue_completed = 0;
+}
+
 bool
 microblaze_expand_move (enum machine_mode mode, rtx operands[])
 {
@@ -3241,65 +3308,45 @@ enum reg_class microblaze_regno_to_class[] =
   emit_move_insn (mem, fnaddr);
 }
 
-/* Emit instruction to perform compare.  
-   cmp is (compare_op op0 op1).  */
-static rtx
-microblaze_emit_compare (enum machine_mode mode, rtx cmp, enum rtx_code *cmp_code)
+/* Generate conditional branch -- first, generate test condition,
+   second, generate correct branch instruction.  */
+
+void
+microblaze_expand_conditional_branch (enum machine_mode mode, rtx operands[])
 {
-  rtx cmp_op0 = XEXP (cmp, 0);
-  rtx cmp_op1 = XEXP (cmp, 1);
+  enum rtx_code code = GET_CODE (operands[0]);
+  rtx cmp_op0 = operands[1];
+  rtx cmp_op1 = operands[2];
+  rtx label1 = operands[3];
   rtx comp_reg = gen_reg_rtx (SImode);
-  enum rtx_code code = *cmp_code;
-  
+  rtx condition;
+
   gcc_assert ((GET_CODE (cmp_op0) == REG) || (GET_CODE (cmp_op0) == SUBREG));
 
   /* If comparing against zero, just test source reg.  */
-  if (cmp_op1 == const0_rtx) 
-    return cmp_op0;
+  if (cmp_op1 == const0_rtx)
+    {
+      comp_reg = cmp_op0;
+      condition = gen_rtx_fmt_ee (signed_condition (code), SImode, comp_reg, const0_rtx);
+      emit_jump_insn (gen_condjump (condition, label1));
+    }
 
-  if (code == EQ || code == NE)
+  else if (code == EQ || code == NE)
     {
       /* Use xor for equal/not-equal comparison.  */
       emit_insn (gen_xorsi3 (comp_reg, cmp_op0, cmp_op1));
+      condition = gen_rtx_fmt_ee (signed_condition (code), SImode, comp_reg, const0_rtx);
+      emit_jump_insn (gen_condjump (condition, label1));
     }
-  else if (code == GT || code == GTU || code == LE || code == LEU)
-    {
-      /* MicroBlaze compare is not symmetrical.  */
-      /* Swap argument order.  */
-      cmp_op1 = force_reg (mode, cmp_op1);
-      if (code == GT || code == LE) 
-        emit_insn (gen_signed_compare (comp_reg, cmp_op0, cmp_op1));
-      else
-        emit_insn (gen_unsigned_compare (comp_reg, cmp_op0, cmp_op1));
-      /* Translate test condition.  */
-      *cmp_code = swap_condition (code);
-    }
-  else /* if (code == GE || code == GEU || code == LT || code == LTU) */
+  else
     {
+      /* Generate compare and branch in single instruction. */
       cmp_op1 = force_reg (mode, cmp_op1);
-      if (code == GE || code == LT) 
-        emit_insn (gen_signed_compare (comp_reg, cmp_op1, cmp_op0));
-      else
-        emit_insn (gen_unsigned_compare (comp_reg, cmp_op1, cmp_op0));
+      condition = gen_rtx_fmt_ee (code, mode, cmp_op0, cmp_op1);
+      emit_jump_insn (gen_branch_compare(condition, cmp_op0, cmp_op1, label1));
     }
-
-  return comp_reg;
 }
 
-/* Generate conditional branch -- first, generate test condition,
-   second, generate correct branch instruction.  */
-
-void
-microblaze_expand_conditional_branch (enum machine_mode mode, rtx operands[])
-{
-  enum rtx_code code = GET_CODE (operands[0]);
-  rtx comp;
-  rtx condition;
-
-  comp = microblaze_emit_compare (mode, operands[0], &code);
-  condition = gen_rtx_fmt_ee (signed_condition (code), SImode, comp, const0_rtx);
-  emit_jump_insn (gen_condjump (condition, operands[3]));
-}
 
 void
 microblaze_expand_conditional_branch_sf (rtx operands[])
@@ -3508,6 +3555,12 @@ enum reg_class microblaze_regno_to_class[] =
 #undef TARGET_SECONDARY_RELOAD
 #define TARGET_SECONDARY_RELOAD		microblaze_secondary_reload
 
+#undef  TARGET_ASM_OUTPUT_MI_THUNK
+#define TARGET_ASM_OUTPUT_MI_THUNK      microblaze_asm_output_mi_thunk
+
+#undef  TARGET_ASM_CAN_OUTPUT_MI_THUNK
+#define TARGET_ASM_CAN_OUTPUT_MI_THUNK  hook_bool_const_tree_hwi_hwi_const_tree_true
+
 #undef TARGET_SCHED_ADJUST_COST
 #define TARGET_SCHED_ADJUST_COST	microblaze_adjust_cost
 
diff --git a/gcc/config/microblaze/microblaze.h b/gcc/config/microblaze/microblaze.h
index 948520a..34c87c9 100644
--- a/gcc/config/microblaze/microblaze.h
+++ b/gcc/config/microblaze/microblaze.h
@@ -413,9 +413,6 @@ enum reg_class
 	  || GET_MODE (X) == VOIDmode)					\
 	 ? (GR_REGS) : (CLASS))))
 
-#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE)			\
-  (GET_MODE_CLASS (MODE) == MODE_INT)
-
 /* Stack layout; function entry, exit and calling.  */
 
 #define STACK_GROWS_DOWNWARD
diff --git a/gcc/config/microblaze/microblaze.md b/gcc/config/microblaze/microblaze.md
index bad1df5..f1913b3 100644
--- a/gcc/config/microblaze/microblaze.md
+++ b/gcc/config/microblaze/microblaze.md
@@ -1485,7 +1485,7 @@
   (set_attr "length"   "124")]
 )
 
-(define_insn "*ashlri_reg"
+(define_insn "*ashrsi_reg"
   [(set (match_operand:SI 0 "register_operand" "=&d")
        (ashiftrt:SI (match_operand:SI 1 "register_operand"  "d")
                    (match_operand:SI 2 "register_operand" "d")))]
@@ -1574,7 +1574,7 @@
   (set_attr "length"   "124")]
 )
 
-(define_insn "*lshlri_reg"
+(define_insn "*lshrsi_reg"
   [(set (match_operand:SI 0 "register_operand" "=&d")
        (lshiftrt:SI (match_operand:SI 1 "register_operand"  "d")
                    (match_operand:SI 2 "register_operand" "d")))]
@@ -1635,28 +1635,6 @@
   (set_attr "length"	"4")]
 )              
 
-(define_insn "signed_compare"
-  [(set (match_operand:SI 0 "register_operand" "=d")
-	(unspec
-		[(match_operand:SI 1 "register_operand" "d")
-		 (match_operand:SI 2 "register_operand" "d")] UNSPEC_CMP))]
-  ""
-  "cmp\t%0,%1,%2"
-  [(set_attr "type"	"arith")
-  (set_attr "mode"	"SI")
-  (set_attr "length"	"4")])
-
-(define_insn "unsigned_compare"
-  [(set (match_operand:SI 0 "register_operand" "=d")
-	(unspec 
-		[(match_operand:SI 1 "register_operand" "d")
-		 (match_operand:SI 2 "register_operand" "d")] UNSPEC_CMPU))]
-  ""
-  "cmpu\t%0,%1,%2"
-  [(set_attr "type"	"arith")
-  (set_attr "mode"	"SI")
-  (set_attr "length"	"4")])
-
 ;;----------------------------------------------------------------
 ;; Setting a register from an floating point comparison. 
 ;;----------------------------------------------------------------
@@ -1730,6 +1708,47 @@
    (set_attr "length"	"4")]
 )
 
+(define_insn "branch_compare"
+  [(set (pc)
+        (if_then_else (match_operator:SI 0 "cmp_op"
+                                         [(match_operand:SI 1 "register_operand" "d")
+                                          (match_operand:SI 2 "register_operand" "d")
+                                         ])
+                      (label_ref (match_operand 3))
+                      (pc)))
+  (clobber(reg:SI R_TMP))]
+  ""
+  {
+    operands[4] = gen_rtx_REG (SImode, MB_ABI_ASM_TEMP_REGNUM);
+    enum rtx_code code = GET_CODE (operands[0]);
+
+    if (code == GT || code == LE)
+      {
+        output_asm_insn ("cmp\tr18,%z1,%z2", operands);
+        code = swap_condition (code);
+      }
+    else if (code == GTU || code == LEU)
+      {
+        output_asm_insn ("cmpu\tr18,%z1,%z2", operands);
+        code = swap_condition (code);
+      }
+    else if (code == GE || code == LT)
+      {
+        output_asm_insn ("cmp\tr18,%z2,%z1", operands);
+      }
+    else if (code == GEU || code == LTU)
+      {
+        output_asm_insn ("cmpu\tr18,%z2,%z1", operands);
+      }
+
+    operands[0] = gen_rtx_fmt_ee (signed_condition (code), SImode, operands[4], const0_rtx);
+    return "b%C0i%?\tr18,%3";
+  }
+  [(set_attr "type"     "branch")
+   (set_attr "mode"     "none")
+   (set_attr "length"   "12")]
+)
+
 ;;----------------------------------------------------------------
 ;; Unconditional branches
 ;;----------------------------------------------------------------
diff --git a/gcc/config/microblaze/predicates.md b/gcc/config/microblaze/predicates.md
index 31d1e06..905d46a 100644
--- a/gcc/config/microblaze/predicates.md
+++ b/gcc/config/microblaze/predicates.md
@@ -123,3 +123,7 @@
 ;; Test for valid PIC call operand
 (define_predicate "call_insn_plt_operand"
   (match_test "PLT_ADDR_P (op)"))
+
+;; Return if the code of this rtx pattern is a comparison.
+(define_predicate "cmp_op"
+  (match_code "gt,ge,gtu,geu,lt,le,ltu,leu"))
diff --git a/gcc/config/pa/pa.c b/gcc/config/pa/pa.c
index 315b8a7..7603858 100644
--- a/gcc/config/pa/pa.c
+++ b/gcc/config/pa/pa.c
@@ -2629,14 +2629,14 @@ enum pa_builtins
   if (optype0 == REGOP)
     latehalf[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);
   else if (optype0 == OFFSOP)
-    latehalf[0] = adjust_address (operands[0], SImode, 4);
+    latehalf[0] = adjust_address_nv (operands[0], SImode, 4);
   else
     latehalf[0] = operands[0];
 
   if (optype1 == REGOP)
     latehalf[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);
   else if (optype1 == OFFSOP)
-    latehalf[1] = adjust_address (operands[1], SImode, 4);
+    latehalf[1] = adjust_address_nv (operands[1], SImode, 4);
   else if (optype1 == CNSTOP)
     split_double (operands[1], &operands[1], &latehalf[1]);
   else
diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index 4b0b8e2..7359cb7 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,3 +1,26 @@
+2014-02-28  Jason Merrill  <jason@redhat.com>
+
+	PR c++/58845
+	* typeck.c (cp_build_binary_op): Sorry on vector&&vector.
+
+2014-02-26  Jason Merrill  <jason@redhat.com>
+
+	PR c++/60182
+	* pt.c (unify): Ignore alias templates when deducing a template
+	template parameter.
+
+2014-02-24  Jason Merrill  <jason@redhat.com>
+
+	PR c++/60146
+	* pt.c (tsubst_omp_for_iterator): Don't let substitution of the
+	DECL_EXPR initialize a non-class iterator.
+
+2014-02-24  Fabien Chêne  <fabien@gcc.gnu.org>
+        PR c++/37140
+        * parser.c (cp_parser_nonclass_name): Call strip_using_decl and
+	move the code handling dependent USING_DECLs...
+        * name-lookup.c (strip_using_decl): ...Here.
+
 2014-02-21  Jason Merrill  <jason@redhat.com>
 
 	PR c++/60108
diff --git a/gcc/cp/name-lookup.c b/gcc/cp/name-lookup.c
index 5763b9b..da167ec 100644
--- a/gcc/cp/name-lookup.c
+++ b/gcc/cp/name-lookup.c
@@ -394,7 +394,8 @@ struct GTY(()) binding_table_s {
     }
 }
 
-/* Strip non dependent using declarations.  */
+/* Strip non dependent using declarations. If DECL is dependent,
+   surreptitiously create a typename_type and return it.  */
 
 tree
 strip_using_decl (tree decl)
@@ -404,6 +405,23 @@ struct GTY(()) binding_table_s {
 
   while (TREE_CODE (decl) == USING_DECL && !DECL_DEPENDENT_P (decl))
     decl = USING_DECL_DECLS (decl);
+
+  if (TREE_CODE (decl) == USING_DECL && DECL_DEPENDENT_P (decl)
+      && USING_DECL_TYPENAME_P (decl))
+    {
+      /* We have found a type introduced by a using
+	 declaration at class scope that refers to a dependent
+	 type.
+	     
+	 using typename :: [opt] nested-name-specifier unqualified-id ;
+      */
+      decl = make_typename_type (TREE_TYPE (decl),
+				 DECL_NAME (decl),
+				 typename_type, tf_error);
+      if (decl != error_mark_node)
+	decl = TYPE_NAME (decl);
+    }
+
   return decl;
 }
 
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index de30f73..c512d69 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -14164,25 +14164,7 @@ typedef struct GTY(()) tree_int
   /* Look up the type-name.  */
   type_decl = cp_parser_lookup_name_simple (parser, identifier, token->location);
 
-  if (TREE_CODE (type_decl) == USING_DECL)
-    {
-      if (!DECL_DEPENDENT_P (type_decl))
-	type_decl = strip_using_decl (type_decl);
-      else if (USING_DECL_TYPENAME_P (type_decl))
-	{
-	  /* We have found a type introduced by a using
-	     declaration at class scope that refers to a dependent
-	     type.
-	     
-	     using typename :: [opt] nested-name-specifier unqualified-id ;
-	  */
-	  type_decl = make_typename_type (TREE_TYPE (type_decl),
-					  DECL_NAME (type_decl),
-					  typename_type, tf_error);
-	  if (type_decl != error_mark_node)
-	    type_decl = TYPE_NAME (type_decl);
-	}
-    }
+  type_decl = strip_using_decl (type_decl);
   
   if (TREE_CODE (type_decl) != TYPE_DECL
       && (objc_is_id (identifier) || objc_is_class_name (identifier)))
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index b63b3d9..724707b 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -12703,27 +12703,43 @@ struct tinst_level *
   tsubst_expr ((NODE), args, complain, in_decl,	\
 	       integral_constant_expression_p)
   tree decl, init, cond, incr;
-  bool init_decl;
 
   init = TREE_VEC_ELT (OMP_FOR_INIT (t), i);
   gcc_assert (TREE_CODE (init) == MODIFY_EXPR);
   decl = TREE_OPERAND (init, 0);
   init = TREE_OPERAND (init, 1);
-  /* Do this before substituting into decl to handle 'auto'.  */
-  init_decl = (init && TREE_CODE (init) == DECL_EXPR);
-  init = RECUR (init);
-  decl = RECUR (decl);
-  if (init_decl)
+  tree decl_expr = NULL_TREE;
+  if (init && TREE_CODE (init) == DECL_EXPR)
     {
-      gcc_assert (!processing_template_decl);
-      init = DECL_INITIAL (decl);
-      DECL_INITIAL (decl) = NULL_TREE;
+      /* We need to jump through some hoops to handle declarations in the
+	 for-init-statement, since we might need to handle auto deduction,
+	 but we need to keep control of initialization.  */
+      decl_expr = init;
+      init = DECL_INITIAL (DECL_EXPR_DECL (init));
+      decl = tsubst_decl (decl, args, complain);
     }
+  else
+    decl = RECUR (decl);
+  init = RECUR (init);
+
+  tree auto_node = type_uses_auto (TREE_TYPE (decl));
+  if (auto_node && init)
+    TREE_TYPE (decl)
+      = do_auto_deduction (TREE_TYPE (decl), init, auto_node);
 
   gcc_assert (!type_dependent_expression_p (decl));
 
   if (!CLASS_TYPE_P (TREE_TYPE (decl)))
     {
+      if (decl_expr)
+	{
+	  /* Declare the variable, but don't let that initialize it.  */
+	  tree init_sav = DECL_INITIAL (DECL_EXPR_DECL (decl_expr));
+	  DECL_INITIAL (DECL_EXPR_DECL (decl_expr)) = NULL_TREE;
+	  RECUR (decl_expr);
+	  DECL_INITIAL (DECL_EXPR_DECL (decl_expr)) = init_sav;
+	}
+
       cond = RECUR (TREE_VEC_ELT (OMP_FOR_COND (t), i));
       incr = TREE_VEC_ELT (OMP_FOR_INCR (t), i);
       if (TREE_CODE (incr) == MODIFY_EXPR)
@@ -12740,7 +12756,13 @@ struct tinst_level *
       return;
     }
 
-  if (init && !init_decl)
+  if (decl_expr)
+    {
+      /* Declare and initialize the variable.  */
+      RECUR (decl_expr);
+      init = NULL_TREE;
+    }
+  else if (init)
     {
       tree c;
       for (c = *clauses; c ; c = OMP_CLAUSE_CHAIN (c))
@@ -16596,9 +16618,11 @@ struct tinst_level *
 	  if (TREE_CODE (arg) != BOUND_TEMPLATE_TEMPLATE_PARM
 	      && !CLASSTYPE_SPECIALIZATION_OF_PRIMARY_TEMPLATE_P (arg))
 	    return unify_template_deduction_failure (explain_p, parm, arg);
-
 	  {
 	    tree parmvec = TYPE_TI_ARGS (parm);
+	    /* An alias template name is never deduced.  */
+	    if (TYPE_ALIAS_P (arg))
+	      arg = strip_typedefs (arg);
 	    tree argvec = INNERMOST_TEMPLATE_ARGS (TYPE_TI_ARGS (arg));
 	    tree full_argvec = add_to_template_args (targs, argvec);
 	    tree parm_parms 
diff --git a/gcc/cp/typeck.c b/gcc/cp/typeck.c
index 299e1f4..b8e862c 100644
--- a/gcc/cp/typeck.c
+++ b/gcc/cp/typeck.c
@@ -4103,6 +4103,11 @@ enum_cast_to_int (tree op)
     case TRUTH_ORIF_EXPR:
     case TRUTH_AND_EXPR:
     case TRUTH_OR_EXPR:
+      if (TREE_CODE (type0) == VECTOR_TYPE || TREE_CODE (type1) == VECTOR_TYPE)
+	{
+	  sorry ("logical operation on vector type");
+	  return error_mark_node;
+	}
       result_type = boolean_type_node;
       break;
 
diff --git a/gcc/expr.c b/gcc/expr.c
index d39bdce..01697e9 100644
--- a/gcc/expr.c
+++ b/gcc/expr.c
@@ -3611,12 +3611,21 @@ static void expand_operands (tree, tree, rtx, rtx*, rtx*,
 	 into a new pseudo.  This constant may be used in different modes,
 	 and if not, combine will put things back together for us.  */
       trunc_y = force_reg (srcmode, trunc_y);
-      emit_unop_insn (ic, x, trunc_y, UNKNOWN);
+
+      /* If x is a hard register, perform the extension into a pseudo,
+	 so that e.g. stack realignment code is aware of it.  */
+      rtx target = x;
+      if (REG_P (x) && HARD_REGISTER_P (x))
+	target = gen_reg_rtx (dstmode);
+
+      emit_unop_insn (ic, target, trunc_y, UNKNOWN);
       last_insn = get_last_insn ();
 
-      if (REG_P (x))
+      if (REG_P (target))
 	set_unique_reg_note (last_insn, REG_EQUAL, y);
 
+      if (target != x)
+	return emit_move_insn (x, target);
       return last_insn;
     }
 
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index 2a5c5a2..db89c5f 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -1,3 +1,24 @@
+2014-03-08  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/60450
+	* simplify.c (gfc_simplify_shape): Only clear shape if it was really
+	created successfully.
+
+2014-03-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2014-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/52370
+	* trans-decl.c (gfc_build_dummy_array_decl): Set TREE_NO_WARNING
+	on decl if sym->attr.optional.
+
+2014-03-02  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/60341
+	* frontend-passes.c (optimize_comparison): Guard two union accesses
+	with the corresponding tag checks.
+
 2014-02-22  Mikael Morin  <mikael@gcc.gnu.org>
 
 	PR fortran/59599
diff --git a/gcc/fortran/frontend-passes.c b/gcc/fortran/frontend-passes.c
index fdfbce0..3dbe8fe 100644
--- a/gcc/fortran/frontend-passes.c
+++ b/gcc/fortran/frontend-passes.c
@@ -1214,7 +1214,9 @@
 	  /* Replace A // B < A // C with B < C, and A // B < C // B
 	     with A < C.  */
 	  if (op1->ts.type == BT_CHARACTER && op2->ts.type == BT_CHARACTER
+	      && op1->expr_type == EXPR_OP
 	      && op1->value.op.op == INTRINSIC_CONCAT
+	      && op2->expr_type == EXPR_OP
 	      && op2->value.op.op == INTRINSIC_CONCAT)
 	    {
 	      gfc_expr *op1_left = op1->value.op.op1;
diff --git a/gcc/fortran/simplify.c b/gcc/fortran/simplify.c
index b03096b..7c21f22 100644
--- a/gcc/fortran/simplify.c
+++ b/gcc/fortran/simplify.c
@@ -5528,7 +5528,7 @@ static gfc_expr* gfc_count (gfc_expr *op1, gfc_expr *op2)
       if (e == &gfc_bad_expr || range_check (e, "SHAPE") == &gfc_bad_expr)
 	{
 	  gfc_free_expr (result);
-	  if (t)
+	  if (t == SUCCESS)
 	    gfc_clear_shape (shape, source->rank);
 	  return &gfc_bad_expr;
 	}
@@ -5536,7 +5536,7 @@ static gfc_expr* gfc_count (gfc_expr *op1, gfc_expr *op2)
       gfc_constructor_append_expr (&result->value.constructor, e, NULL);
     }
 
-  if (t)
+  if (t == SUCCESS)
     gfc_clear_shape (shape, source->rank);
 
   return result;
diff --git a/gcc/fortran/trans-decl.c b/gcc/fortran/trans-decl.c
index 43f918b..7d235618 100644
--- a/gcc/fortran/trans-decl.c
+++ b/gcc/fortran/trans-decl.c
@@ -1013,6 +1013,10 @@
   TREE_STATIC (decl) = 0;
   DECL_EXTERNAL (decl) = 0;
 
+  /* Avoid uninitialized warnings for optional dummy arguments.  */
+  if (sym->attr.optional)
+    TREE_NO_WARNING (decl) = 1;
+
   /* We should never get deferred shape arrays here.  We used to because of
      frontend bugs.  */
   gcc_assert (sym->as->type != AS_DEFERRED);
diff --git a/gcc/ipa-cp.c b/gcc/ipa-cp.c
index 44a5e17..7566469 100644
--- a/gcc/ipa-cp.c
+++ b/gcc/ipa-cp.c
@@ -444,6 +444,9 @@ struct ipcp_param_lattices
     reason = "not a tree_versionable_function";
   else if (cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)
     reason = "insufficient body availability";
+  else if (!opt_for_fn (node->symbol.decl, optimize)
+	   || !opt_for_fn (node->symbol.decl, flag_ipa_cp))
+    reason = "non-optimized function";
 
   if (reason && dump_file && !node->alias && !node->thunk.thunk_p)
     fprintf (dump_file, "Function %s/%i is not versionable, reason: %s.\n",
diff --git a/gcc/params.def b/gcc/params.def
index cb25def..e51b847 100644
--- a/gcc/params.def
+++ b/gcc/params.def
@@ -1014,6 +1014,12 @@ DEFPARAM (PARAM_MAX_SLSR_CANDIDATE_SCAN,
 	  "strength reduction",
 	  50, 1, 999999)
 
+DEFPARAM (PARAM_UNINIT_CONTROL_DEP_ATTEMPTS,
+	  "uninit-control-dep-attempts",
+	  "Maximum number of nested calls to search for control dependencies "
+	  "during uninitialized variable analysis",
+	  1000, 1, 0)
+
 /*
 Local variables:
 mode:c
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 1f75060..f5f0edf 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,104 @@
+2014-03-08  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/60450
+	* gfortran.dg/shape_8.f90: New.
+
+2014-03-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2014-02-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/37743
+	* g++.dg/ext/builtin-bswap1.C: New test.
+	* c-c++-common/pr37743.c: New test.
+
+	PR preprocessor/58844
+	* c-c++-common/cpp/pr58844-1.c: New test.
+	* c-c++-common/cpp/pr58844-2.c: New test.
+
+	2014-02-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/43546
+	* gcc.target/i386/pr43546.c: New test.
+
+	2014-02-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/60101
+	* c-c++-common/pr60101.c: New test.
+
+	2014-02-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/52370
+	* gfortran.dg/pr52370.f90: New test.
+
+	PR debug/59776
+	* gcc.dg/guality/pr59776.c: New test.
+
+	2014-02-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/56824
+	* gcc.dg/pr56824.c: New test.
+
+	2014-02-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/60062
+	* gcc.c-torture/execute/pr60062.c: New test.
+	* gcc.c-torture/execute/pr60072.c: New test.
+
+	2014-02-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/60026
+	* c-c++-common/torture/pr60026.c: New test.
+
+	2014-02-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/57499
+	* g++.dg/torture/pr57499.C: New test.
+
+	2014-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/60400
+	* c-c++-common/cpp/pr60400.c: New test.
+	* c-c++-common/cpp/pr60400-1.h: New file.
+	* c-c++-common/cpp/pr60400-2.h: New file.
+
+2014-03-04  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/60382
+	* gcc.dg/vect/pr60382.c: New testcase.
+
+2014-03-02  Mikael Morin  <mikael@gcc.gnu.org>
+
+	PR fortran/60341
+	* gfortran.dg/str_comp_optimize_1.f90: New test.
+
+2014-02-25  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-02-21  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/60276
+	* gcc.dg/vect/pr60276.c: New testcase.
+
+2014-02-25  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-02-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/60183
+	* gcc.dg/torture/pr60183.c: New testcase.
+
+2014-02-24  Fabien Chêne  <fabien@gcc.gnu.org>
+
+	PR c++/37140
+	* g++.dg/template/using27.C: New.
+	* g++.dg/template/using28.C: New.
+	* g++.dg/template/using29.C: New.
+
+2014-02-23  David Holsgrove <david.holsgrove@xilinx.com>
+
+	* gcc/testsuite/gcc.target/microblaze/others/mem_reload.c: New test.
+
 2014-02-22  Mikael Morin  <mikael@gcc.gnu.org>
 
 	PR fortran/59599
diff --git a/gcc/testsuite/c-c++-common/cpp/pr58844-1.c b/gcc/testsuite/c-c++-common/cpp/pr58844-1.c
new file mode 100644
index 0000000..3abf8a7
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/cpp/pr58844-1.c
@@ -0,0 +1,8 @@
+/* PR preprocessor/58844 */
+/* { dg-do compile } */
+/* { dg-options "-ftrack-macro-expansion=0" } */
+
+#define A x######x
+int A = 1;
+#define A x######x	/* { dg-message "previous definition" } */
+#define A x##x		/* { dg-warning "redefined" } */
diff --git a/gcc/testsuite/c-c++-common/cpp/pr58844-2.c b/gcc/testsuite/c-c++-common/cpp/pr58844-2.c
new file mode 100644
index 0000000..1e21915
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/cpp/pr58844-2.c
@@ -0,0 +1,8 @@
+/* PR preprocessor/58844 */
+/* { dg-do compile } */
+/* { dg-options "-ftrack-macro-expansion=2" } */
+
+#define A x######x
+int A = 1;
+#define A x######x	/* { dg-message "previous definition" } */
+#define A x##x		/* { dg-warning "redefined" } */
diff --git a/gcc/testsuite/c-c++-common/cpp/pr60400-1.h b/gcc/testsuite/c-c++-common/cpp/pr60400-1.h
new file mode 100644
index 0000000..3e32175
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/cpp/pr60400-1.h
@@ -0,0 +1,3 @@
+??=ifndef PR60400_1_H
+??=define PR60400_1_H
+??=endif
diff --git a/gcc/testsuite/c-c++-common/cpp/pr60400-2.h b/gcc/testsuite/c-c++-common/cpp/pr60400-2.h
new file mode 100644
index 0000000..d9a5906
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/cpp/pr60400-2.h
@@ -0,0 +1,4 @@
+??=ifndef PR60400_2_H
+??=define PR60400_2_H
+??=include "pr60400-1.h"
+??=endif
diff --git a/gcc/testsuite/c-c++-common/cpp/pr60400.c b/gcc/testsuite/c-c++-common/cpp/pr60400.c
new file mode 100644
index 0000000..fc3e0d9
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/cpp/pr60400.c
@@ -0,0 +1,13 @@
+/* PR preprocessor/60400 */
+/* { dg-do compile } */
+/* { dg-options "-trigraphs -Wtrigraphs" } */
+
+??=include "pr60400-1.h"
+??=include "pr60400-2.h"
+
+/* { dg-warning "trigraph" "" { target *-*-* } 1 } */
+/* { dg-warning "trigraph" "" { target *-*-* } 2 } */
+/* { dg-warning "trigraph" "" { target *-*-* } 3 } */
+/* { dg-warning "trigraph" "" { target *-*-* } 4 } */
+/* { dg-warning "trigraph" "" { target *-*-* } 5 } */
+/* { dg-warning "trigraph" "" { target *-*-* } 6 } */
diff --git a/gcc/testsuite/c-c++-common/pr37743.c b/gcc/testsuite/c-c++-common/pr37743.c
new file mode 100644
index 0000000..2ea678e
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr37743.c
@@ -0,0 +1,13 @@
+/* PR c/37743 */
+/* This needs to be run only on targets where __UINT32_TYPE__ is defined
+   to unsigned int.  */
+/* { dg-do compile { target *-*-linux-gnu* } } */
+/* { dg-options "-Wformat" } */
+
+int foo (const char *, ...) __attribute__ ((format (printf, 1, 2)));
+
+void
+bar (unsigned int x)
+{
+  foo ("%x", __builtin_bswap32 (x));
+}
diff --git a/gcc/testsuite/c-c++-common/pr60101.c b/gcc/testsuite/c-c++-common/pr60101.c
new file mode 100644
index 0000000..b1634c4
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/pr60101.c
@@ -0,0 +1,112 @@
+/* PR c/60101 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wall" } */
+
+extern int *a, b, *c, *d;
+
+void
+foo (double _Complex *x, double _Complex *y, double _Complex *z, unsigned int l, int w)
+{
+  unsigned int e = (unsigned int) a[3];
+  double _Complex (*v)[l][4][e][l][4] = (double _Complex (*)[l][4][e][l][4]) z;
+  double _Complex (*f)[l][b][l] = (double _Complex (*)[l][b][l]) y;
+  unsigned int g = c[0] * c[1] * c[2];
+  unsigned int h = d[0] + c[0] * (d[1] + c[1] * d[2]);
+  unsigned int i;
+
+  for (i = 0; i < e; i++)
+    {
+      int j = e * d[3] + i;
+
+      unsigned int n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11;
+      float _Complex s = 0.;
+      unsigned int t = 0;
+
+      for (n0 = 0; n0 < l; n0++)
+	for (n1 = 0; n1 < l; n1++)
+	  for (n2 = 0; n2 < l; n2++)
+	    for (n3 = 0; n3 < l; n3++)
+	      for (n4 = 0; n4 < l; n4++)
+		for (n5 = 0; n5 < l; n5++)
+		  for (n6 = 0; n6 < l; n6++)
+		    for (n7 = 0; n7 < l; n7++)
+		      for (n8 = 0; n8 < l; n8++)
+			for (n9 = 0; n9 < l; n9++)
+			  for (n10 = 0; n10 < l; n10++)
+			    for (n11 = 0; n11 < l; n11++)
+			      {
+				if (t % g == h)
+				  s
+				    += f[n0][n4][j][n8] * f[n1][n5][j][n9] * ~(f[n2][n6][w][n10]) * ~(f[n3][n7][w][n11])
+				       * (+0.25 * v[0][n2][0][i][n9][1] * v[0][n3][0][i][n5][1] * v[0][n10][0][i][n4][1]
+					  * v[0][n7][1][i][n8][0] * v[0][n11][1][i][n1][0] * v[0][n6][1][i][n0][0]
+					  + 0.25 * v[0][n2][0][i][n9][1] * v[0][n3][0][i][n5][1] * v[0][n10][0][i][n4][1]
+					  * v[0][n11][1][i][n8][0] * v[0][n6][1][i][n1][0] * v[0][n7][1][i][n0][0]
+					  - 0.5 * v[0][n2][0][i][n9][1] * v[0][n3][0][i][n5][1] * v[0][n10][0][i][n4][1]
+					  * v[0][n11][1][i][n8][0] * v[0][n7][1][i][n1][0] * v[0][n6][1][i][n0][0]
+					  + 0.25 * v[0][n2][0][i][n9][1] * v[0][n10][0][i][n5][1] * v[0][n3][0][i][n4][1]
+					  * v[0][n7][1][i][n8][0] * v[0][n6][1][i][n1][0] * v[0][n11][1][i][n0][0]
+					  - 0.5 * v[0][n2][0][i][n9][1] * v[0][n10][0][i][n5][1] * v[0][n3][0][i][n4][1]
+					  * v[0][n11][1][i][n8][0] * v[0][n6][1][i][n1][0] * v[0][n7][1][i][n0][0]
+					  + 0.25 * v[0][n2][0][i][n9][1] * v[0][n10][0][i][n5][1] * v[0][n3][0][i][n4][1]
+					  * v[0][n11][1][i][n8][0] * v[0][n7][1][i][n1][0] * v[0][n6][1][i][n0][0]
+					  + 0.25 * v[0][n3][0][i][n9][1] * v[0][n2][0][i][n5][1] * v[0][n10][0][i][n4][1]
+					  * v[0][n6][1][i][n8][0] * v[0][n11][1][i][n1][0] * v[0][n7][1][i][n0][0]
+					  - 0.5 * v[0][n3][0][i][n9][1] * v[0][n2][0][i][n5][1] * v[0][n10][0][i][n4][1]
+					  * v[0][n11][1][i][n8][0] * v[0][n6][1][i][n1][0] * v[0][n7][1][i][n0][0]
+					  + 0.25 * v[0][n3][0][i][n9][1] * v[0][n2][0][i][n5][1] * v[0][n10][0][i][n4][1]
+					  * v[0][n11][1][i][n8][0] * v[0][n7][1][i][n1][0] * v[0][n6][1][i][n0][0]
+					  + 0.25 * v[0][n3][0][i][n9][1] * v[0][n10][0][i][n5][1] * v[0][n2][0][i][n4][1]
+					  * v[0][n6][1][i][n8][0] * v[0][n7][1][i][n1][0] * v[0][n11][1][i][n0][0]
+					  + 0.25 * v[0][n3][0][i][n9][1] * v[0][n10][0][i][n5][1] * v[0][n2][0][i][n4][1]
+					  * v[0][n11][1][i][n8][0] * v[0][n6][1][i][n1][0] * v[0][n7][1][i][n0][0]
+					  - 0.5 * v[0][n3][0][i][n9][1] * v[0][n10][0][i][n5][1] * v[0][n2][0][i][n4][1]
+					  * v[0][n11][1][i][n8][0] * v[0][n7][1][i][n1][0] * v[0][n6][1][i][n0][0]
+					  + 0.25 * v[0][n10][0][i][n9][1] * v[0][n2][0][i][n5][1] * v[0][n3][0][i][n4][1]
+					  * v[0][n6][1][i][n8][0] * v[0][n7][1][i][n1][0] * v[0][n11][1][i][n0][0]
+					  - 0.5 * v[0][n10][0][i][n9][1] * v[0][n2][0][i][n5][1] * v[0][n3][0][i][n4][1]
+					  * v[0][n6][1][i][n8][0] * v[0][n11][1][i][n1][0] * v[0][n7][1][i][n0][0]
+					  - 0.5 * v[0][n10][0][i][n9][1] * v[0][n2][0][i][n5][1] * v[0][n3][0][i][n4][1]
+					  * v[0][n7][1][i][n8][0] * v[0][n6][1][i][n1][0] * v[0][n11][1][i][n0][0]
+					  + 0.25 * v[0][n10][0][i][n9][1] * v[0][n2][0][i][n5][1] * v[0][n3][0][i][n4][1]
+					  * v[0][n7][1][i][n8][0] * v[0][n11][1][i][n1][0] * v[0][n6][1][i][n0][0]
+					  + 1. * v[0][n10][0][i][n9][1] * v[0][n2][0][i][n5][1] * v[0][n3][0][i][n4][1]
+					  * v[0][n11][1][i][n8][0] * v[0][n6][1][i][n1][0] * v[0][n7][1][i][n0][0]
+					  - 0.5 * v[0][n10][0][i][n9][1] * v[0][n2][0][i][n5][1] * v[0][n3][0][i][n4][1]
+					  * v[0][n11][1][i][n8][0] * v[0][n7][1][i][n1][0] * v[0][n6][1][i][n0][0]
+					  - 0.5 * v[0][n10][0][i][n9][1] * v[0][n3][0][i][n5][1] * v[0][n2][0][i][n4][1]
+					  * v[0][n6][1][i][n8][0] * v[0][n7][1][i][n1][0] * v[0][n11][1][i][n0][0]
+					  + 0.25 * v[0][n10][0][i][n9][1] * v[0][n3][0][i][n5][1] * v[0][n2][0][i][n4][1]
+					  * v[0][n6][1][i][n8][0] * v[0][n11][1][i][n1][0] * v[0][n7][1][i][n0][0]
+					  + 0.25 * v[0][n10][0][i][n9][1] * v[0][n3][0][i][n5][1] * v[0][n2][0][i][n4][1]
+					  * v[0][n7][1][i][n8][0] * v[0][n6][1][i][n1][0] * v[0][n11][1][i][n0][0]
+					  - 0.5 * v[0][n10][0][i][n9][1] * v[0][n3][0][i][n5][1] * v[0][n2][0][i][n4][1]
+					  * v[0][n7][1][i][n8][0] * v[0][n11][1][i][n1][0] * v[0][n6][1][i][n0][0]
+					  - 0.5 * v[0][n10][0][i][n9][1] * v[0][n3][0][i][n5][1] * v[0][n2][0][i][n4][1]
+					  * v[0][n11][1][i][n8][0] * v[0][n6][1][i][n1][0] * v[0][n7][1][i][n0][0]
+					  + 1. * v[0][n10][0][i][n9][1] * v[0][n3][0][i][n5][1] * v[0][n2][0][i][n4][1]
+					  * v[0][n11][1][i][n8][0] * v[0][n7][1][i][n1][0] * v[0][n6][1][i][n0][0]
+					  + 0.5 * v[0][n6][1][i][n4][1] * v[0][n2][0][i][n9][1] * v[0][n3][0][i][n5][1]
+					  * v[0][n7][1][i][n1][0] * v[0][n11][1][i][n0][0] * v[0][n10][0][i][n8][0]
+					  - 0.25 * v[0][n6][1][i][n4][1] * v[0][n2][0][i][n9][1] * v[0][n3][0][i][n5][1]
+					  * v[0][n11][1][i][n1][0] * v[0][n7][1][i][n0][0] * v[0][n10][0][i][n8][0]
+					  - 0.25 * v[0][n6][1][i][n4][1] * v[0][n2][0][i][n9][1] * v[0][n3][0][i][n5][1]
+					  * v[0][n7][1][i][n8][0] * v[0][n11][1][i][n0][0] * v[0][n10][0][i][n1][0]
+					  + 0.25 * v[0][n6][1][i][n4][1] * v[0][n2][0][i][n9][1] * v[0][n3][0][i][n5][1]
+					  * v[0][n7][1][i][n8][0] * v[0][n11][1][i][n1][0] * v[0][n10][0][i][n0][0]
+					  + 0.25 * v[0][n6][1][i][n4][1] * v[0][n2][0][i][n9][1] * v[0][n3][0][i][n5][1]
+					  * v[0][n11][1][i][n8][0] * v[0][n7][1][i][n0][0] * v[0][n10][0][i][n1][0]
+					  - 0.5 * v[0][n6][1][i][n4][1] * v[0][n2][0][i][n9][1] * v[0][n3][0][i][n5][1]
+					  * v[0][n11][1][i][n8][0] * v[0][n7][1][i][n1][0] * v[0][n10][0][i][n0][0]
+					  - 0.25 * v[0][n6][1][i][n4][1] * v[0][n2][0][i][n9][1] * v[0][n10][0][i][n5][1]
+					  * v[0][n7][1][i][n1][0] * v[0][n11][1][i][n0][0] * v[0][n3][0][i][n8][0]
+					  - 0.25 * v[0][n6][1][i][n4][1] * v[0][n2][0][i][n9][1] * v[0][n10][0][i][n5][1]
+					  * v[0][n7][1][i][n8][0] * v[0][n11][1][i][n0][0] * v[0][n3][0][i][n1][0]);
+				t++;
+			      }
+      int u = (j - w + b) % b;
+      int q = (j >= w ? +1 : -1);
+      int r = q;
+      x[u] += r * s;
+    }
+}
diff --git a/gcc/testsuite/c-c++-common/torture/pr60026.c b/gcc/testsuite/c-c++-common/torture/pr60026.c
new file mode 100644
index 0000000..1cc5f55
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/torture/pr60026.c
@@ -0,0 +1,28 @@
+/* PR ipa/60026 */
+/* { dg-do compile } */
+
+struct S { int f; } a;
+
+__attribute__((optimize (0)))
+struct S foo (int x, struct S y)
+{
+  int b = y.f;
+  return a; 
+}
+
+void
+bar ()
+{
+  while (a.f)
+    {
+      struct S c = {0};
+      foo (0, c);
+    }
+}
+
+int
+main ()
+{
+  bar (); 
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/cpp0x/alias-decl-41.C b/gcc/testsuite/g++.dg/cpp0x/alias-decl-41.C
new file mode 100644
index 0000000..c444217
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/alias-decl-41.C
@@ -0,0 +1,18 @@
+// PR c++/60182
+// { dg-require-effective-target c++11 }
+
+class B {};
+template <typename> using __allocator_base = B;
+template <typename> class F : __allocator_base<int> {};
+class C {};
+template <typename, typename = F<int> > class G : C {};
+template <typename> class D;
+class A {
+  using Container = G<D<char>>;
+  A();
+  A(D<char> const &);
+  Container m_elements;
+};
+template <template <class, class> class C, class A = F<D<int>>>
+void doSomething(C<D<char>, A> &);
+A::A(D<char> const &) : A() { doSomething(m_elements); }
diff --git a/gcc/testsuite/g++.dg/ext/builtin-bswap1.C b/gcc/testsuite/g++.dg/ext/builtin-bswap1.C
new file mode 100644
index 0000000..787ecba
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/builtin-bswap1.C
@@ -0,0 +1,22 @@
+// PR c/37743
+// { dg-do compile }
+
+#if defined(__UINT32_TYPE__) && defined(__INT32_TYPE__)
+
+void foo (__UINT32_TYPE__);
+void foo (__INT32_TYPE__);
+
+void
+bar (__UINT32_TYPE__ x)
+{
+  foo (__builtin_bswap32 (x));
+}
+
+#else
+
+void
+bar ()
+{
+}
+
+#endif
diff --git a/gcc/testsuite/g++.dg/ext/vector27.C b/gcc/testsuite/g++.dg/ext/vector27.C
new file mode 100644
index 0000000..288e13c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/vector27.C
@@ -0,0 +1,7 @@
+// PR c++/58845
+
+void foo()
+{
+  int v __attribute__((vector_size(8)));
+  v = v || v;			// { dg-bogus "" "" { xfail *-*-* } }
+}
diff --git a/gcc/testsuite/g++.dg/gomp/for-20.C b/gcc/testsuite/g++.dg/gomp/for-20.C
new file mode 100644
index 0000000..7b57b16
--- /dev/null
+++ b/gcc/testsuite/g++.dg/gomp/for-20.C
@@ -0,0 +1,16 @@
+// PR c++/60146
+// { dg-do compile }
+// { dg-options -fopenmp }
+
+int foo() { return 0; }
+
+template<typename T> void bar()
+{
+#pragma omp parallel for
+  for (T i = foo(); i < 8; ++i) {}
+}
+
+void baz()
+{
+  bar<int>();
+}
diff --git a/gcc/testsuite/g++.dg/template/using27.C b/gcc/testsuite/g++.dg/template/using27.C
new file mode 100644
index 0000000..f1835e1
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/using27.C
@@ -0,0 +1,33 @@
+// PR c++/37140
+
+struct X
+{
+  typedef int nested_type;
+};
+
+template <class T>
+struct A
+{
+  typedef X type;
+};
+
+template <class T>
+struct B : A<T>
+{
+  using typename A<T>::type;
+  typename type::nested_type x;
+};
+
+template <class T> 
+struct C : B<T>
+{
+  using typename B<T>::type;
+  typename type::nested_type y;
+};
+
+struct D : C<int>
+{
+  using C<int>::type;
+  type::nested_type z;
+};
+
diff --git a/gcc/testsuite/g++.dg/template/using28.C b/gcc/testsuite/g++.dg/template/using28.C
new file mode 100644
index 0000000..52f68cf
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/using28.C
@@ -0,0 +1,17 @@
+// PR c++/37140
+
+struct C
+{
+  static const int block_size = 1;
+};
+
+template <typename T> struct A {
+  typedef C type;
+};
+
+template <typename T> struct B : public A<T> {
+  using typename A<T>::type;
+  static const int block_size = type::block_size;
+};
+
+template class B<int>;
diff --git a/gcc/testsuite/g++.dg/template/using29.C b/gcc/testsuite/g++.dg/template/using29.C
new file mode 100644
index 0000000..8726547
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/using29.C
@@ -0,0 +1,21 @@
+// PR c++/58047
+
+template <int N>
+struct print_arg { };
+
+struct const_holder {
+  static const int CONSTANT = 42;
+};
+
+template <typename T>
+struct identity {
+  typedef T type;
+};
+
+template <class T>
+struct test_case : public identity<T> {
+  using typename identity<T>::type;
+  print_arg<type::CONSTANT> printer;
+};
+
+template struct test_case<const_holder>;
diff --git a/gcc/testsuite/g++.dg/torture/pr57499.C b/gcc/testsuite/g++.dg/torture/pr57499.C
new file mode 100644
index 0000000..fd985a1
--- /dev/null
+++ b/gcc/testsuite/g++.dg/torture/pr57499.C
@@ -0,0 +1,14 @@
+// PR middle-end/57499
+// { dg-do compile }
+
+struct S
+{
+  ~S () __attribute__ ((noreturn)) {} // { dg-warning "function does return" }
+};
+
+void
+foo ()
+{
+  S s;
+  throw 1;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr60062.c b/gcc/testsuite/gcc.c-torture/execute/pr60062.c
new file mode 100644
index 0000000..62973d4
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr60062.c
@@ -0,0 +1,25 @@
+/* PR target/60062 */
+
+int a;
+
+static void
+foo (const char *p1, int p2)
+{
+  if (__builtin_strcmp (p1, "hello") != 0)
+    __builtin_abort ();
+}
+
+static void
+bar (const char *p1)
+{
+  if (__builtin_strcmp (p1, "hello") != 0)
+    __builtin_abort ();
+}
+
+__attribute__((optimize (0))) int
+main ()
+{
+  foo ("hello", a);
+  bar ("hello");
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr60072.c b/gcc/testsuite/gcc.c-torture/execute/pr60072.c
new file mode 100644
index 0000000..566874d
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr60072.c
@@ -0,0 +1,16 @@
+/* PR target/60072 */
+
+int c = 1;
+
+__attribute__ ((optimize (1)))
+static int *foo (int *p)
+{
+  return p;
+}
+
+int
+main ()
+{
+  *foo (&c) = 2;
+  return c - 2;
+}
diff --git a/gcc/testsuite/gcc.dg/guality/pr59776.c b/gcc/testsuite/gcc.dg/guality/pr59776.c
new file mode 100644
index 0000000..382abb6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/guality/pr59776.c
@@ -0,0 +1,29 @@
+/* PR debug/59776 */
+/* { dg-do run } */
+/* { dg-options "-g" } */
+
+#include "../nop.h"
+
+struct S { float f, g; };
+
+__attribute__((noinline, noclone)) void
+foo (struct S *p)
+{
+  struct S s1, s2;			/* { dg-final { gdb-test pr59776.c:17 "s1.f" "5.0" } } */
+  s1 = *p;				/* { dg-final { gdb-test pr59776.c:17 "s1.g" "6.0" } } */
+  s2 = s1;				/* { dg-final { gdb-test pr59776.c:17 "s2.f" "0.0" } } */
+  *(int *) &s2.f = 0;			/* { dg-final { gdb-test pr59776.c:17 "s2.g" "6.0" } } */
+  asm volatile (NOP : : : "memory");	/* { dg-final { gdb-test pr59776.c:20 "s1.f" "5.0" } } */
+  asm volatile (NOP : : : "memory");	/* { dg-final { gdb-test pr59776.c:20 "s1.g" "6.0" } } */
+  s2 = s1;				/* { dg-final { gdb-test pr59776.c:20 "s2.f" "5.0" } } */
+  asm volatile (NOP : : : "memory");	/* { dg-final { gdb-test pr59776.c:20 "s2.g" "6.0" } } */
+  asm volatile (NOP : : : "memory");
+}
+
+int
+main ()
+{
+  struct S x = { 5.0f, 6.0f };
+  foo (&x);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr56824.c b/gcc/testsuite/gcc.dg/pr56824.c
new file mode 100644
index 0000000..d682d0a
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr56824.c
@@ -0,0 +1,18 @@
+/* PR preprocessor/56824 */
+/* { dg-do compile } */
+/* { dg-options "-Waggregate-return" } */
+
+struct S { int i; };
+struct S foo (void);
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Waggregate-return"
+
+int
+main ()
+{
+  foo ();
+  return 0;
+}
+
+#pragma GCC diagnostic pop
diff --git a/gcc/testsuite/gcc.dg/torture/pr60183.c b/gcc/testsuite/gcc.dg/torture/pr60183.c
new file mode 100644
index 0000000..d37b4b8
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr60183.c
@@ -0,0 +1,38 @@
+/* { dg-do run } */
+
+/* Large so an out-of-bound read will crash.  */
+unsigned char c[0x30001] = { 1 };
+int j = 2;
+
+static void
+foo (unsigned long *x, unsigned char *y)
+{
+  int i;
+  unsigned long w = x[0];
+  for (i = 0; i < j; i++)
+    {
+      w += *y;
+      y += 0x10000;
+      w += *y;
+      y += 0x10000;
+    }
+  x[1] = w;
+}
+
+__attribute__ ((noinline, noclone)) void
+bar (unsigned long *x)
+{
+  foo (x, c);
+}
+
+int
+main ()
+{
+  unsigned long a[2] = { 0, -1UL };
+  asm volatile (""::"r" (c):"memory");
+  c[0] = 0;
+  bar (a);
+  if (a[1] != 0)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/vect/pr60276.c b/gcc/testsuite/gcc.dg/vect/pr60276.c
new file mode 100644
index 0000000..d4ad219
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr60276.c
@@ -0,0 +1,52 @@
+/* { dg-do run } */
+
+extern void abort (void);
+
+static void 
+foo (int *out, const int *lp, unsigned samples)
+{
+  int x, target;
+  for (x = 0, target = 0; x < (int)samples; x += 2, target++)
+    {
+      out[x] = lp[target];
+      out[x - 1] = out[x - 2] + out[x];
+    }
+}
+
+static void 
+foo_novec (int *out, const int *lp, unsigned samples)
+{
+  int x, target;
+  for (x = 0, target = 0; x < (int)samples; x += 2, target++)
+    {
+      out[x] = lp[target];
+      out[x - 1] = out[x - 2] + out[x];
+      __asm__ volatile ("" : : : "memory");
+    }
+}
+
+int main(void)
+{
+  const int lp[25] = {
+      0, 2, 4, 6, 8,
+      10, 12, 14, 16,
+      18, 20, 22, 24,
+      26, 28, 30, 32,
+      34, 36, 38, 40,
+      42, 44, 46, 48,
+  };
+  int out[49] = {0};
+  int out2[49] = {0};
+  int s;
+
+  foo (out + 2, lp + 1, 48);
+  foo_novec (out2 + 2, lp + 1, 48);
+
+  for (s = 0; s < 49; s++)
+    if (out[s] != out2[s])
+      abort ();
+
+  return 0;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/pr60382.c b/gcc/testsuite/gcc.dg/vect/pr60382.c
new file mode 100644
index 0000000..a28c631
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/vect/pr60382.c
@@ -0,0 +1,32 @@
+#include "tree-vect.h"
+
+int a, b, c, e, f;
+
+void
+foo ()
+{
+  for (b = 0; b < 3; b++)
+    if (e)
+      {
+	for (c = 0; c < 4; c++)
+	  {
+	    if (b)
+	      continue;
+	    f = 1;
+	    for (a = 0; a < 2; a++)
+	      f |= 1;
+	  }
+	for (;;)
+	  ;
+      }
+}
+
+int
+main ()
+{
+  check_vect ();
+  foo ();
+  return 0;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr43546.c b/gcc/testsuite/gcc.target/i386/pr43546.c
new file mode 100644
index 0000000..53cb3a0
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr43546.c
@@ -0,0 +1,12 @@
+/* PR target/43546 */
+/* { dg-do compile } */
+/* { dg-options "-O1" } */
+/* { dg-additional-options "-mpreferred-stack-boundary=2 -msseregparm -msse" { target ia32 } } */
+
+extern void bar (double);
+
+void
+foo (void)
+{
+  bar (1.0);
+}
diff --git a/gcc/testsuite/gcc.target/microblaze/others/mem_reload.c b/gcc/testsuite/gcc.target/microblaze/others/mem_reload.c
new file mode 100644
index 0000000..e285fb8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/microblaze/others/mem_reload.c
@@ -0,0 +1,74 @@
+/* { dg-options "-O2 -fPIC" } */
+
+typedef struct test_struct
+{
+    unsigned long long h[8];
+    unsigned long long Nl,Nh;
+    union {
+        unsigned long long d[16];
+        unsigned char p[(16*8)];
+    } u;
+    unsigned int num,md_len;
+} TEST_STRUCT;
+
+static const unsigned long long K512[12] = {
+    0x428a2f98d728ae22,0x7137449123ef65cd,
+    0xb5c0fbcfec4d3b2f,0xe9b5dba58189dbbc,
+    0x3956c25bf348b538,0x59f111f1b605d019,
+    0x923f82a4af194f9b,0xab1c5ed5da6d8118,
+    0xd807aa98a3030242,0x12835b0145706fbe,
+    0x243185be4ee4b28c,0x550c7dc3d5ffb4e2};
+
+#define ROTR(x,s)   (((x)>>s) | (x)<<(64-s))
+#define Sigma0(x)   (ROTR((x),28) ^ ROTR((x),34) ^ ROTR((x),39))
+#define Sigma1(x)   (ROTR((x),14) ^ ROTR((x),18) ^ ROTR((x),41))
+#define Ch(x,y,z)   (((x) & (y)) ^ ((~(x)) & (z)))
+#define Maj(x,y,z)  (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
+
+#define ROUND_00_15(i,a,b,c,d,e,f,g,h)  do {    \
+    T1 += h + Sigma1(e) + Ch(e,f,g) + K512[i];  \
+    h = Sigma0(a) + Maj(a,b,c);         \
+    d += T1;    h += T1;        } while (0)
+
+#define ROUND_16_80(i,a,b,c,d,e,f,g,h,X)    do {    \
+    T1 = X[(i)&0x0f] += s0 + s1 + X[(i+9)&0x0f];    \
+    ROUND_00_15(i,a,b,c,d,e,f,g,h);     } while (0)
+
+static void testfunc1 (TEST_STRUCT *ctx, const void *in, unsigned int num)
+{
+    const unsigned long long *W=in;
+    unsigned long long  a,b,c,d,e,f,g,h,s0,s1,T1;
+    unsigned long long  X[16];
+    int i;
+
+    while (num--) {
+
+        T1 = X[0] = W[0];   ROUND_00_15(0,a,b,c,d,e,f,g,h);
+        T1 = X[1] = W[1];   ROUND_00_15(1,h,a,b,c,d,e,f,g);
+        T1 = X[2] = W[2];   ROUND_00_15(2,g,h,a,b,c,d,e,f);
+        T1 = X[3] = W[3];   ROUND_00_15(3,f,g,h,a,b,c,d,e);
+        T1 = X[4] = W[4];   ROUND_00_15(4,e,f,g,h,a,b,c,d);
+        T1 = X[5] = W[5];   ROUND_00_15(5,d,e,f,g,h,a,b,c);
+        T1 = X[6] = W[6];   ROUND_00_15(6,c,d,e,f,g,h,a,b);
+        T1 = X[7] = W[7];   ROUND_00_15(7,b,c,d,e,f,g,h,a);
+        T1 = X[8] = W[8];   ROUND_00_15(8,a,b,c,d,e,f,g,h);
+        T1 = X[9] = W[9];   ROUND_00_15(9,h,a,b,c,d,e,f,g);
+
+        for (i=16;i<80;i+=8)
+        {
+            ROUND_16_80(i+0,a,b,c,d,e,f,g,h,X);
+        }
+
+        ctx->h[4] += e; ctx->h[5] += f; ctx->h[6] += g; ctx->h[7] += h;
+    }
+}
+
+int testfunc2 (TEST_STRUCT *c, const void *_data, unsigned int len)
+{
+    const unsigned char *data=(const unsigned char *)_data;
+
+    unsigned char *p=(unsigned char *)c->u.p;
+
+    testfunc1 (c,p,0);
+    testfunc1 (c,data,len/sizeof(c->u));
+}
diff --git a/gcc/testsuite/gfortran.dg/pr52370.f90 b/gcc/testsuite/gfortran.dg/pr52370.f90
new file mode 100644
index 0000000..66a6fe2
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr52370.f90
@@ -0,0 +1,21 @@
+! PR fortran/52370
+! { dg-do compile }
+! { dg-options "-O1 -Wall" }
+
+module pr52370
+contains
+  subroutine foo(a,b)
+    real, intent(out) :: a
+    real, dimension(:), optional, intent(out) :: b
+    a=0.5
+    if (present(b)) then
+      b=1.0
+    end if
+  end subroutine foo
+end module pr52370
+
+program prg52370
+  use pr52370
+  real :: a
+  call foo(a)
+end program prg52370
diff --git a/gcc/testsuite/gfortran.dg/shape_8.f90 b/gcc/testsuite/gfortran.dg/shape_8.f90
new file mode 100644
index 0000000..edeb5fd
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/shape_8.f90
@@ -0,0 +1,10 @@
+! { dg-do compile }
+!
+! PR 60450: [4.7/4.8 Regression] ICE with SHAPE intrinsic
+!
+! Contributed by Dave Allured <dave.allured@noaa.gov>
+
+  real, allocatable :: x(:,:)
+  allocate (x(3,2), source=99.)
+  print *, shape (x / 10.0)
+end
diff --git a/gcc/testsuite/gfortran.dg/str_comp_optimize_1.f90 b/gcc/testsuite/gfortran.dg/str_comp_optimize_1.f90
new file mode 100644
index 0000000..84287b4
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/str_comp_optimize_1.f90
@@ -0,0 +1,22 @@
+! { dg-do compile }
+! { dg-options "-ffrontend-optimize" }
+!
+! PR fortran/60341
+! An unguarded union access was wrongly enabling a frontend optimization on a
+! string comparison, leading to an ICE.
+!
+! Original testcase from Steve Chapel  <steve.chapel@a2pg.com>.
+! Reduced by Steven G. Kargl  <kargl@gcc.gnu.org>.
+!
+
+      subroutine modelg(ncm)
+      implicit none
+      integer, parameter :: pc = 30, pm = pc - 1
+      integer i
+      character*4 catt(pm,2)
+      integer ncm,iatt(pm,pc)
+      do i=1,ncm
+         if (catt(i,1)//catt(i,2).eq.'central') exit
+      end do
+      iatt(i,4)=1
+      end
diff --git a/gcc/tree-eh.c b/gcc/tree-eh.c
index 4393e8a..902ce45 100644
--- a/gcc/tree-eh.c
+++ b/gcc/tree-eh.c
@@ -4184,8 +4184,11 @@ struct gimple_opt_pass pass_lower_eh_dispatch =
   /* If the block is totally empty, look for more unsplitting cases.  */
   if (gsi_end_p (gsi))
     {
-      /* For the degenerate case of an infinite loop bail out.  */
-      if (infinite_empty_loop_p (e_out))
+      /* For the degenerate case of an infinite loop bail out.
+	 If bb has no successors and is totally empty, which can happen e.g.
+	 because of incorrect noreturn attribute, bail out too.  */
+      if (e_out == NULL
+	  || infinite_empty_loop_p (e_out))
 	return ret;
 
       return ret | cleanup_empty_eh_unsplit (bb, e_out, lp);
@@ -4322,11 +4325,12 @@ struct gimple_opt_pass pass_lower_eh_dispatch =
   remove_unreachable_handlers ();
 
   /* Watch out for the region tree vanishing due to all unreachable.  */
-  if (cfun->eh->region_tree && optimize)
+  if (cfun->eh->region_tree)
     {
       bool changed = false;
 
-      changed |= unsplit_all_eh ();
+      if (optimize)
+	changed |= unsplit_all_eh ();
       changed |= cleanup_all_empty_eh ();
 
       if (changed)
diff --git a/gcc/tree-sra.c b/gcc/tree-sra.c
index 5142d4b..43b2ce6 100644
--- a/gcc/tree-sra.c
+++ b/gcc/tree-sra.c
@@ -2889,6 +2889,10 @@ enum unscalarized_data_handling { SRA_UDH_NONE,  /* Nothing done so far. */
 						  lacc);
 	      else
 		drhs = NULL_TREE;
+	      if (drhs
+		  && !useless_type_conversion_p (lacc->type, TREE_TYPE (drhs)))
+		drhs = fold_build1_loc (loc, VIEW_CONVERT_EXPR,
+					lacc->type, drhs);
 	      ds = gimple_build_debug_bind (get_access_replacement (lacc),
 					    drhs, gsi_stmt (*old_gsi));
 	      gsi_insert_after (new_gsi, ds, GSI_NEW_STMT);
@@ -4867,6 +4871,14 @@ enum ipa_splicing_result { NO_GOOD_ACCESS, UNUSED_PARAMS, BY_VAL_ACCESSES,
       return false;
     }
 
+  if (!opt_for_fn (node->symbol.decl, optimize)
+      || !opt_for_fn (node->symbol.decl, flag_ipa_sra))
+    {
+      if (dump_file)
+	fprintf (dump_file, "Function not optimized.\n");
+      return false;
+    }
+
   if (DECL_VIRTUAL_P (current_function_decl))
     {
       if (dump_file)
diff --git a/gcc/tree-ssa-live.c b/gcc/tree-ssa-live.c
index a72e9d5..8456d7a 100644
--- a/gcc/tree-ssa-live.c
+++ b/gcc/tree-ssa-live.c
@@ -394,7 +394,8 @@
     {
       /* When a global var becomes used for the first time also walk its
          initializer (non global ones don't have any).  */
-      if (set_is_used (t) && is_global_var (t))
+      if (set_is_used (t) && is_global_var (t)
+	  && DECL_CONTEXT (t) == current_function_decl)
 	mark_all_vars_used (&DECL_INITIAL (t));
     }
   /* remove_unused_scope_block_p requires information about labels
diff --git a/gcc/tree-ssa-phiprop.c b/gcc/tree-ssa-phiprop.c
index 4da1814..36b47d7 100644
--- a/gcc/tree-ssa-phiprop.c
+++ b/gcc/tree-ssa-phiprop.c
@@ -307,6 +307,12 @@ struct phiprop_d
       gimple def_stmt;
       tree vuse;
 
+      /* Only replace loads in blocks that post-dominate the PHI node.  That
+         makes sure we don't end up speculating loads.  */
+      if (!dominated_by_p (CDI_POST_DOMINATORS,
+			   bb, gimple_bb (use_stmt)))
+	continue;
+         
       /* Check whether this is a load of *ptr.  */
       if (!(is_gimple_assign (use_stmt)
 	    && TREE_CODE (gimple_assign_lhs (use_stmt)) == SSA_NAME
@@ -378,6 +384,7 @@ struct phiprop_d
   size_t n;
 
   calculate_dominance_info (CDI_DOMINATORS);
+  calculate_dominance_info (CDI_POST_DOMINATORS);
 
   n = num_ssa_names;
   phivn = XCNEWVEC (struct phiprop_d, n);
@@ -395,6 +402,8 @@ struct phiprop_d
   bbs.release ();
   free (phivn);
 
+  free_dominance_info (CDI_POST_DOMINATORS);
+
   return 0;
 }
 
diff --git a/gcc/tree-ssa-uninit.c b/gcc/tree-ssa-uninit.c
index 2c47fe9..2379f9c 100644
--- a/gcc/tree-ssa-uninit.c
+++ b/gcc/tree-ssa-uninit.c
@@ -36,6 +36,7 @@
 #include "hashtab.h"
 #include "tree-pass.h"
 #include "diagnostic-core.h"
+#include "params.h"
 
 /* This implements the pass that does predicate aware warning on uses of
    possibly uninitialized variables. The pass first collects the set of
@@ -246,8 +247,8 @@
 
 /* Computes the control dependence chains (paths of edges)
    for DEP_BB up to the dominating basic block BB (the head node of a
-   chain should be dominated by it).  CD_CHAINS is pointer to a
-   dynamic array holding the result chains. CUR_CD_CHAIN is the current
+   chain should be dominated by it).  CD_CHAINS is pointer to an
+   array holding the result chains.  CUR_CD_CHAIN is the current
    chain being computed.  *NUM_CHAINS is total number of chains.  The
    function returns true if the information is successfully computed,
    return false if there is no control dependence or not computed.  */
@@ -256,7 +257,8 @@
 compute_control_dep_chain (basic_block bb, basic_block dep_bb,
                            vec<edge> *cd_chains,
                            size_t *num_chains,
-                           vec<edge> *cur_cd_chain)
+			   vec<edge> *cur_cd_chain,
+			   int *num_calls)
 {
   edge_iterator ei;
   edge e;
@@ -267,6 +269,10 @@
   if (EDGE_COUNT (bb->succs) < 2)
     return false;
 
+  if (*num_calls > PARAM_VALUE (PARAM_UNINIT_CONTROL_DEP_ATTEMPTS))
+    return false;
+  ++*num_calls;
+
   /* Could  use a set instead.  */
   cur_chain_len = cur_cd_chain->length ();
   if (cur_chain_len > MAX_CHAIN_LEN)
@@ -306,7 +312,7 @@
 
           /* Now check if DEP_BB is indirectly control dependent on BB.  */
           if (compute_control_dep_chain (cd_bb, dep_bb, cd_chains,
-                                         num_chains, cur_cd_chain))
+					 num_chains, cur_cd_chain, num_calls))
             {
               found_cd_chain = true;
               break;
@@ -438,14 +444,12 @@
                  basic_block use_bb)
 {
   size_t num_chains = 0, i;
-  vec<edge> *dep_chains = 0;
+  int num_calls = 0;
+  vec<edge> dep_chains[MAX_NUM_CHAINS];
   vec<edge> cur_chain = vNULL;
   bool has_valid_pred = false;
   basic_block cd_root = 0;
 
-  typedef vec<edge> vec_edge_heap;
-  dep_chains = XCNEWVEC (vec_edge_heap, MAX_NUM_CHAINS);
-
   /* First find the closest bb that is control equivalent to PHI_BB
      that also dominates USE_BB.  */
   cd_root = phi_bb;
@@ -458,20 +462,16 @@
         break;
     }
 
-  compute_control_dep_chain (cd_root, use_bb,
-                             dep_chains, &num_chains,
-                             &cur_chain);
+  compute_control_dep_chain (cd_root, use_bb, dep_chains, &num_chains,
+			     &cur_chain, &num_calls);
 
   has_valid_pred
-      = convert_control_dep_chain_into_preds (dep_chains,
-                                              num_chains,
-                                              preds,
-                                              num_preds);
+    = convert_control_dep_chain_into_preds (dep_chains, num_chains, preds,
+					    num_preds);
   /* Free individual chain  */
   cur_chain.release ();
   for (i = 0; i < num_chains; i++)
     dep_chains[i].release ();
-  free (dep_chains);
   return has_valid_pred;
 }
 
@@ -539,16 +539,13 @@
                 size_t *num_preds, gimple phi)
 {
   size_t num_chains = 0, i, n;
-  vec<edge> *dep_chains = 0;
+  vec<edge> dep_chains[MAX_NUM_CHAINS];
   vec<edge> cur_chain = vNULL;
   vec<edge> def_edges = vNULL;
   bool has_valid_pred = false;
   basic_block phi_bb, cd_root = 0;
   struct pointer_set_t *visited_phis;
 
-  typedef vec<edge> vec_edge_heap;
-  dep_chains = XCNEWVEC (vec_edge_heap, MAX_NUM_CHAINS);
-
   phi_bb = gimple_bb (phi);
   /* First find the closest dominating bb to be
      the control dependence root  */
@@ -567,38 +564,33 @@
   for (i = 0; i < n; i++)
     {
       size_t prev_nc, j;
+      int num_calls = 0;
       edge opnd_edge;
 
       opnd_edge = def_edges[i];
       prev_nc = num_chains;
-      compute_control_dep_chain (cd_root, opnd_edge->src,
-                                 dep_chains, &num_chains,
-                                 &cur_chain);
-      /* Free individual chain  */
-      cur_chain.release ();
+      compute_control_dep_chain (cd_root, opnd_edge->src, dep_chains,
+				 &num_chains, &cur_chain, &num_calls);
 
       /* Now update the newly added chains with
          the phi operand edge:  */
       if (EDGE_COUNT (opnd_edge->src->succs) > 1)
         {
-          if (prev_nc == num_chains
-              && num_chains < MAX_NUM_CHAINS)
-            num_chains++;
+	  if (prev_nc == num_chains && num_chains < MAX_NUM_CHAINS)
+	    dep_chains[num_chains++] = vNULL;
           for (j = prev_nc; j < num_chains; j++)
-            {
-              dep_chains[j].safe_push (opnd_edge);
-            }
+	    dep_chains[j].safe_push (opnd_edge);
         }
     }
 
+  /* Free individual chain  */
+  cur_chain.release ();
+
   has_valid_pred
-      = convert_control_dep_chain_into_preds (dep_chains,
-                                              num_chains,
-                                              preds,
-                                              num_preds);
+    = convert_control_dep_chain_into_preds (dep_chains, num_chains, preds,
+					    num_preds);
   for (i = 0; i < num_chains; i++)
     dep_chains[i].release ();
-  free (dep_chains);
   return has_valid_pred;
 }
 
diff --git a/gcc/tree-vect-data-refs.c b/gcc/tree-vect-data-refs.c
index 1d5d022..d8d1435 100644
--- a/gcc/tree-vect-data-refs.c
+++ b/gcc/tree-vect-data-refs.c
@@ -739,6 +739,13 @@
 	  if (dump_enabled_p ())
 	    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
                              "dependence distance negative.");
+	  /* Record a negative dependence distance to later limit the
+	     amount of stmt copying / unrolling we can perform.
+	     Only need to handle read-after-write dependence.  */
+	  if (DR_IS_READ (drb)
+	      && (STMT_VINFO_MIN_NEG_DIST (stmtinfo_b) == 0
+		  || STMT_VINFO_MIN_NEG_DIST (stmtinfo_b) > (unsigned)dist))
+	    STMT_VINFO_MIN_NEG_DIST (stmtinfo_b) = dist;
 	  continue;
 	}
 
diff --git a/gcc/tree-vect-loop.c b/gcc/tree-vect-loop.c
index b60ef1c..8495287 100644
--- a/gcc/tree-vect-loop.c
+++ b/gcc/tree-vect-loop.c
@@ -2097,6 +2097,12 @@
               || (!check_reduction && flow_loop_nested_p (vect_loop, loop)));
 
   name = PHI_RESULT (phi);
+  /* ???  If there are no uses of the PHI result the inner loop reduction
+     won't be detected as possibly double-reduction by vectorizable_reduction
+     because that tries to walk the PHI arg from the preheader edge which
+     can be constant.  See PR60382.  */
+  if (has_zero_uses (name))
+    return NULL;
   nloop_uses = 0;
   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, name)
     {
diff --git a/gcc/tree-vect-stmts.c b/gcc/tree-vect-stmts.c
index 96dd191..361c312 100644
--- a/gcc/tree-vect-stmts.c
+++ b/gcc/tree-vect-stmts.c
@@ -4369,6 +4369,20 @@ static tree permute_vec_elements (tree, tree, tree, gimple,
       return false;
     }
 
+  /* Invalidate assumptions made by dependence analysis when vectorization
+     on the unrolled body effectively re-orders stmts.  */
+  if (ncopies > 1
+      && STMT_VINFO_MIN_NEG_DIST (stmt_info) != 0
+      && ((unsigned)LOOP_VINFO_VECT_FACTOR (loop_vinfo)
+	  > STMT_VINFO_MIN_NEG_DIST (stmt_info)))
+    {
+      if (dump_enabled_p ())
+	dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
+			 "cannot perform implicit CSE when unrolling "
+			 "with negative dependence distance\n");
+      return false;
+    }
+
   if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)
     return false;
 
@@ -4425,6 +4439,20 @@ static tree permute_vec_elements (tree, tree, tree, gimple,
 	  else if (!vect_grouped_load_supported (vectype, group_size))
 	    return false;
 	}
+
+      /* Invalidate assumptions made by dependence analysis when vectorization
+	 on the unrolled body effectively re-orders stmts.  */
+      if (!PURE_SLP_STMT (stmt_info)
+	  && STMT_VINFO_MIN_NEG_DIST (stmt_info) != 0
+	  && ((unsigned)LOOP_VINFO_VECT_FACTOR (loop_vinfo)
+	      > STMT_VINFO_MIN_NEG_DIST (stmt_info)))
+	{
+	  if (dump_enabled_p ())
+	    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
+			     "cannot perform implicit CSE when performing "
+			     "group loads with negative dependence distance\n");
+	  return false;
+	}
     }
 
 
diff --git a/gcc/tree-vectorizer.h b/gcc/tree-vectorizer.h
index f2ec713..e4ef993 100644
--- a/gcc/tree-vectorizer.h
+++ b/gcc/tree-vectorizer.h
@@ -542,6 +542,10 @@ enum slp_vect_type {
      is 1.  */
   unsigned int gap;
 
+  /* The minimum negative dependence distance this stmt participates in
+     or zero if none.  */
+  unsigned int min_neg_dist;
+
   /* Not all stmts in the loop need to be vectorized. e.g, the increment
      of the loop induction variable and computation of array indexes. relevant
      indicates whether the stmt needs to be vectorized.  */
@@ -593,6 +597,7 @@ enum slp_vect_type {
 #define STMT_VINFO_GROUP_READ_WRITE_DEPENDENCE(S)  (S)->read_write_dep
 #define STMT_VINFO_GROUPED_ACCESS(S)      ((S)->first_element != NULL && (S)->data_ref_info)
 #define STMT_VINFO_LOOP_PHI_EVOLUTION_PART(S) (S)->loop_phi_evolution_part
+#define STMT_VINFO_MIN_NEG_DIST(S)	(S)->min_neg_dist
 
 #define GROUP_FIRST_ELEMENT(S)          (S)->first_element
 #define GROUP_NEXT_ELEMENT(S)           (S)->next_element
diff --git a/gcc/tree.h b/gcc/tree.h
index fb2123e..2b93882 100644
--- a/gcc/tree.h
+++ b/gcc/tree.h
@@ -6546,4 +6546,18 @@ typedef struct GTY(()) builtin_info_type_d {
 	  && builtin_info.implicit_p[uns_fncode]);
 }
 
+/* Return pointer to optimization flags of FNDECL.  */
+static inline struct cl_optimization *
+opts_for_fn (const_tree fndecl)
+{
+  tree fn_opts = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl);
+  if (fn_opts == NULL_TREE)
+    fn_opts = optimization_default_node;
+  return TREE_OPTIMIZATION (fn_opts);
+}
+
+/* opt flag for function FNDECL, e.g. opts_for_fn (fndecl, optimize) is
+   the optimization level of function fndecl.  */
+#define opt_for_fn(fndecl, opt) (opts_for_fn (fndecl)->x_##opt)
+
 #endif  /* GCC_TREE_H  */
diff --git a/libcpp/ChangeLog b/libcpp/ChangeLog
index c50f73c..8ab4511 100644
--- a/libcpp/ChangeLog
+++ b/libcpp/ChangeLog
@@ -1,3 +1,29 @@
+2014-03-06  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2014-02-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/58844
+	* macro.c (enter_macro_context): Only push
+	macro_real_token_count (macro) tokens rather than
+	macro->count tokens, regardless of
+	CPP_OPTION (pfile, track-macro-expansion).
+
+	2014-02-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/56824
+	* line-map.c (linemap_compare_locations): Look through adhoc locations
+	for both l0 and l1.
+
+2014-03-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/60400
+	Backport from mainline
+	2013-06-24  Dehao Chen  <dehao@google.com>
+
+	* files.c (_cpp_stack_include): Fix the highest_location when header
+	file is guarded by #ifndef and is included twice.
+
 2013-10-16  Release Manager
 
 	* GCC 4.8.2 released.
diff --git a/libcpp/files.c b/libcpp/files.c
index 5c5a0b9..ea91b02 100644
--- a/libcpp/files.c
+++ b/libcpp/files.c
@@ -983,6 +983,7 @@ static struct file_hash_entry *search_cache (struct file_hash_entry *head,
 {
   struct cpp_dir *dir;
   _cpp_file *file;
+  bool stacked;
 
   dir = search_path_head (pfile, fname, angle_brackets, type);
   if (!dir)
@@ -993,19 +994,26 @@ static struct file_hash_entry *search_cache (struct file_hash_entry *head,
   if (type == IT_DEFAULT && file == NULL)
     return false;
 
-  /* Compensate for the increment in linemap_add that occurs in
-     _cpp_stack_file.  In the case of a normal #include, we're
-     currently at the start of the line *following* the #include.  A
-     separate source_location for this location makes no sense (until
-     we do the LC_LEAVE), and complicates LAST_SOURCE_LINE_LOCATION.
-     This does not apply if we found a PCH file (in which case
-     linemap_add is not called) or we were included from the
-     command-line.  */
+  /* Compensate for the increment in linemap_add that occurs if
+      _cpp_stack_file actually stacks the file.  In the case of a
+     normal #include, we're currently at the start of the line
+     *following* the #include.  A separate source_location for this
+     location makes no sense (until we do the LC_LEAVE), and
+     complicates LAST_SOURCE_LINE_LOCATION.  This does not apply if we
+     found a PCH file (in which case linemap_add is not called) or we
+     were included from the command-line.  */
   if (file->pchname == NULL && file->err_no == 0
       && type != IT_CMDLINE && type != IT_DEFAULT)
     pfile->line_table->highest_location--;
 
-  return _cpp_stack_file (pfile, file, type == IT_IMPORT);
+  stacked = _cpp_stack_file (pfile, file, type == IT_IMPORT);
+
+  if (!stacked)
+    /* _cpp_stack_file didn't stack the file, so let's rollback the
+       compensation dance we performed above.  */
+    pfile->line_table->highest_location++;
+
+  return stacked;
 }
 
 /* Could not open FILE.  The complication is dependency output.  */
diff --git a/libcpp/line-map.c b/libcpp/line-map.c
index 2ad7ad2..125f0870 100644
--- a/libcpp/line-map.c
+++ b/libcpp/line-map.c
@@ -1024,6 +1024,11 @@ static source_location linemap_macro_loc_to_exp_point (struct line_maps *,
   bool pre_virtual_p, post_virtual_p;
   source_location l0 = pre, l1 = post;
 
+  if (IS_ADHOC_LOC (l0))
+    l0 = set->location_adhoc_data_map.data[l0 & MAX_SOURCE_LOCATION].locus;
+  if (IS_ADHOC_LOC (l1))
+    l1 = set->location_adhoc_data_map.data[l1 & MAX_SOURCE_LOCATION].locus;
+
   if (l0 == l1)
     return 0;
 
diff --git a/libcpp/macro.c b/libcpp/macro.c
index 6d46027..f2b7d0b 100644
--- a/libcpp/macro.c
+++ b/libcpp/macro.c
@@ -1108,21 +1108,22 @@ static void consume_next_token_from_context (cpp_reader *pfile,
 
       if (macro->paramc == 0)
 	{
+	  unsigned tokens_count = macro_real_token_count (macro);
 	  if (CPP_OPTION (pfile, track_macro_expansion))
 	    {
-	      unsigned int i, count = macro->count;
+	      unsigned int i;
 	      const cpp_token *src = macro->exp.tokens;
 	      const struct line_map *map;
 	      source_location *virt_locs = NULL;
-	      _cpp_buff *macro_tokens =
-		tokens_buff_new (pfile, count, &virt_locs);
+	      _cpp_buff *macro_tokens
+		= tokens_buff_new (pfile, tokens_count, &virt_locs);
 
 	      /* Create a macro map to record the locations of the
 		 tokens that are involved in the expansion. LOCATION
 		 is the location of the macro expansion point.  */
-	      map  = linemap_enter_macro (pfile->line_table,
-					  node, location, count);
-	      for (i = 0; i < count; ++i)
+	      map = linemap_enter_macro (pfile->line_table,
+					 node, location, tokens_count);
+	      for (i = 0; i < tokens_count; ++i)
 		{
 		  tokens_buff_add_token (macro_tokens, virt_locs,
 					 src, src->src_loc,
@@ -1134,16 +1135,12 @@ static void consume_next_token_from_context (cpp_reader *pfile,
 					    virt_locs,
 					    (const cpp_token **)
 					    macro_tokens->base,
-					    count);
-	      num_macro_tokens_counter += count;
+					    tokens_count);
 	    }
 	  else
-	    {
-	      unsigned tokens_count = macro_real_token_count (macro);
-	      _cpp_push_token_context (pfile, node, macro->exp.tokens,
-				       tokens_count);
-	      num_macro_tokens_counter += tokens_count;
-	    }
+	    _cpp_push_token_context (pfile, node, macro->exp.tokens,
+				     tokens_count);
+	  num_macro_tokens_counter += tokens_count;
 	}
 
       if (pragma_buff)
diff --git a/libgcc/ChangeLog b/libgcc/ChangeLog
index a233be9..6712a8d 100644
--- a/libgcc/ChangeLog
+++ b/libgcc/ChangeLog
@@ -1,3 +1,13 @@
+2014-02-28  Joey Ye  <joey.ye@arm.com>
+
+	Backport from mainline r208229
+	2014-02-28  Joey Ye  <joey.ye@arm.com>
+
+	PR libgcc/60166
+	* config/arm/sfp-machine.h (_FP_NANFRAC_H,
+	_FP_NANFRAC_S, _FP_NANFRAC_D, _FP_NANFRAC_Q):
+	Set to zero.
+
 2014-02-18  Kai Tietz  <ktietz@redhat.com>
 	Jonathan Schleifer  <js@webkeks.org>
 
diff --git a/libgcc/config/arm/sfp-machine.h b/libgcc/config/arm/sfp-machine.h
index a89d05a..8591ab4 100644
--- a/libgcc/config/arm/sfp-machine.h
+++ b/libgcc/config/arm/sfp-machine.h
@@ -19,10 +19,12 @@
 #define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_2_udiv(D,R,X,Y)
 #define _FP_DIV_MEAT_Q(R,X,Y)	_FP_DIV_MEAT_4_udiv(Q,R,X,Y)
 
-#define _FP_NANFRAC_H		((_FP_QNANBIT_H << 1) - 1)
-#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
-#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
-#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
+/* According to RTABI, QNAN is only with the most significant bit of the
+   significand set, and all other significand bits zero.  */
+#define _FP_NANFRAC_H		0
+#define _FP_NANFRAC_S		0
+#define _FP_NANFRAC_D		0, 0
+#define _FP_NANFRAC_Q		0, 0, 0, 0
 #define _FP_NANSIGN_H		0
 #define _FP_NANSIGN_S		0
 #define _FP_NANSIGN_D		0
diff --git a/libgo/runtime/proc.c b/libgo/runtime/proc.c
index 635e47b..4ca9756 100644
--- a/libgo/runtime/proc.c
+++ b/libgo/runtime/proc.c
@@ -1716,10 +1716,30 @@ struct CgoThreadStart
 // entersyscall is going to return immediately after.
 
 void runtime_entersyscall(void) __attribute__ ((no_split_stack));
+static void doentersyscall(void) __attribute__ ((no_split_stack, noinline));
 
 void
 runtime_entersyscall()
 {
+	// Save the registers in the g structure so that any pointers
+	// held in registers will be seen by the garbage collector.
+	getcontext(&g->gcregs);
+
+	// Do the work in a separate function, so that this function
+	// doesn't save any registers on its own stack.  If this
+	// function does save any registers, we might store the wrong
+	// value in the call to getcontext.
+	//
+	// FIXME: This assumes that we do not need to save any
+	// callee-saved registers to access the TLS variable g.  We
+	// don't want to put the ucontext_t on the stack because it is
+	// large and we can not split the stack here.
+	doentersyscall();
+}
+
+static void
+doentersyscall()
+{
 	if(m->profilehz > 0)
 		runtime_setprof(false);
 
@@ -1736,10 +1756,6 @@ struct CgoThreadStart
 	}
 #endif
 
-	// Save the registers in the g structure so that any pointers
-	// held in registers will be seen by the garbage collector.
-	getcontext(&g->gcregs);
-
 	g->status = Gsyscall;
 
 	if(runtime_atomicload(&runtime_sched.sysmonwait)) {  // TODO: fast atomic
diff --git a/libitm/ChangeLog b/libitm/ChangeLog
index b71c0f8..41ca0c9 100644
--- a/libitm/ChangeLog
+++ b/libitm/ChangeLog
@@ -1,3 +1,18 @@
+2014-03-03  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2013-06-20  Torvald Riegel  <triegel@redhat.com>
+
+	* query.cc (_ITM_inTransaction): Abort when using the HTM fastpath.
+	(_ITM_getTransactionId): Same.
+	* config/x86/target.h (htm_transaction_active): New.
+
+	2013-06-20  Torvald Riegel  <triegel@redhat.com>
+
+	PR libitm/57643
+	* beginend.cc (gtm_thread::begin_transaction): Handle reentrancy in
+	the HTM fastpath.
+
 2013-10-16  Release Manager
 
 	* GCC 4.8.2 released.
@@ -8,13 +23,12 @@
 	2013-08-02  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
 
 	* configure.tgt: Add -msoft-float to XCFLAGS.
-	
 
 2013-08-14  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
 
 	* config/s390/sjlj.S: Add file missing from last commit.
 	* config/s390/target.h: Likewise.
-	
+
 2013-08-02  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>
 
 	Backports from mainline:
diff --git a/libitm/beginend.cc b/libitm/beginend.cc
index 93e702e..a3bf549 100644
--- a/libitm/beginend.cc
+++ b/libitm/beginend.cc
@@ -197,6 +197,8 @@
 	      // We are executing a transaction now.
 	      // Monitor the writer flag in the serial-mode lock, and abort
 	      // if there is an active or waiting serial-mode transaction.
+	      // Note that this can also happen due to an enclosing
+	      // serial-mode transaction; we handle this case below.
 	      if (unlikely(serial_lock.is_write_locked()))
 		htm_abort();
 	      else
@@ -219,6 +221,14 @@
 	          tx = new gtm_thread();
 	          set_gtm_thr(tx);
 	        }
+	      // Check whether there is an enclosing serial-mode transaction;
+	      // if so, we just continue as a nested transaction and don't
+	      // try to use the HTM fastpath.  This case can happen when an
+	      // outermost relaxed transaction calls unsafe code that starts
+	      // a transaction.
+	      if (tx->nesting > 0)
+		break;
+	      // Another thread is running a serial-mode transaction.  Wait.
 	      serial_lock.read_lock(tx);
 	      serial_lock.read_unlock(tx);
 	      // TODO We should probably reset the retry count t here, unless
diff --git a/libitm/config/x86/target.h b/libitm/config/x86/target.h
index 77b627f..063c09e 100644
--- a/libitm/config/x86/target.h
+++ b/libitm/config/x86/target.h
@@ -125,6 +125,13 @@
 {
   return begin_ret & _XABORT_RETRY;
 }
+
+/* Returns true iff a hardware transaction is currently being executed.  */
+static inline bool
+htm_transaction_active ()
+{
+  return _xtest() != 0;
+}
 #endif
 
 
diff --git a/libitm/query.cc b/libitm/query.cc
index 5707321..39a35b3 100644
--- a/libitm/query.cc
+++ b/libitm/query.cc
@@ -43,6 +43,15 @@
 _ITM_howExecuting ITM_REGPARM
 _ITM_inTransaction (void)
 {
+#if defined(USE_HTM_FASTPATH)
+  // If we use the HTM fastpath, we cannot reliably detect whether we are
+  // in a transaction because this function can be called outside of
+  // a transaction and thus we can't deduce this by looking at just the serial
+  // lock.  This function isn't used in practice currently, so the easiest
+  // way to handle it is to just abort.
+  if (htm_fastpath && htm_transaction_active())
+    htm_abort();
+#endif
   struct gtm_thread *tx = gtm_thr();
   if (tx && (tx->nesting > 0))
     {
@@ -58,6 +67,11 @@
 _ITM_transactionId_t ITM_REGPARM
 _ITM_getTransactionId (void)
 {
+#if defined(USE_HTM_FASTPATH)
+  // See ITM_inTransaction.
+  if (htm_fastpath && htm_transaction_active())
+    htm_abort();
+#endif
   struct gtm_thread *tx = gtm_thr();
   return (tx && (tx->nesting > 0)) ? tx->id : _ITM_noTransactionId;
 }
