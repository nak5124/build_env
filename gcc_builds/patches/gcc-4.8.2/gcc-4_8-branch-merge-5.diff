diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 0c4dc21..5026d0c 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,120 @@
+2014-03-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/60568
+	* config/i386/i386.c (x86_output_mi_thunk): Surround UNSPEC_GOT
+	into CONST, put pic register as first operand of PLUS.  Use
+	gen_const_mem for both 32-bit and 64-bit PIC got loads.
+
+2014-03-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/sparc/sparc.c (sparc_do_work_around_errata): Implement work
+	around for store forwarding issue in the FPU on the UT699.
+	* config/sparc/sparc.md (in_branch_delay): Return false for single FP
+	loads and operations if -mfix-ut699 is specified.
+	(divtf3_hq): Tweak attribute.
+	(sqrttf2_hq): Likewise.
+
+2014-03-18  Kai Tietz  <ktietz@redhat.com>
+
+	PR rtl-optimization/56356
+	* sdbout.c (sdbout_parms): Verify that parms'
+	incoming argument is valid.
+	(sdbout_reg_parms): Likewise.
+
+2014-03-18  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/sparc/sparc.c (sparc_do_work_around_errata): Speed up and use
+	proper constant for the store mode.
+
+2014-03-17  Mikael Pettersson  <mikpelinux@gmail.com>
+	    Committed by Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline:
+
+	2013-06-20  Joern Rennecke <joern.rennecke@embecosm.com>
+
+	PR rtl-optimization/57425
+	PR rtl-optimization/57569
+	* alias.c (write_dependence_p): Remove parameters mem_mode and
+	canon_mem_addr.  Add parameters x_mode, x_addr and x_canonicalized.
+	Changed all callers.
+	(canon_anti_dependence): Get comments and semantics in sync.
+	Add parameter mem_canonicalized.  Changed all callers.
+	* rtl.h (canon_anti_dependence): Update prototype.
+
+	2013-06-16  Joern Rennecke <joern.rennecke@embecosm.com>
+
+	PR rtl-optimization/57425
+	PR rtl-optimization/57569
+	* alias.c (write_dependence_p): Add new parameters mem_mode,
+	canon_mem_addr and mem_canonicalized.  Change type of writep to bool.
+	Changed all callers.
+	(canon_anti_dependence): New function.
+	* cse.c (check_dependence): Use canon_anti_dependence.
+	* cselib.c (cselib_invalidate_mem): Likewise.
+	* rtl.h (canon_anti_dependence): Declare.
+
+2014-03-17  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-03-11  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/60429
+	PR tree-optimization/60485
+	* tree-ssa-structalias.c (set_union_with_increment): Properly
+	take into account all fields that overlap the shifted vars.
+	(do_sd_constraint): Likewise.
+	(do_ds_constraint): Likewise.
+	(get_constraint_for_ptr_offset): Likewise.
+
+2014-03-15  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/sparc/sparc-protos.h (tls_call_delay): Delete.
+	(eligible_for_call_delay): New prototype.
+	* config/sparc/sparc.c (tls_call_delay): Rename into...
+	(eligible_for_call_delay): ...this.  Return false if the instruction
+	cannot be put in the delay slot of a branch.
+	(eligible_for_restore_insn): Simplify.
+	(eligible_for_return_delay): Return false if the instruction cannot be
+	put in the delay slot of a branch and simplify.
+	(eligible_for_sibcall_delay): Return false if the instruction cannot be
+	put in the delay slot of a branch.
+	* config/sparc/sparc.md (fix_ut699): New attribute.
+	(tls_call_delay): Delete.
+	(in_call_delay): Reimplement.
+	(eligible_for_sibcall_delay): Rename into...
+	(in_sibcall_delay): ...this.
+	(eligible_for_return_delay): Rename into...
+	(in_return_delay): ...this.
+	(in_branch_delay): Reimplement.
+	(in_uncond_branch_delay): Delete.
+	(in_annul_branch_delay): Delete.
+
+2014-03-14  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from 2014-03-14 trunk r208562.
+
+	PR target/59396
+	* config/avr/avr.c (avr_set_current_function): Pass function name
+	through default_strip_name_encoding before sanity checking instead
+	of skipping the first char of the assembler name.
+
+2014-03-13  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from 2014-03-13 trunk r208532.
+	
+	PR target/60486
+	* config/avr/avr.c (avr_out_plus): Swap cc_plus and cc_minus in
+	calls of avr_out_plus_1.
+
+2014-03-13  Joey Ye  <joey.ye@arm.com>
+
+	Backport from mainline
+	2014-03-12  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR tree-optimization/60454
+	* tree-ssa-math-opts.c (find_bswap_1): Fix bswap detection.
+
 2014-03-06  Matthias Klose  <doko@ubuntu.com>
 
 	* Makefile.in (s-mlib): Only pass MULTIARCH_DIRNAME if
diff --git a/gcc/ada/ChangeLog b/gcc/ada/ChangeLog
index 5f62d18..552edca 100644
--- a/gcc/ada/ChangeLog
+++ b/gcc/ada/ChangeLog
@@ -1,3 +1,13 @@
+2014-03-13  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/51483
+	* back_end.ads (Register_Type_Proc): Add 'precision' parameter.
+	* cstand.adb (Register_Float_Type): Add 'precision' parameter and use
+	it to set the RM size.  Use directly 'size' for the Esize.
+	* gcc-interface/gigi.h (enumerate_modes): Add integer parameter.
+	* gcc-interface/misc.c (enumerate_modes): Likewise.  Do not register
+	types for vector modes, pass the size in addition to the precision.
+
 2014-01-12  Eric Botcazou  <ebotcazou@adacore.com>
 
 	PR ada/59772
diff --git a/gcc/ada/back_end.ads b/gcc/ada/back_end.ads
index bfa2eb5..9d92ce3 100644
--- a/gcc/ada/back_end.ads
+++ b/gcc/ada/back_end.ads
@@ -55,6 +55,7 @@ package Back_End is
       Complex   : Boolean;  -- True iff type has real and imaginary parts
       Count     : Natural;  -- Number of elements in vector, 0 otherwise
       Float_Rep : Float_Rep_Kind; -- Representation used for fpt type
+      Precision : Positive; -- Precision of representation in bits
       Size      : Positive; -- Size of representation in bits
       Alignment : Natural); -- Required alignment in bits
    pragma Convention (C, Register_Type_Proc);
diff --git a/gcc/ada/cstand.adb b/gcc/ada/cstand.adb
index 82f8697..7f12fa0 100644
--- a/gcc/ada/cstand.adb
+++ b/gcc/ada/cstand.adb
@@ -151,6 +151,7 @@ package body CStand is
       Complex   : Boolean;  -- True iff type has real and imaginary parts
       Count     : Natural;  -- Number of elements in vector, 0 otherwise
       Float_Rep : Float_Rep_Kind; -- Representation used for fpt type
+      Precision : Positive; -- Precision of representation in bits
       Size      : Positive; -- Size of representation in bits
       Alignment : Natural); -- Required alignment in bits
    pragma Convention (C, Register_Float_Type);
@@ -2014,6 +2015,7 @@ package body CStand is
       Complex   : Boolean;
       Count     : Natural;
       Float_Rep : Float_Rep_Kind;
+      Precision : Positive;
       Size      : Positive;
       Alignment : Natural)
    is
@@ -2063,13 +2065,24 @@ package body CStand is
 
          else
             Write_Str ("mod 2**");
-            Write_Int (Int (Size / Positive'Max (1, Count)));
+            Write_Int (Int (Precision / Positive'Max (1, Count)));
             Write_Line (";");
          end if;
 
-         Write_Str ("for " & T & "'Size use ");
-         Write_Int (Int (Size));
-         Write_Line (";");
+         if Precision = Size then
+            Write_Str ("for " & T (1 .. Last) & "'Size use ");
+            Write_Int (Int (Size));
+            Write_Line (";");
+
+         else
+            Write_Str ("for " & T (1 .. Last) & "'Value_Size use ");
+            Write_Int (Int (Precision));
+            Write_Line (";");
+
+            Write_Str ("for " & T (1 .. Last) & "'Object_Size use ");
+            Write_Int (Int (Size));
+            Write_Line (";");
+         end if;
 
          Write_Str ("for " & T & "'Alignment use ");
          Write_Int (Int (Alignment / 8));
@@ -2092,15 +2105,13 @@ package body CStand is
       if Digs > 0 and then not Complex and then Count = 0 then
          declare
             Ent   : constant Entity_Id := New_Standard_Entity;
-            Esize : constant Pos := Pos ((Size + Alignment - 1)
-                                           / Alignment * Alignment);
          begin
             Set_Defining_Identifier
               (New_Node (N_Full_Type_Declaration, Stloc), Ent);
             Make_Name (Ent, T (1 .. Last));
             Set_Scope (Ent, Standard_Standard);
-            Build_Float_Type (Ent, Esize, Float_Rep, Pos (Digs));
-            Set_RM_Size (Ent, UI_From_Int (Int (Size)));
+            Build_Float_Type (Ent, Int (Size), Float_Rep, Pos (Digs));
+            Set_RM_Size (Ent, UI_From_Int (Int (Precision)));
             Set_Alignment (Ent, UI_From_Int (Int (Alignment / 8)));
 
             if No (Back_End_Float_Types) then
diff --git a/gcc/ada/gcc-interface/gigi.h b/gcc/ada/gcc-interface/gigi.h
index de1c7e8..c0db89b 100644
--- a/gcc/ada/gcc-interface/gigi.h
+++ b/gcc/ada/gcc-interface/gigi.h
@@ -1014,7 +1014,7 @@ extern tree convert_vms_descriptor (tree gnu_type, tree gnu_expr,
 /* This function is called by the front-end to enumerate all the supported
    modes for the machine, as well as some predefined C types.  */
 extern void enumerate_modes (void (*f) (const char *, int, int, int, int, int,
-					int));
+					int, int));
 
 #ifdef __cplusplus
 }
diff --git a/gcc/ada/gcc-interface/misc.c b/gcc/ada/gcc-interface/misc.c
index 2fd2743..8362048 100644
--- a/gcc/ada/gcc-interface/misc.c
+++ b/gcc/ada/gcc-interface/misc.c
@@ -648,7 +648,7 @@
 /* This function is called by the front-end to enumerate all the supported
    modes for the machine, as well as some predefined C types.  F is a function
    which is called back with the parameters as listed below, first a string,
-   then six ints.  The name is any arbitrary null-terminated string and has
+   then seven ints.  The name is any arbitrary null-terminated string and has
    no particular significance, except for the case of predefined C types, where
    it should be the name of the C type.  For integer types, only signed types
    should be listed, unsigned versions are assumed.  The order of types should
@@ -664,11 +664,12 @@
    COMPLEX_P	nonzero is this represents a complex mode
    COUNT	count of number of items, nonzero for vector mode
    FLOAT_REP	Float_Rep_Kind for FP, otherwise undefined
-   SIZE		number of bits used to store data
+   PRECISION	number of bits used to store data
+   SIZE		number of bits occupied by the mode
    ALIGN	number of bits to which mode is aligned.  */
 
 void
-enumerate_modes (void (*f) (const char *, int, int, int, int, int, int))
+enumerate_modes (void (*f) (const char *, int, int, int, int, int, int, int))
 {
   const tree c_types[]
     = { float_type_node, double_type_node, long_double_type_node };
@@ -742,28 +743,26 @@ enumerate_modes (void (*f) (const char *, int, int, int, int, int, int))
 
       /* First register any C types for this mode that the front end
 	 may need to know about, unless the mode should be skipped.  */
-
-      if (!skip_p)
+      if (!skip_p && !vector_p)
 	for (nameloop = 0; nameloop < ARRAY_SIZE (c_types); nameloop++)
 	  {
-	    tree typ = c_types[nameloop];
-	    const char *nam = c_names[nameloop];
+	    tree type = c_types[nameloop];
+	    const char *name = c_names[nameloop];
 
-	    if (TYPE_MODE (typ) == i)
+	    if (TYPE_MODE (type) == i)
 	      {
-		f (nam, digs, complex_p,
-		   vector_p ? GET_MODE_NUNITS (i) : 0, float_rep,
-		   TYPE_PRECISION (typ), TYPE_ALIGN (typ));
+		f (name, digs, complex_p, 0, float_rep, TYPE_PRECISION (type),
+		   TREE_INT_CST_LOW (TYPE_SIZE (type)), TYPE_ALIGN (type));
 		skip_p = true;
 	      }
 	  }
 
       /* If no predefined C types were found, register the mode itself.  */
-
       if (!skip_p)
 	f (GET_MODE_NAME (i), digs, complex_p,
 	   vector_p ? GET_MODE_NUNITS (i) : 0, float_rep,
-	   GET_MODE_PRECISION (i), GET_MODE_ALIGNMENT (i));
+	   GET_MODE_PRECISION (i), GET_MODE_BITSIZE (i),
+	   GET_MODE_ALIGNMENT (i));
     }
 }
 
diff --git a/gcc/alias.c b/gcc/alias.c
index aa404a7..381222c 100644
--- a/gcc/alias.c
+++ b/gcc/alias.c
@@ -156,7 +156,9 @@ static int base_alias_check (rtx, rtx, enum machine_mode,
 static alias_set_entry get_alias_set_entry (alias_set_type);
 static bool nonoverlapping_component_refs_p (const_rtx, const_rtx);
 static tree decl_for_component_ref (tree);
-static int write_dependence_p (const_rtx, const_rtx, int);
+static int write_dependence_p (const_rtx,
+	    		              const_rtx, enum machine_mode, rtx,
+				      		             bool, bool, bool);
 
 static void memory_modified_1 (rtx, const_rtx, void *);
 
@@ -2558,15 +2560,24 @@ static int base_alias_check (rtx, rtx, enum machine_mode,
 }
 
 /* Returns nonzero if a write to X might alias a previous read from
-   (or, if WRITEP is nonzero, a write to) MEM.  */
+   (or, if WRITEP is true, a write to) MEM.
+   If X_CANONCALIZED is true, then X_ADDR is the canonicalized address of X,
+   and X_MODE the mode for that access.
+   If MEM_CANONICALIZED is true, MEM is canonicalized.  */
 
 static int
-write_dependence_p (const_rtx mem, const_rtx x, int writep)
+write_dependence_p (const_rtx mem,
+		    	           const_rtx x, enum machine_mode x_mode, rtx x_addr,
+				   	         bool mem_canonicalized, bool x_canonicalized, bool writep)
 {
-  rtx x_addr, mem_addr;
+  rtx mem_addr;
   rtx base;
   int ret;
 
+  gcc_checking_assert (x_canonicalized
+  		              ? (x_addr != NULL_RTX && x_mode != VOIDmode)
+			      	       : (x_addr == NULL_RTX && x_mode == VOIDmode));
+
   if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))
     return 1;
 
@@ -2590,17 +2601,21 @@ static int base_alias_check (rtx, rtx, enum machine_mode,
   if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))
     return 1;
 
-  x_addr = XEXP (x, 0);
   mem_addr = XEXP (mem, 0);
-  if (!((GET_CODE (x_addr) == VALUE
-	 && GET_CODE (mem_addr) != VALUE
-	 && reg_mentioned_p (x_addr, mem_addr))
-	|| (GET_CODE (x_addr) != VALUE
-	    && GET_CODE (mem_addr) == VALUE
-	    && reg_mentioned_p (mem_addr, x_addr))))
+  if (!x_addr)
     {
-      x_addr = get_addr (x_addr);
-      mem_addr = get_addr (mem_addr);
+      x_addr = XEXP (x, 0);
+      if (!((GET_CODE (x_addr) == VALUE
+	     && GET_CODE (mem_addr) != VALUE
+	     && reg_mentioned_p (x_addr, mem_addr))
+	    || (GET_CODE (x_addr) != VALUE
+		&& GET_CODE (mem_addr) == VALUE
+		&& reg_mentioned_p (mem_addr, x_addr))))
+	{
+	  x_addr = get_addr (x_addr);
+	  if (!mem_canonicalized)
+	    mem_addr = get_addr (mem_addr);
+	}
     }
 
   if (! writep)
@@ -2616,11 +2631,16 @@ static int base_alias_check (rtx, rtx, enum machine_mode,
 			  GET_MODE (mem)))
     return 0;
 
-  x_addr = canon_rtx (x_addr);
-  mem_addr = canon_rtx (mem_addr);
+  if (!x_canonicalized)
+    {
+      x_addr = canon_rtx (x_addr);
+      x_mode = GET_MODE (x);
+    }
+  if (!mem_canonicalized)
+    mem_addr = canon_rtx (mem_addr);
 
   if ((ret = memrefs_conflict_p (SIZE_FOR_MODE (mem), mem_addr,
-				 SIZE_FOR_MODE (x), x_addr, 0)) != -1)
+				 GET_MODE_SIZE (x_mode), x_addr, 0)) != -1)
     return ret;
 
   if (nonoverlapping_memrefs_p (x, mem, false))
@@ -2634,7 +2654,23 @@ static int base_alias_check (rtx, rtx, enum machine_mode,
 int
 anti_dependence (const_rtx mem, const_rtx x)
 {
-  return write_dependence_p (mem, x, /*writep=*/0);
+  return write_dependence_p (mem, x, VOIDmode, NULL_RTX,
+  	  		          /*mem_canonicalized=*/false,
+						     /*x_canonicalized*/false, /*writep=*/false);
+}
+
+/* Likewise, but we already have a canonicalized MEM, and X_ADDR for X.
+   Also, consider X in X_MODE (which might be from an enclosing
+   STRICT_LOW_PART / ZERO_EXTRACT).
+   If MEM_CANONICALIZED is true, MEM is canonicalized.  */
+
+int
+canon_anti_dependence (const_rtx mem, bool mem_canonicalized,
+		       		         const_rtx x, enum machine_mode x_mode, rtx x_addr)
+{
+  return write_dependence_p (mem, x, x_mode, x_addr,
+  	  		          mem_canonicalized, /*x_canonicalized=*/true,
+							     /*writep=*/false);
 }
 
 /* Output dependence: X is written after store in MEM takes place.  */
@@ -2642,7 +2678,9 @@ static int base_alias_check (rtx, rtx, enum machine_mode,
 int
 output_dependence (const_rtx mem, const_rtx x)
 {
-  return write_dependence_p (mem, x, /*writep=*/1);
+  return write_dependence_p (mem, x, VOIDmode, NULL_RTX,
+  	  		          /*mem_canonicalized=*/false,
+						     /*x_canonicalized*/false, /*writep=*/true);
 }
 
 
diff --git a/gcc/config/avr/avr.c b/gcc/config/avr/avr.c
index 74872aa..44d8a83 100644
--- a/gcc/config/avr/avr.c
+++ b/gcc/config/avr/avr.c
@@ -587,10 +587,14 @@ enum reg_class
       const char *name;
 
       name = DECL_ASSEMBLER_NAME_SET_P (decl)
-        /* Remove the leading '*' added in set_user_assembler_name.  */
-        ? 1 + IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl))
+        ? IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl))
         : IDENTIFIER_POINTER (DECL_NAME (decl));
 
+      /* Skip a leading '*' that might still prefix the assembler name,
+         e.g. in non-LTO runs.  */
+
+      name = default_strip_name_encoding (name);
+
       /* Silently ignore 'signal' if 'interrupt' is present.  AVR-LibC startet
          using this when it switched from SIGNAL and INTERRUPT to ISR.  */
 
@@ -6806,8 +6810,8 @@ enum reg_class
 
   /* Work out the shortest sequence.  */
 
-  avr_out_plus_1 (op, &len_minus, MINUS, &cc_plus, code_sat, sign, out_label);
-  avr_out_plus_1 (op, &len_plus, PLUS, &cc_minus, code_sat, sign, out_label);
+  avr_out_plus_1 (op, &len_minus, MINUS, &cc_minus, code_sat, sign, out_label);
+  avr_out_plus_1 (op, &len_plus, PLUS, &cc_plus, code_sat, sign, out_label);
 
   if (plen)
     {
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index a6414c4..402dec8 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -35053,7 +35053,7 @@ struct builtin_description
 	{
 	  tmp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, fnaddr), UNSPEC_GOTPCREL);
 	  tmp = gen_rtx_CONST (Pmode, tmp);
-	  fnaddr = gen_rtx_MEM (Pmode, tmp);
+	  fnaddr = gen_const_mem (Pmode, tmp);
 	}
     }
   else
@@ -35073,8 +35073,9 @@ struct builtin_description
 	  output_set_got (tmp, NULL_RTX);
 
 	  fnaddr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, fnaddr), UNSPEC_GOT);
-	  fnaddr = gen_rtx_PLUS (Pmode, fnaddr, tmp);
-	  fnaddr = gen_rtx_MEM (Pmode, fnaddr);
+	  fnaddr = gen_rtx_CONST (Pmode, fnaddr);
+	  fnaddr = gen_rtx_PLUS (Pmode, tmp, fnaddr);
+	  fnaddr = gen_const_mem (Pmode, fnaddr);
 	}
     }
 
diff --git a/gcc/config/sparc/sparc-protos.h b/gcc/config/sparc/sparc-protos.h
index a0c1a7a..1fd7165 100644
--- a/gcc/config/sparc/sparc-protos.h
+++ b/gcc/config/sparc/sparc-protos.h
@@ -84,9 +84,9 @@ extern rtx sparc_legitimize_reload_address (rtx, enum machine_mode, int, int,
 extern int mems_ok_for_ldd_peep (rtx, rtx, rtx);
 extern int empty_delay_slot (rtx);
 extern int emit_cbcond_nop (rtx);
+extern int eligible_for_call_delay (rtx);
 extern int eligible_for_return_delay (rtx);
 extern int eligible_for_sibcall_delay (rtx);
-extern int tls_call_delay (rtx);
 extern int emit_move_sequence (rtx, enum machine_mode);
 extern int fp_sethi_p (rtx);
 extern int fp_mov_p (rtx);
diff --git a/gcc/config/sparc/sparc.c b/gcc/config/sparc/sparc.c
index c5bcb3b..dfcc148 100644
--- a/gcc/config/sparc/sparc.c
+++ b/gcc/config/sparc/sparc.c
@@ -881,15 +881,15 @@ static reg_class_t sparc_secondary_reload (bool, rtx, reg_class_t,
 	  && REGNO (SET_DEST (set)) % 2 != 0)
 	{
 	  /* The wrong dependency is on the enclosing double register.  */
-	  unsigned int x = REGNO (SET_DEST (set)) - 1;
+	  const unsigned int x = REGNO (SET_DEST (set)) - 1;
 	  unsigned int src1, src2, dest;
 	  int code;
 
-	  /* If the insn has a delay slot, then it cannot be problematic.  */
 	  next = next_active_insn (insn);
 	  if (!next)
 	    break;
-	  if (NONJUMP_INSN_P (next) && GET_CODE (PATTERN (next)) == SEQUENCE)
+	  /* If the insn is a branch, then it cannot be problematic.  */
+	  if (!NONJUMP_INSN_P (next) || GET_CODE (PATTERN (next)) == SEQUENCE)
 	    continue;
 
 	  extract_insn (next);
@@ -953,11 +953,11 @@ static reg_class_t sparc_secondary_reload (bool, rtx, reg_class_t,
 	     dependency on the first single-cycle load.  */
 	  rtx x = SET_DEST (set);
 
-	  /* If the insn has a delay slot, then it cannot be problematic.  */
 	  next = next_active_insn (insn);
 	  if (!next)
 	    break;
-	  if (NONJUMP_INSN_P (next) && GET_CODE (PATTERN (next)) == SEQUENCE)
+	  /* If the insn is a branch, then it cannot be problematic.  */
+	  if (!NONJUMP_INSN_P (next) || GET_CODE (PATTERN (next)) == SEQUENCE)
 	    continue;
 
 	  /* Look for a second memory access to/from an integer register.  */
@@ -975,17 +975,117 @@ static reg_class_t sparc_secondary_reload (bool, rtx, reg_class_t,
 		insert_nop = true;
 
 	      /* STD is *not* affected.  */
-	      else if ((mem = mem_ref (dest)) != NULL_RTX
-		       && GET_MODE_SIZE (GET_MODE (mem)) <= 4
-		       && (src == const0_rtx
+	      else if (MEM_P (dest)
+		       && GET_MODE_SIZE (GET_MODE (dest)) <= 4
+		       && (src == CONST0_RTX (GET_MODE (dest))
 			   || (REG_P (src)
 			       && REGNO (src) < 32
 			       && REGNO (src) != REGNO (x)))
-		       && !reg_mentioned_p (x, XEXP (mem, 0)))
+		       && !reg_mentioned_p (x, XEXP (dest, 0)))
 		insert_nop = true;
 	    }
 	}
 
+      /* Look for a single-word load/operation into an FP register.  */
+      else if (sparc_fix_ut699
+	       && NONJUMP_INSN_P (insn)
+	       && (set = single_set (insn)) != NULL_RTX
+	       && GET_MODE_SIZE (GET_MODE (SET_SRC (set))) == 4
+	       && REG_P (SET_DEST (set))
+	       && REGNO (SET_DEST (set)) > 31)
+	{
+	  /* Number of instructions in the problematic window.  */
+	  const int n_insns = 4;
+	  /* The problematic combination is with the sibling FP register.  */
+	  const unsigned int x = REGNO (SET_DEST (set));
+	  const unsigned int y = x ^ 1;
+	  rtx after;
+	  int i;
+
+	  next = next_active_insn (insn);
+	  if (!next)
+	    break;
+	  /* If the insn is a branch, then it cannot be problematic.  */
+	  if (!NONJUMP_INSN_P (next) || GET_CODE (PATTERN (next)) == SEQUENCE)
+	    continue;
+
+	  /* Look for a second load/operation into the sibling FP register.  */
+	  if (!((set = single_set (next)) != NULL_RTX
+		&& GET_MODE_SIZE (GET_MODE (SET_SRC (set))) == 4
+		&& REG_P (SET_DEST (set))
+		&& REGNO (SET_DEST (set)) == y))
+	    continue;
+
+	  /* Look for a (possible) store from the FP register in the next N
+	     instructions, but bail out if it is again modified or if there
+	     is a store from the sibling FP register before this store.  */
+	  for (after = next, i = 0; i < n_insns; i++)
+	    {
+	      bool branch_p;
+
+	      after = next_active_insn (after);
+	      if (!after)
+		break;
+
+	      /* This is a branch with an empty delay slot.  */
+	      if (!NONJUMP_INSN_P (after))
+		{
+		  if (++i == n_insns)
+		    break;
+		  branch_p = true;
+		  after = NULL_RTX;
+		}
+	      /* This is a branch with a filled delay slot.  */
+	      else if (GET_CODE (PATTERN (after)) == SEQUENCE)
+		{
+		  if (++i == n_insns)
+		    break;
+		  branch_p = true;
+		  after = XVECEXP (PATTERN (after), 0, 1);
+		}
+	      /* This is a regular instruction.  */
+	      else
+		branch_p = false;
+
+	      if (after && (set = single_set (after)) != NULL_RTX)
+		{
+		  const rtx src = SET_SRC (set);
+		  const rtx dest = SET_DEST (set);
+		  const unsigned int size = GET_MODE_SIZE (GET_MODE (dest));
+
+		  /* If the FP register is again modified before the store,
+		     then the store isn't affected.  */
+		  if (REG_P (dest)
+		      && (REGNO (dest) == x
+			  || (REGNO (dest) == y && size == 8)))
+		    break;
+
+		  if (MEM_P (dest) && REG_P (src))
+		    {
+		      /* If there is a store from the sibling FP register
+			 before the store, then the store is not affected.  */
+		      if (REGNO (src) == y || (REGNO (src) == x && size == 8))
+			break;
+
+		      /* Otherwise, the store is affected.  */
+		      if (REGNO (src) == x && size == 4)
+			{
+			  insert_nop = true;
+			  break;
+			}
+		    }
+		}
+
+	      /* If we have a branch in the first M instructions, then we
+		 cannot see the (M+2)th instruction so we play safe.  */
+	      if (branch_p && i <= (n_insns - 2))
+		{
+		  insert_nop = true;
+		  break;
+		}
+	    }
+	}
+
       else
 	next = NEXT_INSN (insn);
 
@@ -3329,10 +3429,13 @@ enum machine_mode
 /* Return nonzero if TRIAL can go into the call delay slot.  */
 
 int
-tls_call_delay (rtx trial)
+eligible_for_call_delay (rtx trial)
 {
   rtx pat;
 
+  if (get_attr_in_branch_delay (trial) == IN_BRANCH_DELAY_FALSE)
+    return 0;
+
   /* Binutils allows
        call __tls_get_addr, %tgd_call (foo)
         add %l7, %o0, %o0, %tgd_add (foo)
@@ -3414,11 +3517,7 @@ enum machine_mode
 
   /* If we have the 'return' instruction, anything that does not use
      local or output registers and can go into a delay slot wins.  */
-  else if (return_p
-	   && TARGET_V9
-	   && !epilogue_renumber (&pat, 1)
-	   && get_attr_in_uncond_branch_delay (trial)
-	       == IN_UNCOND_BRANCH_DELAY_TRUE)
+  else if (return_p && TARGET_V9 && !epilogue_renumber (&pat, 1))
     return 1;
 
   /* The 'restore src1,src2,dest' pattern for SImode.  */
@@ -3461,21 +3560,20 @@ enum machine_mode
   int regno;
   rtx pat;
 
-  if (GET_CODE (trial) != INSN)
-    return 0;
-
-  if (get_attr_length (trial) != 1)
-    return 0;
-
   /* If the function uses __builtin_eh_return, the eh_return machinery
      occupies the delay slot.  */
   if (crtl->calls_eh_return)
     return 0;
 
+  if (get_attr_in_branch_delay (trial) == IN_BRANCH_DELAY_FALSE)
+    return 0;
+
   /* In the case of a leaf or flat function, anything can go into the slot.  */
   if (sparc_leaf_function_p || TARGET_FLAT)
-    return
-      get_attr_in_uncond_branch_delay (trial) == IN_UNCOND_BRANCH_DELAY_TRUE;
+    return 1;
+
+  if (!NONJUMP_INSN_P (trial))
+    return 0;
 
   pat = PATTERN (trial);
   if (GET_CODE (pat) == PARALLEL)
@@ -3495,9 +3593,7 @@ enum machine_mode
 	  if (regno >= 8 && regno < 24)
 	    return 0;
 	}
-      return !epilogue_renumber (&pat, 1)
-	&& (get_attr_in_uncond_branch_delay (trial)
-	    == IN_UNCOND_BRANCH_DELAY_TRUE);
+      return !epilogue_renumber (&pat, 1);
     }
 
   if (GET_CODE (pat) != SET)
@@ -3517,10 +3613,7 @@ enum machine_mode
      instruction, it can probably go in.  But restore will not work
      with FP_REGS.  */
   if (! SPARC_INT_REG_P (regno))
-    return (TARGET_V9
-	    && !epilogue_renumber (&pat, 1)
-	    && get_attr_in_uncond_branch_delay (trial)
-	       == IN_UNCOND_BRANCH_DELAY_TRUE);
+    return TARGET_V9 && !epilogue_renumber (&pat, 1);
 
   return eligible_for_restore_insn (trial, true);
 }
@@ -3532,10 +3625,10 @@ enum machine_mode
 {
   rtx pat;
 
-  if (GET_CODE (trial) != INSN || GET_CODE (PATTERN (trial)) != SET)
+  if (get_attr_in_branch_delay (trial) == IN_BRANCH_DELAY_FALSE)
     return 0;
 
-  if (get_attr_length (trial) != 1)
+  if (!NONJUMP_INSN_P (trial))
     return 0;
 
   pat = PATTERN (trial);
@@ -3554,6 +3647,9 @@ enum machine_mode
       return 1;
     }
 
+  if (GET_CODE (pat) != SET)
+    return 0;
+
   /* Otherwise, only operations which can be done in tandem with
      a `restore' insn can go into the delay slot.  */
   if (GET_CODE (SET_DEST (pat)) != REG
diff --git a/gcc/config/sparc/sparc.md b/gcc/config/sparc/sparc.md
index 737cff0..96bf1e7 100644
--- a/gcc/config/sparc/sparc.md
+++ b/gcc/config/sparc/sparc.md
@@ -285,7 +285,8 @@
   (const_string "none"))
 
 (define_attr "pic" "false,true"
-  (symbol_ref "(flag_pic != 0 ? PIC_TRUE : PIC_FALSE)"))
+  (symbol_ref "(flag_pic != 0
+		? PIC_TRUE : PIC_FALSE)"))
 
 (define_attr "calls_alloca" "false,true"
   (symbol_ref "(cfun->calls_alloca != 0
@@ -307,6 +308,10 @@
   (symbol_ref "(TARGET_FLAT != 0
 		? FLAT_TRUE : FLAT_FALSE)"))
 
+(define_attr "fix_ut699" "false,true"
+   (symbol_ref "(sparc_fix_ut699 != 0
+		 ? FIX_UT699_TRUE : FIX_UT699_FALSE)"))
+
 ;; Length (in # of insns).
 ;; Beware that setting a length greater or equal to 3 for conditional branches
 ;; has a side-effect (see output_cbranch and output_v9branch).
@@ -421,32 +426,18 @@
   [(set_attr "length" "2")
    (set_attr "type" "multi")])
 
-;; Attributes for instruction and branch scheduling
-(define_attr "tls_call_delay" "false,true"
-  (symbol_ref "(tls_call_delay (insn)
-		? TLS_CALL_DELAY_TRUE : TLS_CALL_DELAY_FALSE)"))
-
+;; Attributes for branch scheduling
 (define_attr "in_call_delay" "false,true"
-  (cond [(eq_attr "type" "uncond_branch,branch,cbcond,uncond_cbcond,call,sibcall,call_no_delay_slot,multi")
-		(const_string "false")
-	 (eq_attr "type" "load,fpload,store,fpstore")
-		(if_then_else (eq_attr "length" "1")
-			      (const_string "true")
-			      (const_string "false"))]
-	 (if_then_else (and (eq_attr "length" "1")
-			    (eq_attr "tls_call_delay" "true"))
-		       (const_string "true")
-		       (const_string "false"))))
-
-(define_attr "eligible_for_sibcall_delay" "false,true"
+  (symbol_ref "(eligible_for_call_delay (insn)
+		? IN_CALL_DELAY_TRUE : IN_CALL_DELAY_FALSE)"))
+
+(define_attr "in_sibcall_delay" "false,true"
   (symbol_ref "(eligible_for_sibcall_delay (insn)
-		? ELIGIBLE_FOR_SIBCALL_DELAY_TRUE
-		: ELIGIBLE_FOR_SIBCALL_DELAY_FALSE)"))
+		? IN_SIBCALL_DELAY_TRUE : IN_SIBCALL_DELAY_FALSE)"))
 
-(define_attr "eligible_for_return_delay" "false,true"
+(define_attr "in_return_delay" "false,true"
   (symbol_ref "(eligible_for_return_delay (insn)
-		? ELIGIBLE_FOR_RETURN_DELAY_TRUE
-		: ELIGIBLE_FOR_RETURN_DELAY_FALSE)"))
+		? IN_RETURN_DELAY_TRUE : IN_RETURN_DELAY_FALSE)"))
 
 ;; ??? !v9: Should implement the notion of predelay slots for floating-point
 ;; branches.  This would allow us to remove the nop always inserted before
@@ -461,39 +452,32 @@
 ;; because it prevents us from moving back the final store of inner loops.
 
 (define_attr "in_branch_delay" "false,true"
-  (if_then_else (and (eq_attr "type" "!uncond_branch,branch,cbcond,uncond_cbcond,call,sibcall,call_no_delay_slot,multi")
-		     (eq_attr "length" "1"))
-		(const_string "true")
-		(const_string "false")))
-
-(define_attr "in_uncond_branch_delay" "false,true"
-  (if_then_else (and (eq_attr "type" "!uncond_branch,branch,cbcond,uncond_cbcond,call,sibcall,call_no_delay_slot,multi")
-		     (eq_attr "length" "1"))
-		(const_string "true")
-		(const_string "false")))
-
-(define_attr "in_annul_branch_delay" "false,true"
-  (if_then_else (and (eq_attr "type" "!uncond_branch,branch,cbcond,uncond_cbcond,call,sibcall,call_no_delay_slot,multi")
-		     (eq_attr "length" "1"))
-		(const_string "true")
-		(const_string "false")))
+  (cond [(eq_attr "type" "uncond_branch,branch,cbcond,uncond_cbcond,call,sibcall,call_no_delay_slot,multi")
+	   (const_string "false")
+	 (and (eq_attr "fix_ut699" "true") (eq_attr "type" "load,sload"))
+	   (const_string "false")
+	 (and (eq_attr "fix_ut699" "true")
+	      (and (eq_attr "type" "fpload,fp,fpmove,fpmul,fpdivs,fpsqrts")
+		   (eq_attr "fptype" "single")))
+	   (const_string "false")
+	 (eq_attr "length" "1")
+	   (const_string "true")
+	] (const_string "false")))
 
 (define_delay (eq_attr "type" "call")
   [(eq_attr "in_call_delay" "true") (nil) (nil)])
 
 (define_delay (eq_attr "type" "sibcall")
-  [(eq_attr "eligible_for_sibcall_delay" "true") (nil) (nil)])
+  [(eq_attr "in_sibcall_delay" "true") (nil) (nil)])
+
+(define_delay (eq_attr "type" "return")
+  [(eq_attr "in_return_delay" "true") (nil) (nil)])
 
 (define_delay (eq_attr "type" "branch")
-  [(eq_attr "in_branch_delay" "true")
-   (nil) (eq_attr "in_annul_branch_delay" "true")])
+  [(eq_attr "in_branch_delay" "true") (nil) (eq_attr "in_branch_delay" "true")])
 
 (define_delay (eq_attr "type" "uncond_branch")
-  [(eq_attr "in_uncond_branch_delay" "true")
-   (nil) (nil)])
-
-(define_delay (eq_attr "type" "return")
-  [(eq_attr "eligible_for_return_delay" "true") (nil) (nil)])
+  [(eq_attr "in_branch_delay" "true") (nil) (nil)])
 
 
 ;; Include SPARC DFA schedulers
@@ -5576,7 +5560,7 @@
 		(match_operand:TF 2 "register_operand" "e")))]
   "TARGET_FPU && TARGET_HARD_QUAD"
   "fdivq\t%1, %2, %0"
-  [(set_attr "type" "fpdivd")])
+  [(set_attr "type" "fpdivs")])
 
 (define_expand "divdf3"
   [(set (match_operand:DF 0 "register_operand" "=e")
@@ -5807,7 +5791,7 @@
 	(sqrt:TF (match_operand:TF 1 "register_operand" "e")))]
   "TARGET_FPU && TARGET_HARD_QUAD"
   "fsqrtq\t%1, %0"
-  [(set_attr "type" "fpsqrtd")])
+  [(set_attr "type" "fpsqrts")])
 
 (define_expand "sqrtdf2"
   [(set (match_operand:DF 0 "register_operand" "=e")
diff --git a/gcc/cse.c b/gcc/cse.c
index 1d45074..40105a9 100644
--- a/gcc/cse.c
+++ b/gcc/cse.c
@@ -1824,7 +1824,7 @@ static enum machine_mode cse_cc_succs (basic_block, basic_block, rtx, rtx,
       }
 }
 
-/* Function called for each rtx to check whether true dependence exist.  */
+/* Function called for each rtx to check whether an anti dependence exist.  */
 struct check_dependence_data
 {
   enum machine_mode mode;
@@ -1837,7 +1837,7 @@ struct check_dependence_data
 {
   struct check_dependence_data *d = (struct check_dependence_data *) data;
   if (*x && MEM_P (*x))
-    return canon_true_dependence (d->exp, d->mode, d->addr, *x, NULL_RTX);
+    return canon_anti_dependence (*x, true, d->exp, d->mode, d->addr);
   else
     return 0;
 }
diff --git a/gcc/cselib.c b/gcc/cselib.c
index f2021b9..334d955 100644
--- a/gcc/cselib.c
+++ b/gcc/cselib.c
@@ -2260,8 +2260,8 @@ enum machine_mode
 	      continue;
 	    }
 	  if (num_mems < PARAM_VALUE (PARAM_MAX_CSELIB_MEMORY_LOCATIONS)
-	      && ! canon_true_dependence (mem_rtx, GET_MODE (mem_rtx),
-					  mem_addr, x, NULL_RTX))
+	      && ! canon_anti_dependence (x, false, mem_rtx,
+					  GET_MODE (mem_rtx), mem_addr))
 	    {
 	      has_mem = true;
 	      num_mems++;
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index db89c5f..2108402 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -1,3 +1,24 @@
+2014-03-20  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/60543
+	PR fortran/60283
+	* gfortran.h (gfc_unset_implicit_pure): New prototype.
+	* resolve.c (gfc_unset_implicit_pure): New.
+	(resolve_structure_cons, resolve_function,
+	pure_subroutine, resolve_ordinary_assign): Use it.
+	* decl.c (match_old_style_init, gfc_match_data,
+	match_pointer_init, variable_decl): Ditto.
+	* expr.c (gfc_check_pointer_assign): Ditto.
+	* intrinsic.c (gfc_intrinsic_sub_interface): Ditto.
+	* io.c (match_vtag, gfc_match_open, gfc_match_close,
+	match_filepos, gfc_match_inquire, gfc_match_print,
+	gfc_match_wait, check_io_constraints): Ditto.
+	* match.c (gfc_match_critical, gfc_match_stopcode,
+	lock_unlock_statement, sync_statement, gfc_match_allocate,
+	gfc_match_deallocate): Ditto.
+	* parse.c (decode_omp_directive): Ditto.
+	* symbol.c (gfc_add_save): Ditto.
+
 2014-03-08  Janus Weil  <janus@gcc.gnu.org>
 
 	PR fortran/60450
diff --git a/gcc/fortran/decl.c b/gcc/fortran/decl.c
index c6e16c7..7dec803 100644
--- a/gcc/fortran/decl.c
+++ b/gcc/fortran/decl.c
@@ -510,9 +510,7 @@
       free (newdata);
       return MATCH_ERROR;
     }
-
-  if (gfc_implicit_pure (NULL))
-    gfc_current_ns->proc_name->attr.implicit_pure = 0;
+  gfc_unset_implicit_pure (gfc_current_ns->proc_name);
 
   /* Mark the variable as having appeared in a data statement.  */
   if (gfc_add_data (&sym->attr, sym->name, &sym->declared_at) == FAILURE)
@@ -571,9 +569,7 @@
       gfc_error ("DATA statement at %C is not allowed in a PURE procedure");
       return MATCH_ERROR;
     }
-
-  if (gfc_implicit_pure (NULL))
-    gfc_current_ns->proc_name->attr.implicit_pure = 0;
+  gfc_unset_implicit_pure (gfc_current_ns->proc_name);
 
   return MATCH_YES;
 
@@ -1737,6 +1733,7 @@
 		 "a PURE procedure");
       return MATCH_ERROR;
     }
+  gfc_unset_implicit_pure (gfc_current_ns->proc_name);
 
   /* Match NULL() initialization.  */
   m = gfc_match_null (init);
@@ -2045,6 +2042,10 @@
 	      m = MATCH_ERROR;
 	    }
 
+	  if (current_attr.flavor != FL_PARAMETER
+	      && gfc_state_stack->state != COMP_DERIVED)
+	    gfc_unset_implicit_pure (gfc_current_ns->proc_name);
+
 	  if (m != MATCH_YES)
 	    goto cleanup;
 	}
diff --git a/gcc/fortran/expr.c b/gcc/fortran/expr.c
index c3dbd01..0e89a4c 100644
--- a/gcc/fortran/expr.c
+++ b/gcc/fortran/expr.c
@@ -3681,8 +3681,7 @@
     }
 
   if (is_implicit_pure && gfc_impure_variable (rvalue->symtree->n.sym))
-    gfc_current_ns->proc_name->attr.implicit_pure = 0;
-
+    gfc_unset_implicit_pure (gfc_current_ns->proc_name);
 
   if (gfc_has_vector_index (rvalue))
     {
diff --git a/gcc/fortran/gfortran.h b/gcc/fortran/gfortran.h
index 18bbf79..bd1aeb9 100644
--- a/gcc/fortran/gfortran.h
+++ b/gcc/fortran/gfortran.h
@@ -2830,6 +2830,7 @@ gfc_expr* gfc_build_intrinsic_call (gfc_namespace *, gfc_isym_id, const char*,
 int gfc_impure_variable (gfc_symbol *);
 int gfc_pure (gfc_symbol *);
 int gfc_implicit_pure (gfc_symbol *);
+void gfc_unset_implicit_pure (gfc_symbol *);
 int gfc_elemental (gfc_symbol *);
 gfc_try gfc_resolve_iterator (gfc_iterator *, bool, bool);
 gfc_try find_forall_index (gfc_expr *, gfc_symbol *, int);
diff --git a/gcc/fortran/intrinsic.c b/gcc/fortran/intrinsic.c
index c571533..7d78419 100644
--- a/gcc/fortran/intrinsic.c
+++ b/gcc/fortran/intrinsic.c
@@ -4229,13 +4229,16 @@ enum klass
       c->resolved_sym->attr.elemental = isym->elemental;
     }
 
-  if (gfc_pure (NULL) && !isym->pure)
+  if (!isym->pure && gfc_pure (NULL))
     {
       gfc_error ("Subroutine call to intrinsic '%s' at %L is not PURE", name,
 		 &c->loc);
       return MATCH_ERROR;
     }
 
+  if (!isym->pure)
+    gfc_unset_implicit_pure (NULL);
+
   c->resolved_sym->attr.noreturn = isym->noreturn;
 
   return MATCH_YES;
diff --git a/gcc/fortran/io.c b/gcc/fortran/io.c
index 748a4f2..1d46474 100644
--- a/gcc/fortran/io.c
+++ b/gcc/fortran/io.c
@@ -1309,7 +1309,8 @@
       return MATCH_ERROR;
     }
 
-  if (gfc_pure (NULL) && gfc_impure_variable (result->symtree->n.sym))
+  bool impure = gfc_impure_variable (result->symtree->n.sym);
+  if (impure && gfc_pure (NULL))
     {
       gfc_error ("Variable %s cannot be assigned in PURE procedure at %C",
 		 tag->name);
@@ -1317,8 +1318,8 @@
       return MATCH_ERROR;
     }
 
-  if (gfc_implicit_pure (NULL) && gfc_impure_variable (result->symtree->n.sym))
-    gfc_current_ns->proc_name->attr.implicit_pure = 0;
+  if (impure)
+    gfc_unset_implicit_pure (NULL);
 
   *v = result;
   return MATCH_YES;
@@ -1838,8 +1839,7 @@
       goto cleanup;
     }
 
-  if (gfc_implicit_pure (NULL))
-    gfc_current_ns->proc_name->attr.implicit_pure = 0;
+  gfc_unset_implicit_pure (NULL);
 
   warn = (open->err || open->iostat) ? true : false;
 
@@ -2251,8 +2251,7 @@
       goto cleanup;
     }
 
-  if (gfc_implicit_pure (NULL))
-    gfc_current_ns->proc_name->attr.implicit_pure = 0;
+  gfc_unset_implicit_pure (NULL);
 
   warn = (close->iostat || close->err) ? true : false;
 
@@ -2419,8 +2418,7 @@
       goto cleanup;
     }
 
-  if (gfc_implicit_pure (NULL))
-    gfc_current_ns->proc_name->attr.implicit_pure = 0;
+  gfc_unset_implicit_pure (NULL);
 
   new_st.op = op;
   new_st.ext.filepos = fp;
@@ -3276,9 +3274,8 @@
 		     "an internal file in a PURE procedure",
 		     io_kind_name (k));
 
-      if (gfc_implicit_pure (NULL) && (k == M_READ || k == M_WRITE))
-	gfc_current_ns->proc_name->attr.implicit_pure = 0;
-
+      if (k == M_READ || k == M_WRITE)
+	gfc_unset_implicit_pure (NULL);
     }
 
   if (k != M_READ)
@@ -3809,8 +3806,7 @@
       return MATCH_ERROR;
     }
 
-  if (gfc_implicit_pure (NULL))
-    gfc_current_ns->proc_name->attr.implicit_pure = 0;
+  gfc_unset_implicit_pure (NULL);
 
   return MATCH_YES;
 }
@@ -3969,8 +3965,7 @@
 	  return MATCH_ERROR;
 	}
 
-      if (gfc_implicit_pure (NULL))
-	gfc_current_ns->proc_name->attr.implicit_pure = 0;
+      gfc_unset_implicit_pure (NULL);
 
       new_st.block = gfc_get_code ();
       new_st.block->op = EXEC_IOLENGTH;
@@ -4023,8 +4018,7 @@
       goto cleanup;
     }
 
-  if (gfc_implicit_pure (NULL))
-    gfc_current_ns->proc_name->attr.implicit_pure = 0;
+  gfc_unset_implicit_pure (NULL);
   
   if (inquire->id != NULL && inquire->pending == NULL)
     {
@@ -4212,8 +4206,7 @@
       goto cleanup;
     }
 
-  if (gfc_implicit_pure (NULL))
-    gfc_current_ns->proc_name->attr.implicit_pure = 0;
+  gfc_unset_implicit_pure (NULL);
 
   new_st.op = EXEC_WAIT;
   new_st.ext.wait = wait;
diff --git a/gcc/fortran/match.c b/gcc/fortran/match.c
index a320248..9827b6c 100644
--- a/gcc/fortran/match.c
+++ b/gcc/fortran/match.c
@@ -1753,8 +1753,7 @@
       return MATCH_ERROR;
     }
 
-  if (gfc_implicit_pure (NULL))
-    gfc_current_ns->proc_name->attr.implicit_pure = 0;
+  gfc_unset_implicit_pure (NULL);
 
   if (gfc_notify_std (GFC_STD_F2008, "CRITICAL statement at %C")
       == FAILURE)
@@ -2683,8 +2682,7 @@
       goto cleanup;
     }
 
-  if (gfc_implicit_pure (NULL))
-    gfc_current_ns->proc_name->attr.implicit_pure = 0;
+  gfc_unset_implicit_pure (NULL);
 
   if (st == ST_STOP && gfc_find_state (COMP_CRITICAL) == SUCCESS)
     {
@@ -2824,8 +2822,7 @@
       return MATCH_ERROR;
     }
 
-  if (gfc_implicit_pure (NULL))
-    gfc_current_ns->proc_name->attr.implicit_pure = 0;
+  gfc_unset_implicit_pure (NULL);
 
   if (gfc_option.coarray == GFC_FCOARRAY_NONE)
     {
@@ -3020,8 +3017,7 @@
       return MATCH_ERROR;
     }
 
-  if (gfc_implicit_pure (NULL))
-    gfc_current_ns->proc_name->attr.implicit_pure = 0;
+  gfc_unset_implicit_pure (NULL);
 
   if (gfc_notify_std (GFC_STD_F2008, "SYNC statement at %C")
       == FAILURE)
@@ -3500,15 +3496,15 @@
       if (gfc_check_do_variable (tail->expr->symtree))
 	goto cleanup;
 
-      if (gfc_pure (NULL) && gfc_impure_variable (tail->expr->symtree->n.sym))
+      bool impure = gfc_impure_variable (tail->expr->symtree->n.sym);
+      if (impure && gfc_pure (NULL))
 	{
 	  gfc_error ("Bad allocate-object at %C for a PURE procedure");
 	  goto cleanup;
 	}
 
-      if (gfc_implicit_pure (NULL)
-	    && gfc_impure_variable (tail->expr->symtree->n.sym))
-	gfc_current_ns->proc_name->attr.implicit_pure = 0;
+      if (impure)
+	gfc_unset_implicit_pure (NULL);
 
       if (tail->expr->ts.deferred)
 	{
@@ -3890,14 +3886,15 @@
 
       sym = tail->expr->symtree->n.sym;
 
-      if (gfc_pure (NULL) && gfc_impure_variable (sym))
+      bool impure = gfc_impure_variable (sym);
+      if (impure && gfc_pure (NULL))
 	{
 	  gfc_error ("Illegal allocate-object at %C for a PURE procedure");
 	  goto cleanup;
 	}
 
-      if (gfc_implicit_pure (NULL) && gfc_impure_variable (sym))
-	gfc_current_ns->proc_name->attr.implicit_pure = 0;
+      if (impure)
+	gfc_unset_implicit_pure (NULL);
 
       if (gfc_is_coarray (tail->expr)
 	  && gfc_find_state (COMP_DO_CONCURRENT) == SUCCESS)
diff --git a/gcc/fortran/parse.c b/gcc/fortran/parse.c
index 33d325d..f748fe3 100644
--- a/gcc/fortran/parse.c
+++ b/gcc/fortran/parse.c
@@ -550,8 +550,7 @@
       return ST_NONE;
     }
 
-  if (gfc_implicit_pure (NULL))
-    gfc_current_ns->proc_name->attr.implicit_pure = 0;
+  gfc_unset_implicit_pure (NULL);
 
   old_locus = gfc_current_locus;
 
diff --git a/gcc/fortran/resolve.c b/gcc/fortran/resolve.c
index eab98ad..43eb240 100644
--- a/gcc/fortran/resolve.c
+++ b/gcc/fortran/resolve.c
@@ -1259,9 +1259,10 @@
 	}
 
       /* F2003, C1272 (3).  */
-      if (gfc_pure (NULL) && cons->expr->expr_type == EXPR_VARIABLE
-	  && (gfc_impure_variable (cons->expr->symtree->n.sym)
-	      || gfc_is_coindexed (cons->expr)))
+      bool impure = cons->expr->expr_type == EXPR_VARIABLE
+		    && (gfc_impure_variable (cons->expr->symtree->n.sym)
+			|| gfc_is_coindexed (cons->expr));
+      if (impure && gfc_pure (NULL))
 	{
 	  t = FAILURE;
 	  gfc_error ("Invalid expression in the structure constructor for "
@@ -1269,12 +1270,8 @@
 		     comp->name, &cons->expr->where);
 	}
 
-      if (gfc_implicit_pure (NULL)
-	    && cons->expr->expr_type == EXPR_VARIABLE
-	    && (gfc_impure_variable (cons->expr->symtree->n.sym)
-		|| gfc_is_coindexed (cons->expr)))
-	gfc_current_ns->proc_name->attr.implicit_pure = 0;
-
+      if (impure)
+	gfc_unset_implicit_pure (NULL);
     }
 
   return t;
@@ -3295,8 +3292,7 @@
 	  t = FAILURE;
 	}
 
-      if (gfc_implicit_pure (NULL))
-	gfc_current_ns->proc_name->attr.implicit_pure = 0;
+      gfc_unset_implicit_pure (NULL);
     }
 
   /* Functions without the RECURSIVE attribution are not allowed to
@@ -3361,8 +3357,7 @@
     gfc_error ("Subroutine call to '%s' at %L is not PURE", sym->name,
 	       &c->loc);
 
-  if (gfc_implicit_pure (NULL))
-    gfc_current_ns->proc_name->attr.implicit_pure = 0;
+  gfc_unset_implicit_pure (NULL);
 }
 
 
@@ -9613,7 +9608,7 @@
       if (lhs->expr_type == EXPR_VARIABLE
 	    && lhs->symtree->n.sym != gfc_current_ns->proc_name
 	    && lhs->symtree->n.sym->ns != gfc_current_ns)
-	gfc_current_ns->proc_name->attr.implicit_pure = 0;
+	gfc_unset_implicit_pure (NULL);
 
       if (lhs->ts.type == BT_DERIVED
 	    && lhs->expr_type == EXPR_VARIABLE
@@ -9621,11 +9616,11 @@
 	    && rhs->expr_type == EXPR_VARIABLE
 	    && (gfc_impure_variable (rhs->symtree->n.sym)
 		|| gfc_is_coindexed (rhs)))
-	gfc_current_ns->proc_name->attr.implicit_pure = 0;
+	gfc_unset_implicit_pure (NULL);
 
       /* Fortran 2008, C1283.  */
       if (gfc_is_coindexed (lhs))
-	gfc_current_ns->proc_name->attr.implicit_pure = 0;
+	gfc_unset_implicit_pure (NULL);
     }
 
   /* F03:7.4.1.2.  */
@@ -14390,6 +14385,33 @@
 }
 
 
+void
+gfc_unset_implicit_pure (gfc_symbol *sym)
+{
+  gfc_namespace *ns;
+
+  if (sym == NULL)
+    {
+      /* Check if the current procedure is implicit_pure.  Walk up
+	 the procedure list until we find a procedure.  */
+      for (ns = gfc_current_ns; ns; ns = ns->parent)
+	{
+	  sym = ns->proc_name;
+	  if (sym == NULL)
+	    return;
+
+	  if (sym->attr.flavor == FL_PROCEDURE)
+	    break;
+	}
+    }
+
+  if (sym->attr.flavor == FL_PROCEDURE)
+    sym->attr.implicit_pure = 0;
+  else
+    sym->attr.pure = 0;
+}
+
+
 /* Test whether the current procedure is elemental or not.  */
 
 int
diff --git a/gcc/fortran/symbol.c b/gcc/fortran/symbol.c
index ef4076d..1b3702f 100644
--- a/gcc/fortran/symbol.c
+++ b/gcc/fortran/symbol.c
@@ -1110,8 +1110,8 @@
       return FAILURE;
     }
 
-  if (s == SAVE_EXPLICIT && gfc_implicit_pure (NULL))
-    gfc_current_ns->proc_name->attr.implicit_pure = 0;
+  if (s == SAVE_EXPLICIT)
+    gfc_unset_implicit_pure (NULL);
 
   if (s == SAVE_EXPLICIT && attr->save == SAVE_EXPLICIT)
     {
diff --git a/gcc/rtl.h b/gcc/rtl.h
index a86034e..91f3387 100644
--- a/gcc/rtl.h
+++ b/gcc/rtl.h
@@ -2705,6 +2705,8 @@ extern int canon_true_dependence (const_rtx, enum machine_mode, rtx,
 				  const_rtx, rtx);
 extern int read_dependence (const_rtx, const_rtx);
 extern int anti_dependence (const_rtx, const_rtx);
+extern int canon_anti_dependence (const_rtx, bool,
+	    			  	        const_rtx, enum machine_mode, rtx);
 extern int output_dependence (const_rtx, const_rtx);
 extern int may_alias_p (const_rtx, const_rtx);
 extern void init_alias_target (void);
diff --git a/gcc/sdbout.c b/gcc/sdbout.c
index 13c11c2..44bdf3e 100644
--- a/gcc/sdbout.c
+++ b/gcc/sdbout.c
@@ -1226,7 +1226,10 @@
 sdbout_parms (tree parms)
 {
   for (; parms; parms = TREE_CHAIN (parms))
-    if (DECL_NAME (parms))
+    if (DECL_NAME (parms)
+	&& TREE_TYPE (parms) != error_mark_node
+	&& DECL_RTL_SET_P (parms)
+	&& DECL_INCOMING_RTL (parms))
       {
 	int current_sym_value = 0;
 	const char *name = IDENTIFIER_POINTER (DECL_NAME (parms));
@@ -1358,7 +1361,10 @@
 sdbout_reg_parms (tree parms)
 {
   for (; parms; parms = TREE_CHAIN (parms))
-    if (DECL_NAME (parms))
+    if (DECL_NAME (parms)
+        && TREE_TYPE (parms) != error_mark_node
+        && DECL_RTL_SET_P (parms)
+        && DECL_INCOMING_RTL (parms))
       {
 	const char *name = IDENTIFIER_POINTER (DECL_NAME (parms));
 
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index f5f0edf..c697e43 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,51 @@
+2014-03-20  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/60543
+	PR fortran/60283
+	* gfortran.dg/implicit_pure_4.f90: New.
+
+2014-03-17  Mikael Pettersson  <mikpelinux@gmail.com>
+	    Committed by Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline:
+
+	2013-06-16  Joern Rennecke <joern.rennecke@embecosm.com>
+
+	PR rtl-optimization/57425
+	PR rtl-optimization/57569
+	* gcc.dg/torture/pr57425-1.c, gcc.dg/torture/pr57425-2.c: New files.
+	* gcc.dg/torture/pr57425-3.c, gcc.dg/torture/pr57569.c: Likewise.
+
+2014-03-17  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-03-11  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/60429
+	PR tree-optimization/60485
+	* gcc.dg/pr60485-1.c: New testcase.
+	* gcc.dg/pr60485-2.c: Likewise.
+
+2014-03-15  Dominique d'Humieres  <dominiq@lps.ens.fr>
+
+	Backport from mainline
+	PR libfortran/60128
+	* gfortran.dg/fmt_en.f90: New test.
+
+2014-03-15  Jerry DeLisle  <jvdelisle@gcc.gnu>
+
+	Backport from mainline
+	PR libfortran/58324
+	* gfortran.dg/list_read_12.f90: New test.
+
+2014-03-13  Joey Ye  <joey.ye@arm.com>
+
+	Backport from mainline
+	2014-03-12  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR tree-optimization/60454
+	* gcc.c-torture/execute/pr60454.c: New test.
+
 2014-03-08  Janus Weil  <janus@gcc.gnu.org>
 
 	PR fortran/60450
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr60454.c b/gcc/testsuite/gcc.c-torture/execute/pr60454.c
new file mode 100644
index 0000000..ceec45e
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/execute/pr60454.c
@@ -0,0 +1,31 @@
+#ifdef __UINT32_TYPE__
+typedef __UINT32_TYPE__ uint32_t;
+#else
+typedef unsigned uint32_t;
+#endif
+
+#define __fake_const_swab32(x) ((uint32_t)(			      \
+        (((uint32_t)(x) & (uint32_t)0x000000ffUL) << 24) |            \
+        (((uint32_t)(x) & (uint32_t)0x0000ff00UL) <<  8) |            \
+        (((uint32_t)(x) & (uint32_t)0x000000ffUL) <<  8) |            \
+        (((uint32_t)(x) & (uint32_t)0x0000ff00UL)      ) |            \
+        (((uint32_t)(x) & (uint32_t)0xff000000UL) >> 24)))
+
+/* Previous version of bswap optimization would detect byte swap when none
+   happen. This test aims at catching such wrong detection to avoid
+   regressions.  */
+
+__attribute__ ((noinline, noclone)) uint32_t
+fake_swap32 (uint32_t in)
+{
+  return __fake_const_swab32 (in);
+}
+
+int main(void)
+{
+  if (sizeof (uint32_t) * __CHAR_BIT__ != 32)
+    return 0;
+  if (fake_swap32 (0x12345678UL) != 0x78567E12UL)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/pr60485-1.c b/gcc/testsuite/gcc.dg/pr60485-1.c
new file mode 100644
index 0000000..2e5c2e5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr60485-1.c
@@ -0,0 +1,29 @@
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+extern void abort (void);
+struct S {
+    int *i[4];
+    int *p1;
+    int *p2;
+    int *p3;
+    int *p4;
+};
+int **b;
+int main()
+{
+  int i = 1;
+  struct S s;
+  s.p3 = &i;
+  int **p;
+  if (b)
+    p = b;
+  else
+    p = &s.i[2];
+  p += 4;
+  if (!b)
+    **p = 0;
+  if (i != 0)
+    abort ();
+  return i;
+}
diff --git a/gcc/testsuite/gcc.dg/pr60485-2.c b/gcc/testsuite/gcc.dg/pr60485-2.c
new file mode 100644
index 0000000..767e61d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr60485-2.c
@@ -0,0 +1,38 @@
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+extern void abort (void);
+struct S {
+    int *i[4];
+    int *p1;
+    int *p2;
+    int *p3;
+    int *p4;
+    int **x;
+};
+int **b;
+int main()
+{
+  int i = 1;
+  struct S s;
+  s.p3 = &i;
+  int **p;
+  if (b)
+    p = b;
+  else
+    p = &s.i[2];
+  p += 4;
+  /* prevert fowrprop from creating an offsetted sd constraint and
+     preserve the pointer offsetting constraint.  */
+  s.x = p;
+  p = s.x;
+  if (!b)
+    {
+      int *z = *p;
+      /* z should point to i (and non-local/escaped).  */
+      *z = 0;
+    }
+  if (i != 0)
+    abort ();
+  return i;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr57425-1.c b/gcc/testsuite/gcc.dg/torture/pr57425-1.c
new file mode 100644
index 0000000..8ca85ca
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr57425-1.c
@@ -0,0 +1,37 @@
+/* { dg-do run } */
+
+extern void abort (void) __attribute__((noreturn));
+
+union setconflict
+{
+  int a[20];
+  long b[10];
+};
+
+int
+main ()
+{
+  int sum = 0;
+  {
+    union setconflict a;
+    int *c;
+    c = a.a;
+    asm ("": "=r" (c):"0" (c));
+    *c = 0;
+    asm ("": "=r" (c):"0" (c));
+    sum += *c;
+  }
+  {
+    union setconflict a;
+    long *c;
+    c = a.b;
+    asm ("": "=r" (c):"0" (c));
+    *c = 1;
+    asm ("": "=r" (c):"0" (c));
+    sum += *c;
+  }
+
+  if (sum != 1)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr57425-2.c b/gcc/testsuite/gcc.dg/torture/pr57425-2.c
new file mode 100644
index 0000000..ccb546e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr57425-2.c
@@ -0,0 +1,31 @@
+/* { dg-do run } */
+
+extern void abort (void) __attribute__((noreturn));
+
+int
+main ()
+{
+  int sum = 0;
+  {
+    int a[20];
+    int *c;
+    c = a;
+    asm ("": "=r" (c):"0" (c));
+    *c = 0;
+    asm ("": "=r" (c):"0" (c));
+    sum += *c;
+  }
+  {
+    long b[10];
+    long *c;
+    c = b;
+    asm ("": "=r" (c):"0" (c));
+    *c = 1;
+    asm ("": "=r" (c):"0" (c));
+    sum += *c;
+  }
+
+  if (sum != 1)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr57425-3.c b/gcc/testsuite/gcc.dg/torture/pr57425-3.c
new file mode 100644
index 0000000..8e0c7fe
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr57425-3.c
@@ -0,0 +1,31 @@
+/* { dg-do run } */
+
+extern void abort (void) __attribute__((noreturn));
+
+int
+main ()
+{
+  int sum = 0;
+  {
+    long a[20];
+    long *c;
+    c = a;
+    asm ("": "=r" (c):"0" (c));
+    *c = 0;
+    asm ("": "=r" (c):"0" (c));
+    sum += *c;
+  }
+  {
+    long long b[10];
+    long long *c;
+    c = b;
+    asm ("": "=r" (c):"0" (c));
+    *c = 1;
+    asm ("": "=r" (c):"0" (c));
+    sum += *c;
+  }
+
+  if (sum != 1)
+    abort();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/torture/pr57569.c b/gcc/testsuite/gcc.dg/torture/pr57569.c
new file mode 100644
index 0000000..f036d55
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/torture/pr57569.c
@@ -0,0 +1,37 @@
+/* { dg-do run } */
+
+extern void abort (void) __attribute__((noreturn));
+
+struct S { int f0; } a; 
+
+int b, e, *d = &b, f;
+
+void 
+fn1 ()
+{
+  int **g[9][6];
+  int ***h = &g[6][3];
+  for (; e < 9; e++) {
+    f = 0;
+    for (; f < 6; f++)
+      g[e][f] = &d;
+  }
+  ***h = 0;
+}
+
+void
+fn2 ()
+{
+  fn1 ();
+  struct S c[4][10] = {};
+  a = c[3][9];
+}
+
+int
+main ()
+{
+  fn2 ();
+  if (a.f0 != 0)
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gfortran.dg/fmt_en.f90 b/gcc/testsuite/gfortran.dg/fmt_en.f90
new file mode 100644
index 0000000..75d6040
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/fmt_en.f90
@@ -0,0 +1,141 @@
+! { dg-do run }
+! PR60128 Invalid outputs with EN descriptors
+! Test case provided by Walt Brainerd.
+program pr60128
+implicit none
+    integer :: n_tst = 0, n_cnt = 0
+
+! Original test.
+    call checkfmt("(en15.2)", -.44444,    "    -444.44E-03")
+
+! Test for the bug in comment 6.
+    call checkfmt("(en15.0)", 1.0,        "         1.E+00")
+    call checkfmt("(en15.0)", 1.00000012, "         1.E+00")
+    call checkfmt("(en15.0)", 0.99999994, "         1.E+00")
+    call checkfmt("(en15.0)", 10.0,       "        10.E+00")
+    call checkfmt("(en15.0)", 10.0000010, "        10.E+00")
+    call checkfmt("(en15.0)", 9.99999905, "        10.E+00")
+    call checkfmt("(en15.0)", 100.0,      "       100.E+00")
+    call checkfmt("(en15.0)", 100.000008, "       100.E+00")
+    call checkfmt("(en15.0)", 99.9999924, "       100.E+00")
+    call checkfmt("(en15.0)", 1000.0,     "         1.E+03")
+    call checkfmt("(en15.0)", 1000.00006, "         1.E+03")
+    call checkfmt("(en15.0)", 999.999939, "         1.E+03")
+    call checkfmt("(en15.0)", 9.5,        "        10.E+00")
+    call checkfmt("(en15.0)", 9.50000095, "        10.E+00")
+    call checkfmt("(en15.0)", 9.49999905, "         9.E+00")
+    call checkfmt("(en15.0)", 99.5,       "       100.E+00")
+    call checkfmt("(en15.0)", 99.5000076, "       100.E+00")
+    call checkfmt("(en15.0)", 99.4999924, "        99.E+00")
+    call checkfmt("(en15.0)", 999.5,      "         1.E+03")
+    call checkfmt("(en15.0)", 999.500061, "         1.E+03")
+    call checkfmt("(en15.0)", 999.499939, "       999.E+00")
+    call checkfmt("(en15.0)", 9500.0,     "        10.E+03")
+    call checkfmt("(en15.0)", 9500.00098, "        10.E+03")
+    call checkfmt("(en15.0)", 9499.99902, "         9.E+03")
+    call checkfmt("(en15.1)", 9950.0,     "       10.0E+03")
+    call checkfmt("(en15.2)", 9995.0,     "      10.00E+03")
+    call checkfmt("(en15.3)", 9999.5,     "     10.000E+03")
+    call checkfmt("(en15.1)", 9.5,        "        9.5E+00")
+    call checkfmt("(en15.1)", 9.50000095, "        9.5E+00")
+    call checkfmt("(en15.1)", 9.49999905, "        9.5E+00")
+    call checkfmt("(en15.1)", 0.099951,   "      100.0E-03")
+    call checkfmt("(en15.1)", 0.009951,   "       10.0E-03")
+    call checkfmt("(en15.1)", 0.000999951,"        1.0E-03")
+
+    call checkfmt("(en15.0)", -1.0,        "        -1.E+00")
+    call checkfmt("(en15.0)", -1.00000012, "        -1.E+00")
+    call checkfmt("(en15.0)", -0.99999994, "        -1.E+00")
+    call checkfmt("(en15.0)", -10.0,       "       -10.E+00")
+    call checkfmt("(en15.0)", -10.0000010, "       -10.E+00")
+    call checkfmt("(en15.0)", -9.99999905, "       -10.E+00")
+    call checkfmt("(en15.0)", -100.0,      "      -100.E+00")
+    call checkfmt("(en15.0)", -100.000008, "      -100.E+00")
+    call checkfmt("(en15.0)", -99.9999924, "      -100.E+00")
+    call checkfmt("(en15.0)", -1000.0,     "        -1.E+03")
+    call checkfmt("(en15.0)", -1000.00006, "        -1.E+03")
+    call checkfmt("(en15.0)", -999.999939, "        -1.E+03")
+    call checkfmt("(en15.0)", -9.5,        "       -10.E+00")
+    call checkfmt("(en15.0)", -9.50000095, "       -10.E+00")
+    call checkfmt("(en15.0)", -9.49999905, "        -9.E+00")
+    call checkfmt("(en15.0)", -99.5,       "      -100.E+00")
+    call checkfmt("(en15.0)", -99.5000076, "      -100.E+00")
+    call checkfmt("(en15.0)", -99.4999924, "       -99.E+00")
+    call checkfmt("(en15.0)", -999.5,      "        -1.E+03")
+    call checkfmt("(en15.0)", -999.500061, "        -1.E+03")
+    call checkfmt("(en15.0)", -999.499939, "      -999.E+00")
+    call checkfmt("(en15.0)", -9500.0,     "       -10.E+03")
+    call checkfmt("(en15.0)", -9500.00098, "       -10.E+03")
+    call checkfmt("(en15.0)", -9499.99902, "        -9.E+03")
+    call checkfmt("(en15.1)", -9950.0,     "      -10.0E+03")
+    call checkfmt("(en15.2)", -9995.0,     "     -10.00E+03")
+    call checkfmt("(en15.3)", -9999.5,     "    -10.000E+03")
+    call checkfmt("(en15.1)", -9.5,        "       -9.5E+00")
+    call checkfmt("(en15.1)", -9.50000095, "       -9.5E+00")
+    call checkfmt("(en15.1)", -9.49999905, "       -9.5E+00")
+    call checkfmt("(en15.1)", -0.099951,   "     -100.0E-03")
+    call checkfmt("(en15.1)", -0.009951,   "      -10.0E-03")
+    call checkfmt("(en15.1)", -0.000999951,"       -1.0E-03")
+
+    call checkfmt("(en15.1)", 987350.,     "      987.4E+03")
+    call checkfmt("(en15.2)", 98735.,      "      98.74E+03")
+    call checkfmt("(en15.3)", 9873.5,      "      9.874E+03")
+    call checkfmt("(en15.1)", 987650.,     "      987.6E+03")
+    call checkfmt("(en15.2)", 98765.,      "      98.76E+03")
+    call checkfmt("(en15.3)", 9876.5,      "      9.876E+03")
+    call checkfmt("(en15.1)", 3.125E-02,   "       31.2E-03")
+    call checkfmt("(en15.1)", 9.375E-02,   "       93.8E-03")
+    call checkfmt("(en15.2)", 1.5625E-02,  "      15.62E-03")
+    call checkfmt("(en15.2)", 4.6875E-02,  "      46.88E-03")
+    call checkfmt("(en15.3)", 7.8125E-03,  "      7.812E-03")
+    call checkfmt("(en15.3)", 2.34375E-02, "     23.438E-03")
+    call checkfmt("(en15.3)", 9.765625E-04,"    976.562E-06")
+    call checkfmt("(en15.6)", 2.9296875E-03,"   2.929688E-03")
+
+    call checkfmt("(en15.1)", -987350.,     "     -987.4E+03")
+    call checkfmt("(en15.2)", -98735.,      "     -98.74E+03")
+    call checkfmt("(en15.3)", -9873.5,      "     -9.874E+03")
+    call checkfmt("(en15.1)", -987650.,     "     -987.6E+03")
+    call checkfmt("(en15.2)", -98765.,      "     -98.76E+03")
+    call checkfmt("(en15.3)", -9876.5,      "     -9.876E+03")
+    call checkfmt("(en15.1)", -3.125E-02,   "      -31.2E-03")
+    call checkfmt("(en15.1)", -9.375E-02,   "      -93.8E-03")
+    call checkfmt("(en15.2)", -1.5625E-02,  "     -15.62E-03")
+    call checkfmt("(en15.2)", -4.6875E-02,  "     -46.88E-03")
+    call checkfmt("(en15.3)", -7.8125E-03,  "     -7.812E-03")
+    call checkfmt("(en15.3)", -2.34375E-02, "    -23.438E-03")
+    call checkfmt("(en15.3)", -9.765625E-04,"   -976.562E-06")
+    call checkfmt("(en15.6)", -2.9296875E-03,"  -2.929688E-03")
+
+    !print *, n_tst, n_cnt
+    if (n_cnt /= 0) call abort
+
+contains
+    subroutine checkfmt(fmt, x, cmp)
+        use ISO_FORTRAN_ENV
+        implicit none
+        integer, parameter :: j(size(real_kinds)+4)=[REAL_KINDS, [4, 4, 4, 4]]
+        integer :: i
+        character(len=*), intent(in) :: fmt
+        real, intent(in) :: x
+        character(len=*), intent(in) :: cmp
+        character(len=20) :: s
+        do i=1,size(real_kinds)
+          if (i == 1) then
+            write(s, fmt) real(x,kind=j(1))
+          else if (i == 2) then
+            write(s, fmt) real(x,kind=j(2))
+          else if (i == 3) then
+            write(s, fmt) real(x,kind=j(3))
+          else if (i == 4) then
+            write(s, fmt) real(x,kind=j(4))
+          end if
+          n_tst = n_tst + 1
+          if (s /= cmp) then
+             print "(a,1x,a,' expected: ',1x,a)", fmt, s, cmp
+             n_cnt = n_cnt + 1
+           end if
+        end do
+        
+    end subroutine
+end program
diff --git a/gcc/testsuite/gfortran.dg/implicit_pure_4.f90 b/gcc/testsuite/gfortran.dg/implicit_pure_4.f90
new file mode 100644
index 0000000..8563dd7
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/implicit_pure_4.f90
@@ -0,0 +1,22 @@
+! { dg-do compile }
+!
+! PR fortran/60543
+! PR fortran/60283
+!
+module m
+contains
+  REAL(8) FUNCTION random()
+    CALL RANDOM_NUMBER(random)
+  END FUNCTION random
+  REAL(8) FUNCTION random2()
+    block
+      block
+        block
+          CALL RANDOM_NUMBER(random2)
+        end block
+      end block
+    end block
+  END FUNCTION random2
+end module m
+
+! { dg-final { scan-module-absence "m" "IMPLICIT_PURE" } }
diff --git a/gcc/testsuite/gfortran.dg/list_read_12.f90 b/gcc/testsuite/gfortran.dg/list_read_12.f90
new file mode 100644
index 0000000..811ef15
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/list_read_12.f90
@@ -0,0 +1,11 @@
+! { dg-do run }
+! PR58324 Bogus end of file condition
+integer :: i, ios
+open(99, access='stream', form='unformatted')
+write(99) "5 a"
+close(99)
+
+open(99, access='sequential', form='formatted')
+read(99, *, iostat=ios) i
+if (ios /= 0) call abort
+end
diff --git a/gcc/tree-ssa-math-opts.c b/gcc/tree-ssa-math-opts.c
index 2140ced..508a240 100644
--- a/gcc/tree-ssa-math-opts.c
+++ b/gcc/tree-ssa-math-opts.c
@@ -1718,7 +1718,9 @@ struct symbolic_number {
 
   if (rhs_class == GIMPLE_BINARY_RHS)
     {
+      int i;
       struct symbolic_number n1, n2;
+      unsigned HOST_WIDEST_INT mask;
       tree source_expr2;
 
       if (code != BIT_IOR_EXPR)
@@ -1744,6 +1746,15 @@ struct symbolic_number {
 	    return NULL_TREE;
 
 	  n->size = n1.size;
+	  for (i = 0, mask = 0xff; i < n->size; i++, mask <<= BITS_PER_UNIT)
+	    {
+	      unsigned HOST_WIDEST_INT masked1, masked2;
+
+	      masked1 = n1.n & mask;
+	      masked2 = n2.n & mask;
+	      if (masked1 && masked2 && masked1 != masked2)
+		return NULL_TREE;
+	    }
 	  n->n = n1.n | n2.n;
 
 	  if (!verify_symbolic_number_p (n, stmt))
diff --git a/gcc/tree-ssa-structalias.c b/gcc/tree-ssa-structalias.c
index d4b1400..5461708 100644
--- a/gcc/tree-ssa-structalias.c
+++ b/gcc/tree-ssa-structalias.c
@@ -949,24 +949,27 @@ struct constraint_graph
 	bitmap_set_bit (result, i);
       else
 	{
-	  unsigned HOST_WIDE_INT fieldoffset = vi->offset + offset;
+	  HOST_WIDE_INT fieldoffset = vi->offset + offset;
+	  unsigned HOST_WIDE_INT size = vi->size;
 
 	  /* If the offset makes the pointer point to before the
 	     variable use offset zero for the field lookup.  */
-	  if (offset < 0
-	      && fieldoffset > vi->offset)
-	    fieldoffset = 0;
-
-	  if (offset != 0)
+	  if (fieldoffset < 0)
+	    vi = lookup_vi_for_tree (vi->decl);
+	  else
 	    vi = first_or_preceding_vi_for_offset (vi, fieldoffset);
 
-	  bitmap_set_bit (result, vi->id);
-	  /* If the result is not exactly at fieldoffset include the next
-	     field as well.  See get_constraint_for_ptr_offset for more
-	     rationale.  */
-	  if (vi->offset != fieldoffset
-	      && vi->next != NULL)
-	    bitmap_set_bit (result, vi->next->id);
+	  do
+	    {
+	      bitmap_set_bit (result, vi->id);
+	      if (!vi->next)
+		break;
+
+	      /* We have to include all fields that overlap the current field
+		 shifted by offset.  */
+	      vi = vi->next;
+	    }
+	  while (vi->offset < fieldoffset + size);
 	}
     }
 
@@ -1607,16 +1610,21 @@ struct topo_info
     {
       varinfo_t v = get_varinfo (j);
       HOST_WIDE_INT fieldoffset = v->offset + roffset;
+      unsigned HOST_WIDE_INT size = v->size;
       unsigned int t;
 
       if (v->is_full_var)
-	fieldoffset = v->offset;
+	;
       else if (roffset != 0)
-	v = first_vi_for_offset (v, fieldoffset);
-      /* If the access is outside of the variable we can ignore it.  */
-      if (!v)
-	continue;
+	{
+	  if (fieldoffset < 0)
+	    v = lookup_vi_for_tree (v->decl);
+	  else
+	    v = first_or_preceding_vi_for_offset (v, fieldoffset);
+	}
 
+      /* We have to include all fields that overlap the current field
+	 shifted by roffset.  */
       do
 	{
 	  t = find (v->id);
@@ -1633,16 +1641,13 @@ struct topo_info
 		   && add_graph_edge (graph, lhs, t))
 	    flag |= bitmap_ior_into (sol, get_varinfo (t)->solution);
 
-	  /* If the variable is not exactly at the requested offset
-	     we have to include the next one.  */
-	  if (v->offset == (unsigned HOST_WIDE_INT)fieldoffset
+	  if (v->is_full_var
 	      || v->next == NULL)
 	    break;
 
 	  v = v->next;
-	  fieldoffset = v->offset;
 	}
-      while (1);
+      while (v->offset < fieldoffset + size);
     }
 
 done:
@@ -1705,15 +1710,20 @@ struct topo_info
       varinfo_t v = get_varinfo (j);
       unsigned int t;
       HOST_WIDE_INT fieldoffset = v->offset + loff;
+      unsigned HOST_WIDE_INT size = v->size;
 
       if (v->is_full_var)
-	fieldoffset = v->offset;
+	;
       else if (loff != 0)
-	v = first_vi_for_offset (v, fieldoffset);
-      /* If the access is outside of the variable we can ignore it.  */
-      if (!v)
-	continue;
+	{
+	  if (fieldoffset < 0)
+	    v = lookup_vi_for_tree (v->decl);
+	  else
+	    v = first_or_preceding_vi_for_offset (v, fieldoffset);
+	}
 
+      /* We have to include all fields that overlap the current field
+	 shifted by loff.  */
       do
 	{
 	  if (v->may_have_pointers)
@@ -1739,16 +1749,13 @@ struct topo_info
 		bitmap_set_bit (changed, t);
 	    }
 
-	  /* If the variable is not exactly at the requested offset
-	     we have to include the next one.  */
-	  if (v->offset == (unsigned HOST_WIDE_INT)fieldoffset
+	  if (v->is_full_var
 	      || v->next == NULL)
 	    break;
 
 	  v = v->next;
-	  fieldoffset = v->offset;
 	}
-      while (1);
+      while (v->offset < fieldoffset + size);
     }
 }
 
@@ -2997,35 +3004,31 @@ struct topo_info
 	  varinfo_t temp;
 	  unsigned HOST_WIDE_INT offset = curr->offset + rhsoffset;
 
-	  /* Search the sub-field which overlaps with the
-	     pointed-to offset.  If the result is outside of the variable
-	     we have to provide a conservative result, as the variable is
-	     still reachable from the resulting pointer (even though it
-	     technically cannot point to anything).  The last and first
-	     sub-fields are such conservative results.
-	     ???  If we always had a sub-field for &object + 1 then
-	     we could represent this in a more precise way.  */
+	  /* If curr->offset + rhsoffset is less than zero adjust it.  */
 	  if (rhsoffset < 0
 	      && curr->offset < offset)
 	    offset = 0;
-	  temp = first_or_preceding_vi_for_offset (curr, offset);
 
-	  /* If the found variable is not exactly at the pointed to
-	     result, we have to include the next variable in the
-	     solution as well.  Otherwise two increments by offset / 2
-	     do not result in the same or a conservative superset
-	     solution.  */
-	  if (temp->offset != offset
-	      && temp->next != NULL)
+	  /* We have to include all fields that overlap the current
+	     field shifted by rhsoffset.  And we include at least
+	     the last or the first field of the variable to represent
+	     reachability of off-bound addresses, in particular &object + 1,
+	     conservatively correct.  */
+	  temp = first_or_preceding_vi_for_offset (curr, offset);
+	  temp = first_or_preceding_vi_for_offset (curr, offset);
+	  c.var = temp->id;
+	  c.offset = 0;
+	  temp = temp->next;
+	  while (temp
+		 && temp->offset < offset + curr->size)
 	    {
 	      struct constraint_expr c2;
-	      c2.var = temp->next->id;
+	      c2.var = temp->id;
 	      c2.type = ADDRESSOF;
 	      c2.offset = 0;
 	      results->safe_push (c2);
+	      temp = temp->next;
 	    }
-	  c.var = temp->id;
-	  c.offset = 0;
 	}
       else
 	c.offset = rhsoffset;
diff --git a/libgcc/ChangeLog b/libgcc/ChangeLog
index 6712a8d..e8a0745 100644
--- a/libgcc/ChangeLog
+++ b/libgcc/ChangeLog
@@ -1,3 +1,7 @@
+2014-03-20  Joel Sherrill  <joel.sherrill@oarcorp.com>
+
+	* config.host (v850*-*-*): Add to tmake_file instead of resetting it.
+
 2014-02-28  Joey Ye  <joey.ye@arm.com>
 
 	Backport from mainline r208229
diff --git a/libgcc/config.host b/libgcc/config.host
index 302aa61..4a76998 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -1085,7 +1085,7 @@ tilepro-*-linux*)
 	md_unwind_header=tilepro/linux-unwind.h
         ;;
 v850*-*-*)
-	tmake_file="v850/t-v850 t-fdpbit"
+	tmake_file="${tmake_file} v850/t-v850 t-fdpbit"
 	;;
 vax-*-linux*)
 	tmake_file="$tmake_file vax/t-linux"
diff --git a/libgfortran/ChangeLog b/libgfortran/ChangeLog
index fa07295..7721349 100644
--- a/libgfortran/ChangeLog
+++ b/libgfortran/ChangeLog
@@ -1,3 +1,29 @@
+2014-03-15  Dominique d'Humieres  <dominiq@lps.ens.fr>
+
+	Backport from mainline
+	PR libgfortran/60128
+	* io/write_float.def (output_float): Remove unused variable
+	nzero_real. Replace a double space with a single one.
+	(determine_en_precision): Fix wrong handling of the EN format.
+
+2014-03-15  Jerry DeLisle  <jvdelisle@gcc.gnu>
+
+	Backport from mainline
+	PR libfortran/58324
+	PR libfortran/38199
+	* io/list_read.c (finish_list_read): Read one character to check
+	for the end of the file.  If it is the end, then issue the file
+	end error message.  If not, use eat_line to reach the end
+	without giving error.  The next attempt to read will then
+	issue the error as described above.
+	* io/read.c (read_decimal): Quickly skip spaces to avoid calls
+	to next_char.
+	* io/unit.c (is_trim_ok): New helper function to check various
+	conditions to see if its OK to trim the internal unit string.
+	(get_internal_unit): Use LEN_TRIM to shorten selected internal
+	unit strings for optimizing READ. Enable this optimization for
+	formatted READ.
+
 2014-02-21  Jerry DeLisle  <jvdelisle@gcc.gnu>
 	    Dominique d'Humieres  <dominiq@lps.ens.fr>
 	    Steven G. Kargl  <kargl@gcc.gnu.org>
diff --git a/libgfortran/io/list_read.c b/libgfortran/io/list_read.c
index 7cafad0..91ef8b5 100644
--- a/libgfortran/io/list_read.c
+++ b/libgfortran/io/list_read.c
@@ -2034,8 +2034,6 @@ This file is part of the GNU Fortran runtime library (libgfortran).
 void
 finish_list_read (st_parameter_dt *dtp)
 {
-  int err;
-
   free_saved (dtp);
 
   fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);
@@ -2046,12 +2044,22 @@ This file is part of the GNU Fortran runtime library (libgfortran).
       return;
     }
 
-  err = eat_line (dtp);
-  if (err == LIBERROR_END)
+  if (!is_internal_unit (dtp))
     {
-      free_line (dtp);
-      hit_eof (dtp);
+      int c;
+      c = next_char (dtp);
+      if (c == EOF)
+	{
+	  free_line (dtp);
+	  hit_eof (dtp);
+	  return;
+	}
+      if (c != '\n')
+	eat_line (dtp);
     }
+
+  free_line (dtp);
+
 }
 
 /*			NAMELIST INPUT
diff --git a/libgfortran/io/read.c b/libgfortran/io/read.c
index 2da1048..f45e1b4 100644
--- a/libgfortran/io/read.c
+++ b/libgfortran/io/read.c
@@ -655,7 +655,13 @@ This file is part of the GNU Fortran runtime library (libgfortran).
 	
       if (c == ' ')
         {
-	  if (dtp->u.p.blank_status == BLANK_NULL) continue;
+	  if (dtp->u.p.blank_status == BLANK_NULL)
+	    {
+	      /* Skip spaces.  */
+	      for ( ; w > 0; p++, w--)
+		if (*p != ' ') break; 
+	      continue;
+	    }
 	  if (dtp->u.p.blank_status == BLANK_ZERO) c = '0';
         }
         
diff --git a/libgfortran/io/unit.c b/libgfortran/io/unit.c
index f8c1516..ab61769 100644
--- a/libgfortran/io/unit.c
+++ b/libgfortran/io/unit.c
@@ -29,6 +29,7 @@ This file is part of the GNU Fortran runtime library (libgfortran).
 #include "unix.h"
 #include <stdlib.h>
 #include <string.h>
+#include <stdbool.h>
 
 
 /* IO locking rules:
@@ -375,6 +376,38 @@ This file is part of the GNU Fortran runtime library (libgfortran).
 }
 
 
+/* Helper function to check rank, stride, format string, and namelist.
+   This is used for optimization. You can't trim out blanks or shorten
+   the string if trailing spaces are significant.  */
+static bool
+is_trim_ok (st_parameter_dt *dtp)
+{
+  /* Check rank and stride.  */
+  if (dtp->internal_unit_desc
+      && (GFC_DESCRIPTOR_RANK (dtp->internal_unit_desc) > 1
+	  || GFC_DESCRIPTOR_STRIDE(dtp->internal_unit_desc, 0) != 1))
+    return false;
+  /* Format strings can not have 'BZ' or '/'.  */
+  if (dtp->common.flags & IOPARM_DT_HAS_FORMAT)
+    {
+      char *p = dtp->format;
+      off_t i;
+      if (dtp->common.flags & IOPARM_DT_HAS_BLANK)
+	return false;
+      for (i = 0; i < dtp->format_len; i++)
+	{
+	  if (p[i] == '/') return false;
+	  if (p[i] == 'b' || p[i] == 'B')
+	    if (p[i+1] == 'z' || p[i+1] == 'Z')
+	      return false;
+	}
+    }
+  if (dtp->u.p.ionml) /* A namelist.  */
+    return false;
+  return true;
+}
+
+
 gfc_unit *
 get_internal_unit (st_parameter_dt *dtp)
 {
@@ -402,6 +435,22 @@ This file is part of the GNU Fortran runtime library (libgfortran).
      some other file I/O unit.  */
   iunit->unit_number = -1;
 
+  /* As an optimization, adjust the unit record length to not
+     include trailing blanks. This will not work under certain conditions
+     where trailing blanks have significance.  */
+  if (dtp->u.p.mode == READING && is_trim_ok (dtp))
+    {
+      int len;
+      if (dtp->common.unit == 0)
+	  len = string_len_trim (dtp->internal_unit_len,
+						   dtp->internal_unit);
+      else
+	  len = string_len_trim_char4 (dtp->internal_unit_len,
+			      (const gfc_char4_t*) dtp->internal_unit);
+      dtp->internal_unit_len = len; 
+      iunit->recl = dtp->internal_unit_len;
+    }
+
   /* Set up the looping specification from the array descriptor, if any.  */
 
   if (is_array_io (dtp))
@@ -414,27 +463,6 @@ This file is part of the GNU Fortran runtime library (libgfortran).
 
       start_record *= iunit->recl;
     }
-  else
-    {
-      /* If we are not processing an array, adjust the unit record length not
-	 to include trailing blanks for list-formatted reads.  */
-      if (dtp->u.p.mode == READING && !(dtp->common.flags & IOPARM_DT_HAS_FORMAT))
-	{
-	  if (dtp->common.unit == 0)
-	    {
-	      dtp->internal_unit_len =
-		string_len_trim (dtp->internal_unit_len, dtp->internal_unit);
-	      iunit->recl = dtp->internal_unit_len;
-	    }
-	  else
-	    {
-	      dtp->internal_unit_len =
-		string_len_trim_char4 (dtp->internal_unit_len,
-				       (const gfc_char4_t*) dtp->internal_unit);
-	      iunit->recl = dtp->internal_unit_len;
-	    }
-	}
-    }
 
   /* Set initial values for unit parameters.  */
   if (dtp->common.unit)
diff --git a/libgfortran/io/write_float.def b/libgfortran/io/write_float.def
index cfee29d..acfa125 100644
--- a/libgfortran/io/write_float.def
+++ b/libgfortran/io/write_float.def
@@ -125,8 +125,6 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,
   int nzero;
   /* Number of digits after the decimal point.  */
   int nafter;
-  /* Number of zeros after the decimal point, whatever the precision.  */
-  int nzero_real;
   int leadzero;
   int nblanks;
   int ndigits, edigits;
@@ -138,7 +136,6 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,
   p = dtp->u.p.scale_factor;
 
   rchar = '5';
-  nzero_real = -1;
 
   /* We should always know the field width and precision.  */
   if (d < 0)
@@ -191,7 +188,7 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,
 	      if (nafter < 0)
 		nafter = 0;
 	      nafter = d;
-	      nzero = nzero_real = 0;
+	      nzero = 0;
 	    }
 	  else /* p < 0  */
 	    {
@@ -211,14 +208,13 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,
 		  nafter = d + nbefore;
 		  nbefore = 0;
 		}
-	      nzero_real = nzero;
 	      if (nzero > d)
 		nzero = d;
 	    }
 	}
       else
 	{
-	  nzero = nzero_real = 0;
+	  nzero = 0;
 	  nafter = d;
 	}
 
@@ -373,7 +369,7 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,
   updown:
 
   rchar = '0';
-  if  (ft != FMT_F && w > 0 && d == 0 && p == 0)
+  if (ft != FMT_F && w > 0 && d == 0 && p == 0)
     nbefore = 1;
   /* Scan for trailing zeros to see if we really need to round it.  */
   for(i = nbefore + nafter; i < ndigits; i++)
@@ -1125,14 +1121,36 @@ OUTPUT_FLOAT_FMT_G(16,L)
 /* EN format is tricky since the number of significant digits depends
    on the magnitude.  Solve it by first printing a temporary value and
    figure out the number of significant digits from the printed
-   exponent.  */
+   exponent.  Values y, 0.95*10.0**e <= y <10.0**e, are rounded to
+   10.0**e even when the final result will not be rounded to 10.0**e.
+   For these values the exponent returned by atoi has to be decremented
+   by one. The values y in the ranges
+       (1000.0-0.5*10.0**(-d))*10.0**(3*n) <= y < 10.0*(3*(n+1))  
+        (100.0-0.5*10.0**(-d))*10.0**(3*n) <= y < 10.0*(3*n+2)
+         (10.0-0.5*10.0**(-d))*10.0**(3*n) <= y < 10.0*(3*n+1)
+   are correctly rounded respectively to 1.0...0*10.0*(3*(n+1)),
+   100.0...0*10.0*(3*n), and 10.0...0*10.0*(3*n), where 0...0
+   represents d zeroes, by the lines 279 to 297. */
 
 #define EN_PREC(x,y)\
 {\
-    GFC_REAL_ ## x tmp;				\
-    tmp = * (GFC_REAL_ ## x *)source;				\
+    volatile GFC_REAL_ ## x tmp, one = 1.0;\
+    tmp = * (GFC_REAL_ ## x *)source;\
     if (isfinite (tmp))						\
-      nprinted = DTOA(y,0,tmp);					\
+      {\
+	nprinted = DTOA(y,0,tmp);\
+	int e = atoi (&buffer[4]);\
+	if (buffer[1] == '1')\
+	  {\
+	    tmp = (calculate_exp_ ## x (-e)) * tmp;\
+	    tmp = one - (tmp < 0 ? -tmp : tmp);	\
+	    if (tmp > 0)\
+	      e = e - 1;\
+	  }\
+	nbefore = e%3;\
+	if (nbefore < 0)\
+	  nbefore = 3 + nbefore;\
+      }\
     else\
       nprinted = -1;\
 }\
@@ -1144,6 +1162,7 @@ determine_en_precision (st_parameter_dt *dtp, const fnode *f,
   int nprinted;
   char buffer[10];
   const size_t size = 10;
+  int nbefore; /* digits before decimal point - 1.  */
 
   switch (len)
     {
@@ -1176,16 +1195,6 @@ determine_en_precision (st_parameter_dt *dtp, const fnode *f,
   if (nprinted == -1)
     return -1;
 
-  int e = atoi (&buffer[5]);
-  int nbefore; /* digits before decimal point - 1.  */
-  if (e >= 0)
-    nbefore = e % 3;
-  else
-    {
-      nbefore = (-e) % 3;
-      if (nbefore != 0)
-	nbefore = 3 - nbefore;
-    }
   int prec = f->u.real.d + nbefore;
   if (dtp->u.p.current_unit->round_status != ROUND_UNSPECIFIED
       && dtp->u.p.current_unit->round_status != ROUND_PROCDEFINED)
diff --git a/libjava/ChangeLog b/libjava/ChangeLog
index 2701366..68f2897 100644
--- a/libjava/ChangeLog
+++ b/libjava/ChangeLog
@@ -1,3 +1,8 @@
+2014-03-11  Uros Bizjak  <ubizjak@gmail.com>
+
+	* java/lang/natObject.cc (_Jv_MonitorEnter): Add missing parenthesis
+	around comparison with (address | LOCKED) in JvAssert.
+
 2013-10-16  Release Manager
 
 	* GCC 4.8.2 released.
diff --git a/libjava/java/lang/natObject.cc b/libjava/java/lang/natObject.cc
index 87f2044..1a66640 100644
--- a/libjava/java/lang/natObject.cc
+++ b/libjava/java/lang/natObject.cc
@@ -929,7 +929,7 @@ struct hash_entry {
 	  // only be held by other threads waiting for conversion, and
 	  // they, like us, drop it quickly without blocking.
 	  _Jv_MutexLock(&(hl->si.mutex));
-	  JvAssert(he -> address == address | LOCKED );
+	  JvAssert(he -> address == (address | LOCKED));
 	  release_set(&(he -> address), (address | REQUEST_CONVERSION | HEAVY));
 				// release lock on he
 	  LOG(REQ_CONV, (address | REQUEST_CONVERSION | HEAVY), self);
@@ -961,7 +961,7 @@ struct hash_entry {
     }
   obj_addr_t was_heavy = (address & HEAVY);
   if ((address & LOCKED) ||
-      !compare_and_swap(&(he -> address), address, (address | LOCKED )))
+      !compare_and_swap(&(he -> address), address, address | LOCKED ))
     {
       wait_unlocked(he);
       goto retry;
diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index b6d9bcf..1b86ea4 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,3 +1,64 @@
+2014-03-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/60564
+	* include/std/future (__future_base::_Task_state<>): Change
+	constructors to template functions using perfect forwarding.
+	(__create_task_state): Use decayed type as stored task.
+	(packaged_task::packaged_task(_Fn&&)): Forward instead of moving.
+	* testsuite/30_threads/packaged_task/60564.cc: New.
+
+2014-03-12  Roland McGrath  <mcgrathr@google.com>
+	    Mark Seaborn  <mseaborn@google.com>
+
+	PR libstdc++/59392
+	* libsupc++/eh_call.cc (__cxa_call_unexpected): Call __do_catch with
+	the address of a null pointer, not with a null pointer to pointer.
+	Copy comment for this case from eh_personality.cc:__cxa_call_unexpected.
+	* testsuite/18_support/bad_exception/59392.cc: New file.
+
+2014-03-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline.
+	2014-01-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/59680
+	* src/c++11/thread.cc (__sleep_for): Fix call to ::sleep.
+
+2014-03-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline.
+	2014-01-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/59215
+	* include/bits/shared_ptr_base.h
+	(_Sp_counted_base<_S_atomic>::_M_add_ref_lock()): Use relaxed atomic
+	load.
+
+2014-03-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline.
+
+	2014-01-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/59738
+	* include/bits/stl_vector.h (vector<>::_M_move_assign): Restore
+	support for non-Movable types.
+
+	2014-01-08  Franois Dumont  <fdumont@gcc.gnu.org>
+
+	* include/bits/stl_vector.h (std::vector<>::_M_move_assign): Pass
+	*this allocator instance when building temporary vector instance
+	so that *this allocator does not get moved.
+	* testsuite/23_containers/vector/allocator/move.cc (test01): Add
+	check on a vector iterator.
+	* testsuite/23_containers/vector/allocator/move_assign.cc
+	(test02): Likewise.
+	(test03): New, test with a non-propagating allocator.
+
+	2013-11-15  Jonathan Wakely  <jwakely.gcc@gmail.com>
+
+	* testsuite/23_containers/vector/allocator/move.cc: New
+
 2014-01-27  Jason Merrill  <jason@redhat.com>
 
 	Core DR 475
diff --git a/libstdc++-v3/include/bits/shared_ptr_base.h b/libstdc++-v3/include/bits/shared_ptr_base.h
index 9dcefa2..e661b65 100644
--- a/libstdc++-v3/include/bits/shared_ptr_base.h
+++ b/libstdc++-v3/include/bits/shared_ptr_base.h
@@ -233,7 +233,7 @@ namespace std _GLIBCXX_VISIBILITY(default)
     _M_add_ref_lock()
     {
       // Perform lock-free add-if-not-zero operation.
-      _Atomic_word __count = _M_use_count;
+      _Atomic_word __count = _M_get_use_count();
       do
 	{
 	  if (__count == 0)
diff --git a/libstdc++-v3/include/bits/stl_vector.h b/libstdc++-v3/include/bits/stl_vector.h
index 69c6e27..14de461 100644
--- a/libstdc++-v3/include/bits/stl_vector.h
+++ b/libstdc++-v3/include/bits/stl_vector.h
@@ -1361,7 +1361,8 @@ namespace std _GLIBCXX_VISIBILITY(default)
       void
       _M_move_assign(vector&& __x, std::true_type) noexcept
       {
-	const vector __tmp(std::move(*this));
+	vector __tmp(get_allocator());
+	this->_M_impl._M_swap_data(__tmp._M_impl);
 	this->_M_impl._M_swap_data(__x._M_impl);
 	if (_Alloc_traits::_S_propagate_on_move_assign())
 	  std::__alloc_on_move(_M_get_Tp_allocator(),
diff --git a/libstdc++-v3/include/std/future b/libstdc++-v3/include/std/future
index 30100fe..00dc978 100644
--- a/libstdc++-v3/include/std/future
+++ b/libstdc++-v3/include/std/future
@@ -1261,9 +1261,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     struct __future_base::_Task_state<_Fn, _Alloc, _Res(_Args...)> final
     : __future_base::_Task_state_base<_Res(_Args...)>
     {
-      _Task_state(_Fn&& __fn, const _Alloc& __a)
-      : _Task_state_base<_Res(_Args...)>(__a), _M_impl(std::move(__fn), __a)
-      { }
+      template<typename _Fn2>
+	_Task_state(_Fn2&& __fn, const _Alloc& __a)
+	: _Task_state_base<_Res(_Args...)>(__a),
+	  _M_impl(std::forward<_Fn2>(__fn), __a)
+	{ }
 
     private:
       virtual void
@@ -1292,19 +1294,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       struct _Impl : _Alloc
       {
-	_Impl(_Fn&& __fn, const _Alloc& __a)
-	  : _Alloc(__a), _M_fn(std::move(__fn)) { }
+	template<typename _Fn2>
+	  _Impl(_Fn2&& __fn, const _Alloc& __a)
+	  : _Alloc(__a), _M_fn(std::forward<_Fn2>(__fn)) { }
 	_Fn _M_fn;
       } _M_impl;
     };
 
-    template<typename _Signature, typename _Fn, typename _Alloc>
-      static shared_ptr<__future_base::_Task_state_base<_Signature>>
-      __create_task_state(_Fn&& __fn, const _Alloc& __a)
-      {
-	typedef __future_base::_Task_state<_Fn, _Alloc, _Signature> _State;
-	return std::allocate_shared<_State>(__a, std::move(__fn), __a);
-      }
+  template<typename _Signature, typename _Fn, typename _Alloc>
+    static shared_ptr<__future_base::_Task_state_base<_Signature>>
+    __create_task_state(_Fn&& __fn, const _Alloc& __a)
+    {
+      typedef typename decay<_Fn>::type _Fn2;
+      typedef __future_base::_Task_state<_Fn2, _Alloc, _Signature> _State;
+      return std::allocate_shared<_State>(__a, std::forward<_Fn>(__fn), __a);
+    }
 
   template<typename _Fn, typename _Alloc, typename _Res, typename... _Args>
     shared_ptr<__future_base::_Task_state_base<_Res(_Args...)>>
@@ -1344,7 +1348,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	       __constrain_pkgdtask<packaged_task, _Fn>::__type>
 	explicit
 	packaged_task(_Fn&& __fn)
-	: packaged_task(allocator_arg, std::allocator<int>(), std::move(__fn))
+	: packaged_task(allocator_arg, std::allocator<int>(),
+			std::forward<_Fn>(__fn))
 	{ }
 
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
diff --git a/libstdc++-v3/libsupc++/eh_call.cc b/libstdc++-v3/libsupc++/eh_call.cc
index 18ba0db..0b3632e 100644
--- a/libstdc++-v3/libsupc++/eh_call.cc
+++ b/libstdc++-v3/libsupc++/eh_call.cc
@@ -104,14 +104,14 @@
   } end_catch_protect_obj;
 
 
-  __try 
-    { 
+  __try
+    {
       if (foreign_exception)
 	std::unexpected();
       else
 	__unexpected(unexpectedHandler);
     }
-  __catch(...) 
+  __catch(...)
     {
       /* See if the new exception matches the rtti list.  */
       if (foreign_exception)
@@ -140,15 +140,19 @@
 			       &new_ptr) != ctm_failed)
 	    __throw_exception_again;
 
-	  if (catch_type->__do_catch(&bad_exc, 0, 1))
+	  // If the exception spec allows std::bad_exception, throw that.
+	  // We don't have a thrown object to compare against, but since
+	  // bad_exception doesn't have virtual bases, that's OK; just pass NULL.
+	  void* obj = NULL;
+	  if (catch_type->__do_catch(&bad_exc, &obj, 1))
 	    bad_exception_allowed = true;
 	}
 
       // If the exception spec allows std::bad_exception, throw that.
-#ifdef __EXCEPTIONS  
+#ifdef __EXCEPTIONS
       if (bad_exception_allowed)
 	throw std::bad_exception();
-#endif   
+#endif
 
       // Otherwise, die.
       __terminate(terminateHandler);
diff --git a/libstdc++-v3/src/c++11/thread.cc b/libstdc++-v3/src/c++11/thread.cc
index 8d040a7..0351f19 100644
--- a/libstdc++-v3/src/c++11/thread.cc
+++ b/libstdc++-v3/src/c++11/thread.cc
@@ -183,7 +183,7 @@ namespace std _GLIBCXX_VISIBILITY(default)
         ::usleep(__us);
       }
 # else
-    ::sleep(__s.count() + (__ns >= 1000000));
+    ::sleep(__s.count() + (__ns.count() >= 1000000));
 # endif
 #elif defined(_GLIBCXX_HAVE_WIN32_SLEEP)
     unsigned long ms = __ns.count() / 1000000;
diff --git a/libstdc++-v3/testsuite/18_support/bad_exception/59392.cc b/libstdc++-v3/testsuite/18_support/bad_exception/59392.cc
new file mode 100644
index 0000000..c9b65a2
--- /dev/null
+++ b/libstdc++-v3/testsuite/18_support/bad_exception/59392.cc
@@ -0,0 +1,51 @@
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <exception>
+#include <cstdlib>
+
+class expected {};
+class unexpected {};
+class from_handler {};
+
+static void func_with_exception_spec() throw(expected)
+{
+  throw unexpected();
+}
+
+static void unexpected_handler()
+{
+  throw from_handler();
+}
+
+static void terminate_handler()
+{
+  exit(0);
+}
+
+// libstdc++/59392
+int main()
+{
+  std::set_unexpected(unexpected_handler);
+  std::set_terminate(terminate_handler);
+  try {
+    func_with_exception_spec();
+  } catch (expected&) {
+    abort();
+  }
+  abort();
+}
diff --git a/libstdc++-v3/testsuite/23_containers/vector/allocator/move.cc b/libstdc++-v3/testsuite/23_containers/vector/allocator/move.cc
new file mode 100644
index 0000000..7e62f1e
--- /dev/null
+++ b/libstdc++-v3/testsuite/23_containers/vector/allocator/move.cc
@@ -0,0 +1,59 @@
+// Copyright (C) 2013 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+
+#include <vector>
+#include <testsuite_hooks.h>
+#include <testsuite_allocator.h>
+
+struct T { int i; };
+
+using __gnu_test::uneq_allocator;
+
+void test01()
+{
+  bool test __attribute__((unused)) = true;
+  typedef uneq_allocator<T> alloc_type;
+  typedef std::vector<T, alloc_type> test_type;
+  test_type v1(alloc_type(1));
+  v1 = { T() };
+  auto it = v1.begin();
+  test_type v2(std::move(v1));
+  VERIFY(1 == v1.get_allocator().get_personality());
+  VERIFY(1 == v2.get_allocator().get_personality());
+  VERIFY( it == v2.begin() );
+}
+
+void test02()
+{
+  bool test __attribute__((unused)) = true;
+  typedef uneq_allocator<T> alloc_type;
+  typedef std::vector<T, alloc_type> test_type;
+  test_type v1(alloc_type(1));
+  v1 = { T() };
+  test_type v2(std::move(v1), alloc_type(2));
+  VERIFY(1 == v1.get_allocator().get_personality());
+  VERIFY(2 == v2.get_allocator().get_personality());
+}
+
+int main()
+{
+  test01();
+  test02();
+  return 0;
+}
diff --git a/libstdc++-v3/testsuite/23_containers/vector/allocator/move_assign.cc b/libstdc++-v3/testsuite/23_containers/vector/allocator/move_assign.cc
index 64795d3..42dec6d 100644
--- a/libstdc++-v3/testsuite/23_containers/vector/allocator/move_assign.cc
+++ b/libstdc++-v3/testsuite/23_containers/vector/allocator/move_assign.cc
@@ -46,16 +46,35 @@ void test02()
   typedef std::vector<T, alloc_type> test_type;
   test_type v1(alloc_type(1));
   v1.push_back(T());
+  auto it = v1.begin();
   test_type v2(alloc_type(2));
-  v2 = std::move(v1);
   v2.push_back(T());
+  v2 = std::move(v1);
+  VERIFY( it == v2.begin() );
   VERIFY(0 == v1.get_allocator().get_personality());
   VERIFY(1 == v2.get_allocator().get_personality());
 }
 
+void test03()
+{
+  bool test __attribute__((unused)) = true;
+  typedef propagating_allocator<T, false> alloc_type;
+  typedef std::vector<T, alloc_type> test_type;
+  test_type v1(alloc_type(1));
+  v1.push_back(T());
+  auto it = v1.begin();
+  test_type v2(alloc_type(1));
+  v2.push_back(T());
+  v2 = std::move(v1);
+  VERIFY( it == v2.begin() );
+  VERIFY(1 == v1.get_allocator().get_personality());
+  VERIFY(1 == v2.get_allocator().get_personality());
+}
+
 int main()
 {
   test01();
   test02();
+  test03();
   return 0;
 }
diff --git a/libstdc++-v3/testsuite/30_threads/packaged_task/60564.cc b/libstdc++-v3/testsuite/30_threads/packaged_task/60564.cc
new file mode 100644
index 0000000..956d506
--- /dev/null
+++ b/libstdc++-v3/testsuite/30_threads/packaged_task/60564.cc
@@ -0,0 +1,51 @@
+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-gnu* *-*-solaris* *-*-cygwin *-*-darwin* powerpc-ibm-aix* } }
+// { dg-options " -std=gnu++11 -pthread" { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-gnu* powerpc-ibm-aix* } }
+// { dg-options " -std=gnu++11 -pthreads" { target *-*-solaris* } }
+// { dg-options " -std=gnu++11 " { target *-*-cygwin *-*-darwin* } }
+// { dg-require-cstdint "" }
+// { dg-require-gthreads "" }
+// { dg-require-atomic-builtins "" }
+
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+
+#include <future>
+#include <testsuite_hooks.h>
+
+struct X
+{
+  X() = default;
+  X(const X&) = default;
+  X(X&& x) { x.moved = true; }
+
+  void operator()() const { }
+
+  bool moved = false;
+};
+
+void test01()
+{
+  X x;
+  std::packaged_task<void()> p(x);
+  VERIFY( !x.moved );
+}
+
+int main()
+{
+  test01();
+}
