From cd5d86fae6cfcfa48c84d2972ff0a6abbad9c034 Mon Sep 17 00:00:00 2001
From: nu774 <honeycomb77@gmail.com>
Date: Thu, 9 May 2013 03:36:14 +0900
Subject: [PATCH 49/66] mp3: enable packed main_data decoding in MP4

14496-3 suggests packing main_data of MP3 that is usually scatttered into
multiple frames due to bit reservoir.
However, after packing main_data into a access unit, bitrate index in the
MPEG audio frame header doesn't match with actual frame size.
In order to accept this, this patch removes unnecessary frame size checking
on mp3 decoder.
Also, mov demuxer was changed to use MP3 parser only on special cases
(QT MOV with specific sample description) to avoid re-packetizing.
---
 libavcodec/mpegaudiodec_template.c |  8 --------
 libavformat/mov.c                  | 10 +++++++++-
 2 files changed, 9 insertions(+), 9 deletions(-)

diff --git a/libavcodec/mpegaudiodec_template.c b/libavcodec/mpegaudiodec_template.c
index 1cc5ac4..e00f55c 100644
--- a/libavcodec/mpegaudiodec_template.c
+++ b/libavcodec/mpegaudiodec_template.c
@@ -1686,14 +1686,6 @@ static int decode_frame(AVCodecContext * avctx, void *data, int *got_frame_ptr,
     if (!avctx->bit_rate)
         avctx->bit_rate = s->bit_rate;
 
-    if (s->frame_size <= 0 || s->frame_size > buf_size) {
-        av_log(avctx, AV_LOG_ERROR, "incomplete frame\n");
-        return AVERROR_INVALIDDATA;
-    } else if (s->frame_size < buf_size) {
-        av_log(avctx, AV_LOG_DEBUG, "incorrect frame size - multiple frames in buffer?\n");
-        buf_size= s->frame_size;
-    }
-
     s->frame = data;
 
     ret = mp_decode_frame(s, NULL, buf, buf_size);
diff --git a/libavformat/mov.c b/libavformat/mov.c
index d79b59f..8c0f23f 100644
--- a/libavformat/mov.c
+++ b/libavformat/mov.c
@@ -1641,6 +1641,15 @@ static void mov_parse_stsd_audio(MOVContext *c, AVIOContext *pb,
                     ff_mov_get_lpcm_codec_id(st->codec->bits_per_coded_sample,
                                              flags);
         }
+        if (version == 0 || (version == 1 && sc->audio_cid != -2)) {
+            /* can't correctly handle variable sized packet as audio unit */
+            switch (st->codec->codec_id) {
+            case AV_CODEC_ID_MP2:
+            case AV_CODEC_ID_MP3:
+                st->need_parsing = AVSTREAM_PARSE_FULL;
+                break;
+            }
+        }
     }
 
     switch (st->codec->codec_id) {
@@ -1851,7 +1860,6 @@ static int mov_finalize_stsd_codec(MOVContext *c, AVIOContext *pb,
     case AV_CODEC_ID_MP3:
         /* force type after stsd for m1a hdlr */
         st->codec->codec_type = AVMEDIA_TYPE_AUDIO;
-        st->need_parsing      = AVSTREAM_PARSE_FULL;
         break;
     case AV_CODEC_ID_GSM:
     case AV_CODEC_ID_ADPCM_MS:
-- 
2.4.1

