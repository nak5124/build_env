From 25a882b5bbdef90600b18bff46e4468235b24958 Mon Sep 17 00:00:00 2001
From: Yuta NAKAI <nak5124@live.jp>
Date: Wed, 29 Apr 2015 11:08:42 +0900
Subject: [PATCH 4/9] Cleanup

---
 adler32.c                  | 196 ++++-------------
 arch/x86/crc_folding.c     |  69 +++---
 arch/x86/deflate_quick.c   |  48 ++--
 arch/x86/fill_window_sse.c |  34 +--
 arch/x86/x86.c             |   2 +-
 compress.c                 |  32 ++-
 configure                  |  10 +-
 crc32.c                    | 263 +++++-----------------
 crc32.h                    |   4 +-
 deflate.c                  | 532 +++++++++++++++++++++------------------------
 deflate.h                  | 167 +++++++-------
 deflate_medium.c           |   8 +-
 gzclose.c                  |  11 +-
 gzguts.h                   | 115 ++--------
 gzlib.c                    | 291 +++++++------------------
 gzread.c                   | 153 ++++++-------
 gzwrite.c                  | 129 ++++++-----
 infback.c                  | 169 +++++---------
 inffast.c                  | 170 ++++++---------
 inffast.h                  |   2 +-
 inflate.c                  | 501 ++++++++++++++----------------------------
 inflate.h                  |  48 ++--
 inftrees.c                 |  41 ++--
 inftrees.h                 |   6 +-
 match.c                    |  52 ++---
 match.h                    |   2 +-
 test/example.c             | 104 ++++-----
 trees.c                    | 411 ++++++++++------------------------
 trees.h                    |  10 +-
 uncompr.c                  |  17 +-
 zconf.h                    | 332 ++--------------------------
 zconf.h.in                 | 332 ++--------------------------
 zlib.h                     | 497 +++++++++++++++++++-----------------------
 zutil.c                    | 109 ++++++----
 zutil.h                    |  65 +-----
 35 files changed, 1662 insertions(+), 3270 deletions(-)

diff --git a/adler32.c b/adler32.c
index 0ac4cf3..3ff091f 100644
--- a/adler32.c
+++ b/adler32.c
@@ -5,188 +5,84 @@
 
 /* @(#) $Id$ */
 
-#include "zutil.h"
-
-#define local static
+#include <stddef.h>
+#include <stdint.h>
 
-local uLong adler32_combine_ (uLong adler1, uLong adler2, z_off64_t len2);
+#include "zutil.h"
 
 #define BASE 65521      /* largest prime smaller than 65536 */
+#define BASE_X2 131042  /* twice BASE */
 #define NMAX 5552
 /* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
 
-#define DO1(buf,i)  {adler += (buf)[i]; sum2 += adler;}
-#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
-#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
-#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
-#define DO16(buf)   DO8(buf,0); DO8(buf,8);
-
-/* use NO_DIVIDE if your processor does not do division in hardware --
-   try it both ways to see which is faster */
-#ifdef NO_DIVIDE
-/* note that this assumes BASE is 65521, where 65536 % 65521 == 15
-   (thank you to John Reiser for pointing this out) */
-#  define CHOP(a) \
-    do { \
-        unsigned long tmp = a >> 16; \
-        a &= 0xffffUL; \
-        a += (tmp << 4) - tmp; \
-    } while (0)
-#  define MOD28(a) \
-    do { \
-        CHOP(a); \
-        if (a >= BASE) a -= BASE; \
-    } while (0)
-#  define MOD(a) \
-    do { \
-        CHOP(a); \
-        MOD28(a); \
-    } while (0)
-#  define MOD63(a) \
-    do { /* this assumes a is not negative */ \
-        z_off64_t tmp = a >> 32; \
-        a &= 0xffffffffL; \
-        a += (tmp << 8) - (tmp << 5) + tmp; \
-        tmp = a >> 16; \
-        a &= 0xffffL; \
-        a += (tmp << 4) - tmp; \
-        tmp = a >> 16; \
-        a &= 0xffffL; \
-        a += (tmp << 4) - tmp; \
-        if (a >= BASE) a -= BASE; \
-    } while (0)
-#else
-#  define MOD(a) a %= BASE
-#  define MOD28(a) a %= BASE
-#  define MOD63(a) a %= BASE
-#endif
-
 /* ========================================================================= */
-uLong ZEXPORT adler32(adler, buf, len)
-    uLong adler;
-    const Byte *buf;
-    uInt len;
+unsigned long ZEXPORT adler32(unsigned long adler,
+                              const unsigned char *buf,
+                              unsigned int len)
 {
-    unsigned long sum2;
-    unsigned n;
+    /* initial Adler-32 value */
+    if (buf == NULL)
+        return UINT32_C(1) << 0 | UINT32_C(0) << 16;
 
     /* split Adler-32 into component sums */
-    sum2 = (adler >> 16) & 0xffff;
-    adler &= 0xffff;
-
-    /* in case user likes doing a byte at a time, keep it fast */
-    if (len == 1) {
-        adler += buf[0];
-        if (adler >= BASE)
-            adler -= BASE;
-        sum2 += adler;
-        if (sum2 >= BASE)
-            sum2 -= BASE;
-        return adler | (sum2 << 16);
-    }
-
-    /* initial Adler-32 value (deferred check for len == 1 speed) */
-    if (buf == Z_NULL)
-        return 1L;
-
-    /* in case short lengths are provided, keep it somewhat fast */
-    if (len < 16) {
-        while (len--) {
-            adler += *buf++;
-            sum2 += adler;
-        }
-        if (adler >= BASE)
-            adler -= BASE;
-        MOD28(sum2);            /* only added so many BASE's */
-        return adler | (sum2 << 16);
-    }
-
-    /* do length NMAX blocks -- requires just one modulo operation */
-    while (len >= NMAX) {
-        len -= NMAX;
-#ifndef ADLER32_UNROLL_LESS
-        n = NMAX / 16;          /* NMAX is divisible by 16 */
-#else
-        n = NMAX / 8;           /* NMAX is divisible by 8 */
-#endif
-        do {
-#ifndef ADLER32_UNROLL_LESS
-            DO16(buf);          /* 16 sums unrolled */
-            buf += 16;
-#else
-            DO8(buf,0);         /* 8 sums unrolled */
-            buf += 8;
-#endif
-        } while (--n);
-        MOD(adler);
-        MOD(sum2);
-    }
-
-    /* do remaining bytes (less than NMAX, still just one modulo) */
-    if (len) {                  /* avoid modulos if none remaining */
-#ifndef ADLER32_UNROLL_LESS
-        while (len >= 16) {
-            len -= 16;
-            DO16(buf);
-            buf += 16;
-#else
-        while (len >= 8) {
-            len -= 8;
-            DO8(buf, 0);
-            buf += 8;
-#endif
+    uint32_t a = adler >>  0 & 0xFFFF; /* (sum of all bytes) % BASE */
+    uint32_t b = adler >> 16 & 0xFFFF; /* (sum of all a) % BASE */
+
+    while (len) {
+        size_t i;
+        for (i = 0; i < len && i < NMAX; i++) {
+            a += buf[i];
+            b += a;
         }
-        while (len--) {
-            adler += *buf++;
-            sum2 += adler;
-        }
-        MOD(adler);
-        MOD(sum2);
+        a %= BASE;
+        b %= BASE;
+        buf += i;
+        len -= i;
     }
 
     /* return recombined sums */
-    return adler | (sum2 << 16);
+    return a << 0 | b << 16;
 }
 
 /* ========================================================================= */
-local uLong adler32_combine_(uLong adler1, uLong adler2, z_off64_t len2)
+static unsigned long adler32_combine_(unsigned long adler1,
+                                      unsigned long adler2,
+                                      off_t len2)
 {
-    unsigned long sum1;
-    unsigned long sum2;
-    unsigned rem;
-
     /* for negative len, return invalid adler32 as a clue for debugging */
     if (len2 < 0)
-        return 0xffffffffUL;
+        return UINT32_C(0xFFFF) << 0 | UINT32_C(0xFFFF) << 16;
 
     /* the derivation of this formula is left as an exercise for the reader */
-    MOD63(len2);                /* assumes len2 >= 0 */
-    rem = (unsigned)len2;
-    sum1 = adler1 & 0xffff;
-    sum2 = rem * sum1;
-    MOD(sum2);
-    sum1 += (adler2 & 0xffff) + BASE - 1;
-    sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;
+    uint32_t adler1_a = adler1 >>  0 & 0xFFFF;
+    uint32_t adler1_b = adler1 >> 16 & 0xFFFF;
+    uint32_t adler2_a = adler2 >>  0 & 0xFFFF;
+    uint32_t adler2_b = adler2 >> 16 & 0xFFFF;
+    uint32_t rem = len2 % BASE;
+    uint32_t sum1 = adler1_a;
+    uint32_t sum2 = (rem * sum1) % BASE;
+    sum1 += adler2_a + BASE - 1;
+    sum2 += adler1_b + adler2_b + BASE - rem;
+    /* sum1 %= BASE; */
     if (sum1 >= BASE) sum1 -= BASE;
     if (sum1 >= BASE) sum1 -= BASE;
-    if (sum2 >= (BASE << 1)) sum2 -= (BASE << 1);
+    /* sum2 %= BASE; */
+    if (sum2 >= BASE_X2) sum2 -= BASE_X2;
     if (sum2 >= BASE) sum2 -= BASE;
-    return sum1 | (sum2 << 16);
+    return sum1 << 0 | sum2 << 16;
 }
 
 /* ========================================================================= */
-uLong ZEXPORT adler32_combine(adler1, adler2, len2)
-    uLong adler1;
-    uLong adler2;
-    z_off_t len2;
+unsigned long ZEXPORT adler32_combine(unsigned long adler1,
+                                      unsigned long adler2,
+                                      off_t len2)
 {
     return adler32_combine_(adler1, adler2, len2);
 }
 
-uLong ZEXPORT adler32_combine64(adler1, adler2, len2)
-    uLong adler1;
-    uLong adler2;
-    z_off64_t len2;
+unsigned long ZEXPORT adler32_combine64(unsigned long adler1,
+                                        unsigned long adler2,
+                                        off_t len2)
 {
     return adler32_combine_(adler1, adler2, len2);
 }
diff --git a/arch/x86/crc_folding.c b/arch/x86/crc_folding.c
index 5a4e975..f033547 100644
--- a/arch/x86/crc_folding.c
+++ b/arch/x86/crc_folding.c
@@ -40,7 +40,7 @@
         _mm_storeu_si128((__m128i *)s->crc0 + 4, xmm_crc_part);\
     } while (0);
 
-ZLIB_INTERNAL void crc_fold_init(deflate_state *z_const s)
+ZLIB_INTERNAL void crc_fold_init(deflate_state *const s)
 {
     CRC_LOAD(s)
 
@@ -54,11 +54,11 @@ ZLIB_INTERNAL void crc_fold_init(deflate_state *z_const s)
     s->strm->adler = 0;
 }
 
-local void fold_1(deflate_state *z_const s,
-        __m128i *xmm_crc0, __m128i *xmm_crc1,
-        __m128i *xmm_crc2, __m128i *xmm_crc3)
+static void fold_1(deflate_state *const s,
+                   __m128i *xmm_crc0, __m128i *xmm_crc1,
+                   __m128i *xmm_crc2, __m128i *xmm_crc3)
 {
-    z_const __m128i xmm_fold4 = _mm_set_epi32(
+    const __m128i xmm_fold4 = _mm_set_epi32(
             0x00000001, 0x54442bd4,
             0x00000001, 0xc6e41596);
     
@@ -80,11 +80,11 @@ local void fold_1(deflate_state *z_const s,
     *xmm_crc3 = _mm_castps_si128(ps_res);
 }
 
-local void fold_2(deflate_state *z_const s,
-        __m128i *xmm_crc0, __m128i *xmm_crc1,
-        __m128i *xmm_crc2, __m128i *xmm_crc3)
+static void fold_2(deflate_state *const s,
+                   __m128i *xmm_crc0, __m128i *xmm_crc1,
+                   __m128i *xmm_crc2, __m128i *xmm_crc3)
 {
-    z_const __m128i xmm_fold4 = _mm_set_epi32(
+    const __m128i xmm_fold4 = _mm_set_epi32(
             0x00000001, 0x54442bd4,
             0x00000001, 0xc6e41596);
 
@@ -114,11 +114,11 @@ local void fold_2(deflate_state *z_const s,
     *xmm_crc3 = _mm_castps_si128(ps_res31);
 }
 
-local void fold_3(deflate_state *z_const s,
-        __m128i *xmm_crc0, __m128i *xmm_crc1,
-        __m128i *xmm_crc2, __m128i *xmm_crc3)
+static void fold_3(deflate_state *const s,
+                   __m128i *xmm_crc0, __m128i *xmm_crc1,
+                   __m128i *xmm_crc2, __m128i *xmm_crc3)
 {
-    z_const __m128i xmm_fold4 = _mm_set_epi32(
+    const __m128i xmm_fold4 = _mm_set_epi32(
             0x00000001, 0x54442bd4,
             0x00000001, 0xc6e41596);
 
@@ -154,11 +154,11 @@ local void fold_3(deflate_state *z_const s,
     *xmm_crc3 = _mm_castps_si128(ps_res32);
 }
 
-local void fold_4(deflate_state *z_const s,
-        __m128i *xmm_crc0, __m128i *xmm_crc1,
-        __m128i *xmm_crc2, __m128i *xmm_crc3)
+static void fold_4(deflate_state *const s,
+                   __m128i *xmm_crc0, __m128i *xmm_crc1,
+                   __m128i *xmm_crc2, __m128i *xmm_crc3)
 {
-    z_const __m128i xmm_fold4 = _mm_set_epi32(
+    const __m128i xmm_fold4 = _mm_set_epi32(
             0x00000001, 0x54442bd4,
             0x00000001, 0xc6e41596);
 
@@ -202,7 +202,7 @@ local void fold_4(deflate_state *z_const s,
     *xmm_crc3 = _mm_castps_si128(ps_res3);
 }
 
-local z_const unsigned __attribute__((aligned(32))) pshufb_shf_table[60] = {
+static const unsigned int __attribute__((aligned(32))) pshufb_shf_table[60] = {
 	0x84838281,0x88878685,0x8c8b8a89,0x008f8e8d, /* shl 15 (16 - 1)/shr1 */
 	0x85848382,0x89888786,0x8d8c8b8a,0x01008f8e, /* shl 14 (16 - 3)/shr2 */
 	0x86858483,0x8a898887,0x8e8d8c8b,0x0201008f, /* shl 13 (16 - 4)/shr3 */
@@ -220,16 +220,17 @@ local z_const unsigned __attribute__((aligned(32))) pshufb_shf_table[60] = {
 	0x0201008f,0x06050403,0x0a090807,0x0e0d0c0b  /* shl  1 (16 -15)/shr15*/
 };
 
-local void partial_fold(deflate_state *z_const s, z_const size_t len,
-        __m128i *xmm_crc0, __m128i *xmm_crc1,
-        __m128i *xmm_crc2, __m128i *xmm_crc3,
-        __m128i *xmm_crc_part)
+static void partial_fold(deflate_state *const s,
+                         const size_t len,
+                         __m128i *xmm_crc0, __m128i *xmm_crc1,
+                         __m128i *xmm_crc2, __m128i *xmm_crc3,
+                         __m128i *xmm_crc_part)
 {
 
-    z_const __m128i xmm_fold4 = _mm_set_epi32(
+    const __m128i xmm_fold4 = _mm_set_epi32(
             0x00000001, 0x54442bd4,
             0x00000001, 0xc6e41596);
-    z_const __m128i xmm_mask3 = _mm_set1_epi32(0x80808080);
+    const __m128i xmm_mask3 = _mm_set1_epi32(0x80808080);
     
     __m128i xmm_shl, xmm_shr, xmm_tmp1, xmm_tmp2, xmm_tmp3;
     __m128i xmm_a0_0, xmm_a0_1;
@@ -270,8 +271,10 @@ local void partial_fold(deflate_state *z_const s, z_const size_t len,
     *xmm_crc3 = _mm_castps_si128(ps_res);
 }
 
-ZLIB_INTERNAL void crc_fold_copy(deflate_state *z_const s,
-        unsigned char *dst, z_const unsigned char *src, long len)
+ZLIB_INTERNAL void crc_fold_copy(deflate_state *const s,
+                                 unsigned char *dst,
+                                 const unsigned char *src,
+                                 long len)
 {
     unsigned long algn_diff;
     __m128i xmm_t0, xmm_t1, xmm_t2, xmm_t3;
@@ -395,7 +398,7 @@ done:
     CRC_SAVE(s)
 }
 
-local z_const unsigned __attribute__((aligned(16))) crc_k[] = {
+static const unsigned int __attribute__((aligned(16))) crc_k[] = {
     0xccaa009e, 0x00000000, /* rk1 */
     0x751997d0, 0x00000001, /* rk2 */
     0xccaa009e, 0x00000000, /* rk5 */
@@ -404,20 +407,20 @@ local z_const unsigned __attribute__((aligned(16))) crc_k[] = {
     0xdb710640, 0x00000001  /* rk8 */
 };
 
-local z_const unsigned __attribute__((aligned(16))) crc_mask[4] = {
+static const unsigned int __attribute__((aligned(16))) crc_mask[4] = {
     0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0x00000000
 };
 
-local z_const unsigned __attribute__((aligned(16))) crc_mask2[4] = {
+static const unsigned int __attribute__((aligned(16))) crc_mask2[4] = {
     0x00000000, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF
 };
 
-unsigned ZLIB_INTERNAL crc_fold_512to32(deflate_state *z_const s)
+unsigned ZLIB_INTERNAL crc_fold_512to32(deflate_state *const s)
 {
-    z_const __m128i xmm_mask  = _mm_load_si128((__m128i *)crc_mask);
-    z_const __m128i xmm_mask2 = _mm_load_si128((__m128i *)crc_mask2);
+    const __m128i xmm_mask  = _mm_load_si128((__m128i *)crc_mask);
+    const __m128i xmm_mask2 = _mm_load_si128((__m128i *)crc_mask2);
 
-    unsigned crc;
+    unsigned int crc;
     __m128i x_tmp0, x_tmp1, x_tmp2, crc_fold;
 
     CRC_LOAD(s)
diff --git a/arch/x86/deflate_quick.c b/arch/x86/deflate_quick.c
index 1459a1b..e612f35 100644
--- a/arch/x86/deflate_quick.c
+++ b/arch/x86/deflate_quick.c
@@ -19,8 +19,8 @@
 extern void fill_window_sse(deflate_state *s);
 extern void flush_pending  (z_stream *strm);
 
-local inline long compare258(z_const unsigned char *z_const src0,
-        z_const unsigned char *z_const src1)
+static inline long compare258(const unsigned char *const src0,
+                              const unsigned char *const src1)
 {
     intptr_t ax, dx, cx;
     __m128i xmm_src0;
@@ -73,13 +73,14 @@ local inline long compare258(z_const unsigned char *z_const src0,
     return ax - 16;
 }
 
-local z_const unsigned quick_len_codes[MAX_MATCH-MIN_MATCH+1];
-local z_const unsigned quick_dist_codes[8192];
+static const unsigned int quick_len_codes[MAX_MATCH-MIN_MATCH+1];
+static const unsigned int quick_dist_codes[8192];
 
-local inline void quick_send_bits(deflate_state *z_const s, z_const int value,
-        z_const int length)
+static inline void quick_send_bits(deflate_state *const s,
+                                   const int value,
+                                   const int length)
 {
-    unsigned code, out, w, b;
+    unsigned int code, out, w, b;
 
     out = s->bi_buf;
     w = s->bi_valid;
@@ -91,7 +92,7 @@ local inline void quick_send_bits(deflate_state *z_const s, z_const int value,
     if (s->pending + 4 >= s->pending_buf_size)
         flush_pending(s->strm);
 
-    *(unsigned *)(s->pending_buf + s->pending) = out;
+    *(unsigned int *)(s->pending_buf + s->pending) = out;
 
     b = w >> 3;
     s->pending += b;
@@ -99,10 +100,11 @@ local inline void quick_send_bits(deflate_state *z_const s, z_const int value,
     s->bi_valid = w - (b << 3);
 }
 
-local inline void static_emit_ptr(deflate_state *z_const s, z_const int lc,
-        z_const unsigned dist)
+static inline void static_emit_ptr(deflate_state *const s,
+                                   const int lc,
+                                   const unsigned int dist)
 {
-    unsigned code, len;
+    unsigned int code, len;
 
     code = quick_len_codes[lc] >> 8;
     len =  quick_len_codes[lc] & 0xFF;
@@ -113,26 +115,26 @@ local inline void static_emit_ptr(deflate_state *z_const s, z_const int lc,
     quick_send_bits(s, code, len);
 }
 
-z_const ct_data static_ltree[L_CODES+2];
+const ct_data static_ltree[L_CODES+2];
 
-local inline void static_emit_lit(deflate_state *z_const s,z_const int lit)
+static inline void static_emit_lit(deflate_state *const s, const int lit)
 {
     quick_send_bits(s, static_ltree[lit].Code, static_ltree[lit].Len);
     Tracecv(isgraph(lit), (stderr," '%c' ", lit));
 }
 
-local void static_emit_tree(deflate_state *z_const s,
-        z_const int flush)
+static void static_emit_tree(deflate_state *const s,
+                             const int flush)
 {
-    unsigned last;
+    unsigned int last;
 
     last = flush == Z_FINISH ? 1 : 0;
     send_bits(s, (STATIC_TREES<<1)+ last, 3);
 }
 
 
-local void static_emit_end_block(deflate_state *z_const s,
-        int last)
+static void static_emit_end_block(deflate_state *const s,
+                                  int last)
 {
     send_code(s, END_BLOCK, static_ltree);
 
@@ -143,10 +145,10 @@ local void static_emit_end_block(deflate_state *z_const s,
     flush_pending(s->strm);
 }
 
-local inline Pos quick_insert_string(deflate_state *z_const s, z_const Pos str)
+static inline Pos quick_insert_string(deflate_state *const s, const Pos str)
 {
     Pos ret;
-    unsigned h = 0;
+    unsigned int h = 0;
 
     __asm__ __volatile__ (
         "crc32l (%[window], %[str], 1), %0\n\t"
@@ -163,7 +165,7 @@ local inline Pos quick_insert_string(deflate_state *z_const s, z_const Pos str)
 ZLIB_INTERNAL block_state deflate_quick(deflate_state *s, int flush)
 {
     IPos hash_head;
-    unsigned dist, match_len;
+    unsigned int dist, match_len;
 
     static_emit_tree(s, flush);
 
@@ -218,7 +220,7 @@ ZLIB_INTERNAL block_state deflate_quick(deflate_state *s, int flush)
     return block_done;
 }
 
-local z_const unsigned quick_len_codes[MAX_MATCH-MIN_MATCH+1] = {
+static const unsigned int quick_len_codes[MAX_MATCH-MIN_MATCH+1] = {
 	0x00004007, 0x00002007, 0x00006007, 0x00001007, 
 	0x00005007, 0x00003007, 0x00007007, 0x00000807, 
 	0x00004808, 0x0000c808, 0x00002808, 0x0000a808, 
@@ -285,7 +287,7 @@ local z_const unsigned quick_len_codes[MAX_MATCH-MIN_MATCH+1] = {
 	0x001c230d, 0x001d230d, 0x001e230d, 0x0000a308, 
 };
 
-local z_const unsigned quick_dist_codes[8192] = {
+static const unsigned int quick_dist_codes[8192] = {
 	0x00000005, 0x00001005, 0x00000805, 0x00001805, 
 	0x00000406, 0x00002406, 0x00001406, 0x00003406, 
 	0x00000c07, 0x00002c07, 0x00004c07, 0x00006c07, 
diff --git a/arch/x86/fill_window_sse.c b/arch/x86/fill_window_sse.c
index 9b1781c..31a8a28 100644
--- a/arch/x86/fill_window_sse.c
+++ b/arch/x86/fill_window_sse.c
@@ -13,28 +13,28 @@
 #include <immintrin.h>
 #include "deflate.h"
 
-extern int read_buf        (z_stream *strm, Byte *buf, unsigned size);
+extern int read_buf        (z_stream *strm, unsigned char *buf, unsigned int size);
 
 ZLIB_INTERNAL void fill_window_sse(deflate_state *s)
 {
-    z_const __m128i xmm_wsize = _mm_set1_epi16(s->w_size);
+    const __m128i xmm_wsize = _mm_set1_epi16(s->w_size);
 
-    register unsigned n;
-    register Pos *p;
-    unsigned more;    /* Amount of free space at the end of the window. */
-    uInt wsize = s->w_size;
+    unsigned int n;
+    Pos *p;
+    unsigned int more;    /* Amount of free space at the end of the window. */
+    unsigned int wsize = s->w_size;
 
     Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
 
     do {
-        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
+        more = (unsigned int)(s->window_size -(unsigned long)s->lookahead -(unsigned long)s->strstart);
 
         /* Deal with !@#$% 64K limit: */
         if (sizeof(int) <= 2) {
             if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
                 more = wsize;
 
-            } else if (more == (unsigned)(-1)) {
+            } else if (more == (unsigned int)(-1)) {
                 /* Very unlikely, but possible on 16 bit machine if
                  * strstart == 0 && lookahead == 1 (input done a byte at time)
                  */
@@ -47,7 +47,7 @@ ZLIB_INTERNAL void fill_window_sse(deflate_state *s)
          */
         if (s->strstart >= wsize+MAX_DIST(s)) {
 
-            memcpy(s->window, s->window+wsize, (unsigned)wsize);
+            memcpy(s->window, s->window+wsize, (unsigned int)wsize);
             s->match_start -= wsize;
             s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
             s->block_start -= (long) wsize;
@@ -107,7 +107,7 @@ ZLIB_INTERNAL void fill_window_sse(deflate_state *s)
 
         /* Initialize the hash value now that we have some input: */
         if (s->lookahead + s->insert >= MIN_MATCH) {
-            uInt str = s->strstart - s->insert;
+            unsigned int str = s->strstart - s->insert;
             s->ins_h = s->window[str];
             if (str >= 1)
                 UPDATE_HASH(s, s->ins_h, str + 1 - (MIN_MATCH-1));
@@ -138,8 +138,8 @@ ZLIB_INTERNAL void fill_window_sse(deflate_state *s)
      * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
      */
     if (s->high_water < s->window_size) {
-        ulg curr = s->strstart + (ulg)(s->lookahead);
-        ulg init;
+        unsigned long curr = s->strstart + (unsigned long)(s->lookahead);
+        unsigned long init;
 
         if (s->high_water < curr) {
             /* Previous high water mark below current data -- zero WIN_INIT
@@ -148,23 +148,23 @@ ZLIB_INTERNAL void fill_window_sse(deflate_state *s)
             init = s->window_size - curr;
             if (init > WIN_INIT)
                 init = WIN_INIT;
-            memset(s->window + curr, 0, (unsigned)init);
+            memset(s->window + curr, 0, (unsigned int)init);
             s->high_water = curr + init;
         }
-        else if (s->high_water < (ulg)curr + WIN_INIT) {
+        else if (s->high_water < (unsigned long)curr + WIN_INIT) {
             /* High water mark at or above current data, but below current data
              * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
              * to end of window, whichever is less.
              */
-            init = (ulg)curr + WIN_INIT - s->high_water;
+            init = (unsigned long)curr + WIN_INIT - s->high_water;
             if (init > s->window_size - s->high_water)
                 init = s->window_size - s->high_water;
-            memset(s->window + s->high_water, 0, (unsigned)init);
+            memset(s->window + s->high_water, 0, (unsigned int)init);
             s->high_water += init;
         }
     }
 
-    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
+    Assert((unsigned long)s->strstart <= s->window_size - MIN_LOOKAHEAD,
            "not enough room for search");
 }
 #endif
diff --git a/arch/x86/x86.c b/arch/x86/x86.c
index 9efe455..5ee8877 100644
--- a/arch/x86/x86.c
+++ b/arch/x86/x86.c
@@ -16,7 +16,7 @@ ZLIB_INTERNAL int x86_cpu_has_pclmulqdq;
 
 void ZLIB_INTERNAL x86_check_features(void)
 {
-    unsigned eax, ebx, ecx, edx;
+    unsigned int eax, ebx, ecx, edx;
 
     eax = 1;
     __asm__ __volatile__ (
diff --git a/compress.c b/compress.c
index ba29677..ce058a7 100644
--- a/compress.c
+++ b/compress.c
@@ -19,21 +19,21 @@
    memory, Z_BUF_ERROR if there was not enough room in the output buffer,
    Z_STREAM_ERROR if the level parameter is invalid.
 */
-int ZEXPORT compress2 (dest, destLen, source, sourceLen, level)
-    Byte *dest;
-    uLong *destLen;
-    const Byte *source;
-    uLong sourceLen;
-    int level;
+int ZEXPORT compress2(unsigned char *dest,
+                      unsigned long *destLen,
+                      const unsigned char *source,
+                      unsigned long sourceLen,
+                      int level)
 {
     z_stream stream;
     int err;
 
-    stream.next_in = (z_const Byte *)source;
-    stream.avail_in = (uInt)sourceLen;
+    stream.next_in = (const unsigned char *)source;
+    stream.avail_in = (unsigned int)sourceLen;
+    if ((unsigned long)stream.avail_in != sourceLen) return Z_BUF_ERROR;
     stream.next_out = dest;
-    stream.avail_out = (uInt)*destLen;
-    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
+    stream.avail_out = (unsigned int)*destLen;
+    if ((unsigned long)stream.avail_out != *destLen) return Z_BUF_ERROR;
 
     stream.zalloc = (alloc_func)0;
     stream.zfree = (free_func)0;
@@ -55,11 +55,10 @@ int ZEXPORT compress2 (dest, destLen, source, sourceLen, level)
 
 /* ===========================================================================
  */
-int ZEXPORT compress (dest, destLen, source, sourceLen)
-    Byte *dest;
-    uLong *destLen;
-    const Byte *source;
-    uLong sourceLen;
+int ZEXPORT compress(unsigned char *dest,
+                     unsigned long *destLen,
+                     const unsigned char *source,
+                     unsigned long sourceLen)
 {
     return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);
 }
@@ -68,8 +67,7 @@ int ZEXPORT compress (dest, destLen, source, sourceLen)
      If the default memLevel or windowBits for deflateInit() is changed, then
    this function needs to be updated.
  */
-uLong ZEXPORT compressBound (sourceLen)
-    uLong sourceLen;
+unsigned long ZEXPORT compressBound(unsigned long sourceLen)
 {
     return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
            (sourceLen >> 25) + 13;
diff --git a/configure b/configure
index d063517..43ca05c 100755
--- a/configure
+++ b/configure
@@ -227,7 +227,7 @@ if test "$gcc" -eq 1 && ($cc -c $test.c) >> configure.log 2>&1; then
 		LDSHAREDLIBC=''
         EXE='.exe' ;;
   MINGW* | mingw*)
-        CFLAGS="${CFLAGS} -D_FILE_OFFSET_BITS=64"
+        CFLAGS="${CFLAGS} -D_FILE_OFFSET_BITS=64 -D_GNU_SOURCE=1"
         SFLAGS="${CFLAGS}"
         LDFLAGS="-L. ${old_ldflags}"
         shared_ext=".dll"
@@ -646,8 +646,8 @@ case "${ARCH}" in
             ;;
         esac
 
-        CFLAGS="${CFLAGS} -DUNALIGNED_OK -DADLER32_UNROLL_LESS -DCRC32_UNROLL_LESS -DX86_CPUID"
-        SFLAGS="${SFLAGS} -DUNALIGNED_OK -DADLER32_UNROLL_LESS -DCRC32_UNROLL_LESS -DX86_CPUID"
+        CFLAGS="${CFLAGS} -DUNALIGNED_OK -DCRC32_UNROLL_LESS -DX86_CPUID"
+        SFLAGS="${SFLAGS} -DUNALIGNED_OK -DCRC32_UNROLL_LESS -DX86_CPUID"
 
 	# Enable arch-specific optimizations?
 	if test $without_optimizations -eq 0; then
@@ -691,8 +691,8 @@ case "${ARCH}" in
             armv6l | armv6hl)
                 # Tests done on Raspberry pi (armv6hl) indicate that UNALIGNED_OK and CRC32_UNROLL_LESS both
                 # provide performance improvements, totaling about 1.5% for the two.
-                CFLAGS="${CFLAGS} -DUNALIGNED_OK -DADLER32_UNROLL_LESS -DCRC32_UNROLL_LESS"
-                SFLAGS="${SFLAGS} -DUNALIGNED_OK -DADLER32_UNROLL_LESS -DCRC32_UNROLL_LESS"
+                CFLAGS="${CFLAGS} -DUNALIGNED_OK -DCRC32_UNROLL_LESS"
+                SFLAGS="${SFLAGS} -DUNALIGNED_OK -DCRC32_UNROLL_LESS"
             ;;
         esac
 
diff --git a/crc32.c b/crc32.c
index 595a4a6..cc66044 100644
--- a/crc32.c
+++ b/crc32.c
@@ -11,183 +11,39 @@
 
 /* @(#) $Id$ */
 
-/*
-  Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore
-  protection on the static variables used to control the first-use generation
-  of the crc tables.  Therefore, if you #define DYNAMIC_CRC_TABLE, you should
-  first call get_crc_table() to initialize the tables before allowing more than
-  one thread to use crc32().
-
-  DYNAMIC_CRC_TABLE and MAKECRCH can be #defined to write out crc32.h.
- */
-
-#ifdef MAKECRCH
-#  include <stdio.h>
-#  ifndef DYNAMIC_CRC_TABLE
-#    define DYNAMIC_CRC_TABLE
-#  endif /* !DYNAMIC_CRC_TABLE */
-#endif /* MAKECRCH */
+#ifdef __MINGW32__
+#include <sys/param.h>
+#else
+#include <endian.h>
+#endif
+#include <stdint.h>
 
 #include "zutil.h"
 
-#define local static
-
 /* Definitions for doing the crc four data bytes at a time. */
-#if !defined(NOBYFOUR) && defined(Z_U4)
-#  define BYFOUR
+#if BYTE_ORDER == LITTLE_ENDIAN
+static unsigned long crc32_little(unsigned long, const unsigned char *, unsigned int);
 #endif
-#ifdef BYFOUR
-   local unsigned long crc32_little (unsigned long, const unsigned char *, unsigned);
-   local unsigned long crc32_big (unsigned long, const unsigned char *, unsigned);
-#  define TBLS 8
-#else
-#  define TBLS 1
-#endif /* BYFOUR */
+#if BYTE_ORDER == BIG_ENDIAN
+static unsigned long crc32_big(unsigned long, const unsigned char *, unsigned int);
+#endif
+#define TBLS 8
 
 /* Local functions for crc concatenation */
-local unsigned long gf2_matrix_times (unsigned long *mat, unsigned long vec);
-local void gf2_matrix_square (unsigned long *square, unsigned long *mat);
-local uLong crc32_combine_ (uLong crc1, uLong crc2, z_off64_t len2);
-
-
-#ifdef DYNAMIC_CRC_TABLE
-
-local volatile int crc_table_empty = 1;
-local z_crc_t crc_table[TBLS][256];
-local void make_crc_table (void);
-#ifdef MAKECRCH
-   local void write_table (FILE *, const z_crc_t *);
-#endif /* MAKECRCH */
-/*
-  Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:
-  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
-
-  Polynomials over GF(2) are represented in binary, one bit per coefficient,
-  with the lowest powers in the most significant bit.  Then adding polynomials
-  is just exclusive-or, and multiplying a polynomial by x is a right shift by
-  one.  If we call the above polynomial p, and represent a byte as the
-  polynomial q, also with the lowest power in the most significant bit (so the
-  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
-  where a mod b means the remainder after dividing a by b.
-
-  This calculation is done using the shift-register method of multiplying and
-  taking the remainder.  The register is initialized to zero, and for each
-  incoming bit, x^32 is added mod p to the register if the bit is a one (where
-  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
-  x (which is shifting right by one and adding x^32 mod p if the bit shifted
-  out is a one).  We start with the highest power (least significant bit) of
-  q and repeat for all eight bits of q.
-
-  The first table is simply the CRC of all possible eight bit values.  This is
-  all the information needed to generate CRCs on data a byte at a time for all
-  combinations of CRC register values and incoming bytes.  The remaining tables
-  allow for word-at-a-time CRC calculation for both big-endian and little-
-  endian machines, where a word is four bytes.
-*/
-local void make_crc_table()
-{
-    z_crc_t c;
-    int n, k;
-    z_crc_t poly;                       /* polynomial exclusive-or pattern */
-    /* terms of polynomial defining this crc (except x^32): */
-    static volatile int first = 1;      /* flag to limit concurrent making */
-    static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
-
-    /* See if another task is already doing this (not thread-safe, but better
-       than nothing -- significantly reduces duration of vulnerability in
-       case the advice about DYNAMIC_CRC_TABLE is ignored) */
-    if (first) {
-        first = 0;
-
-        /* make exclusive-or pattern from polynomial (0xedb88320UL) */
-        poly = 0;
-        for (n = 0; n < (int)(sizeof(p)/sizeof(unsigned char)); n++)
-            poly |= (z_crc_t)1 << (31 - p[n]);
-
-        /* generate a crc for every 8-bit value */
-        for (n = 0; n < 256; n++) {
-            c = (z_crc_t)n;
-            for (k = 0; k < 8; k++)
-                c = c & 1 ? poly ^ (c >> 1) : c >> 1;
-            crc_table[0][n] = c;
-        }
-
-#ifdef BYFOUR
-        /* generate crc for each value followed by one, two, and three zeros,
-           and then the byte reversal of those as well as the first table */
-        for (n = 0; n < 256; n++) {
-            c = crc_table[0][n];
-            crc_table[4][n] = ZSWAP32(c);
-            for (k = 1; k < 4; k++) {
-                c = crc_table[0][c & 0xff] ^ (c >> 8);
-                crc_table[k][n] = c;
-                crc_table[k + 4][n] = ZSWAP32(c);
-            }
-        }
-#endif /* BYFOUR */
-
-        crc_table_empty = 0;
-    }
-    else {      /* not first */
-        /* wait for the other guy to finish (not efficient, but rare) */
-        while (crc_table_empty)
-            ;
-    }
+static unsigned long gf2_matrix_times(unsigned long *mat, unsigned long vec);
+static void gf2_matrix_square(unsigned long *square, unsigned long *mat);
+static unsigned long crc32_combine_(unsigned long crc1, unsigned long crc2, off_t len2);
 
-#ifdef MAKECRCH
-    /* write out CRC tables to crc32.h */
-    {
-        FILE *out;
-
-        out = fopen("crc32.h", "w");
-        if (out == NULL) return;
-        fprintf(out, "/* crc32.h -- tables for rapid CRC calculation\n");
-        fprintf(out, " * Generated automatically by crc32.c\n */\n\n");
-        fprintf(out, "local const z_crc_t ");
-        fprintf(out, "crc_table[TBLS][256] =\n{\n  {\n");
-        write_table(out, crc_table[0]);
-#  ifdef BYFOUR
-        fprintf(out, "#ifdef BYFOUR\n");
-        for (k = 1; k < 8; k++) {
-            fprintf(out, "  },\n  {\n");
-            write_table(out, crc_table[k]);
-        }
-        fprintf(out, "#endif\n");
-#  endif /* BYFOUR */
-        fprintf(out, "  }\n};\n");
-        fclose(out);
-    }
-#endif /* MAKECRCH */
-}
-
-#ifdef MAKECRCH
-local void write_table(FILE *out, const z_crc_t *table)
-{
-    int n;
-
-    for (n = 0; n < 256; n++)
-        fprintf(out, "%s0x%08lxUL%s", n % 5 ? "" : "    ",
-                (unsigned long)(table[n]),
-                n == 255 ? "\n" : (n % 5 == 4 ? ",\n" : ", "));
-}
-#endif /* MAKECRCH */
-
-#else /* !DYNAMIC_CRC_TABLE */
 /* ========================================================================
- * Tables of CRC-32s of all single-byte values, made by make_crc_table().
+ * Tables of CRC-32s of all single-byte values.
  */
 #include "crc32.h"
-#endif /* DYNAMIC_CRC_TABLE */
 
 /* =========================================================================
  * This function can be used by asm versions of crc32()
  */
-const z_crc_t * ZEXPORT get_crc_table()
+const z_crc_t * ZEXPORT get_crc_table(void)
 {
-#ifdef DYNAMIC_CRC_TABLE
-    if (crc_table_empty)
-        make_crc_table();
-#endif /* DYNAMIC_CRC_TABLE */
     return (const z_crc_t *)crc_table;
 }
 
@@ -197,29 +53,20 @@ const z_crc_t * ZEXPORT get_crc_table()
 #define DO4 DO1; DO1; DO1; DO1
 
 /* ========================================================================= */
-unsigned long ZEXPORT crc32(crc, buf, len)
-    unsigned long crc;
-    const unsigned char *buf;
-    uInt len;
+unsigned long ZEXPORT crc32(unsigned long crc,
+                            const unsigned char *buf,
+                            unsigned int len)
 {
-    if (buf == Z_NULL) return 0UL;
+    if (buf == NULL) return 0UL;
 
-#ifdef DYNAMIC_CRC_TABLE
-    if (crc_table_empty)
-        make_crc_table();
-#endif /* DYNAMIC_CRC_TABLE */
-
-#ifdef BYFOUR
     if (sizeof(void *) == sizeof(ptrdiff_t)) {
-        z_crc_t endian;
-
-        endian = 1;
-        if (*((unsigned char *)(&endian)))
-            return crc32_little(crc, buf, len);
-        else
-            return crc32_big(crc, buf, len);
+#if BYTE_ORDER == LITTLE_ENDIAN
+        return crc32_little(crc, buf, len);
+#endif
+#if BYTE_ORDER == BIG_ENDIAN
+        return crc32_big(crc, buf, len);
+#endif
     }
-#endif /* BYFOUR */
     crc = crc ^ 0xffffffffUL;
 
 #ifdef CRC32_UNROLL_LESS
@@ -240,8 +87,7 @@ unsigned long ZEXPORT crc32(crc, buf, len)
     return crc ^ 0xffffffffUL;
 }
 
-#ifdef BYFOUR
-
+#if BYTE_ORDER == LITTLE_ENDIAN
 /* ========================================================================= */
 #define DOLIT4 c ^= *buf4++; \
         c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ \
@@ -249,10 +95,12 @@ unsigned long ZEXPORT crc32(crc, buf, len)
 #define DOLIT32 DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4
 
 /* ========================================================================= */
-local unsigned long crc32_little(unsigned long crc, const unsigned char *buf, unsigned len)
+static unsigned long crc32_little(unsigned long crc,
+                                  const unsigned char *buf,
+                                  unsigned int len)
 {
-    register z_crc_t c;
-    register const z_crc_t *buf4;
+    z_crc_t c;
+    const z_crc_t *buf4;
 
     c = (z_crc_t)crc;
     c = ~c;
@@ -282,7 +130,9 @@ local unsigned long crc32_little(unsigned long crc, const unsigned char *buf, un
     c = ~c;
     return (unsigned long)c;
 }
+#endif
 
+#if BYTE_ORDER == BIG_ENDIAN
 /* ========================================================================= */
 #define DOBIG4 c ^= *++buf4; \
         c = crc_table[4][c & 0xff] ^ crc_table[5][(c >> 8) & 0xff] ^ \
@@ -290,10 +140,12 @@ local unsigned long crc32_little(unsigned long crc, const unsigned char *buf, un
 #define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4
 
 /* ========================================================================= */
-local unsigned long crc32_big(unsigned long crc, const unsigned char *buf, unsigned len)
+static unsigned long crc32_big(unsigned long crc,
+                               const unsigned char *buf,
+                               unsigned int len)
 {
-    register z_crc_t c;
-    register const z_crc_t *buf4;
+    z_crc_t c;
+    const z_crc_t *buf4;
 
     c = ZSWAP32((z_crc_t)crc);
     c = ~c;
@@ -325,13 +177,13 @@ local unsigned long crc32_big(unsigned long crc, const unsigned char *buf, unsig
     c = ~c;
     return (unsigned long)(ZSWAP32(c));
 }
-
-#endif /* BYFOUR */
+#endif
 
 #define GF2_DIM 32      /* dimension of GF(2) vectors (length of CRC) */
 
 /* ========================================================================= */
-local unsigned long gf2_matrix_times(unsigned long *mat, unsigned long vec)
+static unsigned long gf2_matrix_times(unsigned long *mat,
+                                      unsigned long vec)
 {
     unsigned long sum;
 
@@ -346,7 +198,8 @@ local unsigned long gf2_matrix_times(unsigned long *mat, unsigned long vec)
 }
 
 /* ========================================================================= */
-local void gf2_matrix_square(unsigned long *square, unsigned long *mat)
+static void gf2_matrix_square(unsigned long *square,
+                              unsigned long *mat)
 {
     int n;
 
@@ -355,7 +208,9 @@ local void gf2_matrix_square(unsigned long *square, unsigned long *mat)
 }
 
 /* ========================================================================= */
-local uLong crc32_combine_(uLong crc1, uLong crc2, z_off64_t len2)
+static unsigned long crc32_combine_(unsigned long crc1,
+                                    unsigned long crc2,
+                                    off_t len2)
 {
     int n;
     unsigned long row;
@@ -408,18 +263,12 @@ local uLong crc32_combine_(uLong crc1, uLong crc2, z_off64_t len2)
 }
 
 /* ========================================================================= */
-uLong ZEXPORT crc32_combine(crc1, crc2, len2)
-    uLong crc1;
-    uLong crc2;
-    z_off_t len2;
+unsigned long ZEXPORT crc32_combine(unsigned long crc1, unsigned long crc2, off_t len2)
 {
     return crc32_combine_(crc1, crc2, len2);
 }
 
-uLong ZEXPORT crc32_combine64(crc1, crc2, len2)
-    uLong crc1;
-    uLong crc2;
-    z_off64_t len2;
+unsigned long ZEXPORT crc32_combine64(unsigned long crc1, unsigned long crc2, off_t len2)
 {
     return crc32_combine_(crc1, crc2, len2);
 }
@@ -428,10 +277,10 @@ uLong ZEXPORT crc32_combine64(crc1, crc2, len2)
 
 #ifdef X86_PCLMULQDQ_CRC
 #include "arch/x86/x86.h"
-extern void ZLIB_INTERNAL crc_fold_init(deflate_state *z_const s);
-extern void ZLIB_INTERNAL crc_fold_copy(deflate_state *z_const s,
-        unsigned char *dst, z_const unsigned char *src, long len);
-extern unsigned ZLIB_INTERNAL crc_fold_512to32(deflate_state *z_const s);
+extern void ZLIB_INTERNAL crc_fold_init(deflate_state *const s);
+extern void ZLIB_INTERNAL crc_fold_copy(deflate_state *const s,
+        unsigned char *dst, const unsigned char *src, long len);
+extern unsigned ZLIB_INTERNAL crc_fold_512to32(deflate_state *const s);
 #endif
 
 ZLIB_INTERNAL void crc_reset(deflate_state *const s)
@@ -442,7 +291,7 @@ ZLIB_INTERNAL void crc_reset(deflate_state *const s)
         return;
     }
 #endif
-    s->strm->adler = crc32(0L, Z_NULL, 0);
+    s->strm->adler = crc32(0L, NULL, 0);
 }
 
 ZLIB_INTERNAL void crc_finalize(deflate_state *const s)
@@ -453,7 +302,7 @@ ZLIB_INTERNAL void crc_finalize(deflate_state *const s)
 #endif
 }
 
-ZLIB_INTERNAL void copy_with_crc(z_stream *strm, Byte *dst, long size)
+ZLIB_INTERNAL void copy_with_crc(z_stream *strm, unsigned char *dst, long size)
 {
 #ifdef X86_PCLMULQDQ_CRC
     if (x86_cpu_has_pclmulqdq) {
diff --git a/crc32.h b/crc32.h
index c2f4c6b..444d2fb 100644
--- a/crc32.h
+++ b/crc32.h
@@ -2,7 +2,7 @@
  * Generated automatically by crc32.c
  */
 
-local const z_crc_t crc_table[TBLS][256] =
+static const z_crc_t crc_table[TBLS][256] =
 {
   {
     0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,
@@ -57,7 +57,6 @@ local const z_crc_t crc_table[TBLS][256] =
     0xcdd70693UL, 0x54de5729UL, 0x23d967bfUL, 0xb3667a2eUL, 0xc4614ab8UL,
     0x5d681b02UL, 0x2a6f2b94UL, 0xb40bbe37UL, 0xc30c8ea1UL, 0x5a05df1bUL,
     0x2d02ef8dUL
-#ifdef BYFOUR
   },
   {
     0x00000000UL, 0x191b3141UL, 0x32366282UL, 0x2b2d53c3UL, 0x646cc504UL,
@@ -436,6 +435,5 @@ local const z_crc_t crc_table[TBLS][256] =
     0x95e6b8b1UL, 0x7b490da3UL, 0x1e2eb11bUL, 0x483ed243UL, 0x2d596efbUL,
     0xc3f6dbe9UL, 0xa6916751UL, 0x1fa9b0ccUL, 0x7ace0c74UL, 0x9461b966UL,
     0xf10605deUL
-#endif
   }
 };
diff --git a/deflate.c b/deflate.c
index eecd925..400cf71 100644
--- a/deflate.c
+++ b/deflate.c
@@ -56,6 +56,7 @@
 #include "arch/x86/x86.h"
 #endif
 
+ZLIB_INTERNAL
 const char deflate_copyright[] =
    " deflate 1.2.8.f Copyright 1995-2013 Jean-loup Gailly and Mark Adler ";
 /*
@@ -69,29 +70,29 @@ const char deflate_copyright[] =
  *  Function prototypes.
  */
 
-typedef block_state (*compress_func) (deflate_state *s, int flush);
+typedef block_state (*compress_func)(deflate_state *s, int flush);
 /* Compression function. Returns the block state after the call. */
 
-local void fill_window    (deflate_state *s);
-local block_state deflate_stored (deflate_state *s, int flush);
-local block_state deflate_fast   (deflate_state *s, int flush);
-block_state deflate_quick  (deflate_state *s, int flush);
-local block_state deflate_medium (deflate_state *s, int flush);
-local block_state deflate_slow   (deflate_state *s, int flush);
-local block_state deflate_rle    (deflate_state *s, int flush);
-local block_state deflate_huff   (deflate_state *s, int flush);
-local void lm_init        (deflate_state *s);
-local void putShortMSB    (deflate_state *s, uInt b);
-ZLIB_INTERNAL void flush_pending  (z_stream *strm);
-ZLIB_INTERNAL int read_buf        (z_stream *strm, Byte *buf, unsigned size);
+static void fill_window(deflate_state *s);
+static block_state deflate_stored(deflate_state *s, int flush);
+static block_state deflate_fast(deflate_state *s, int flush);
+block_state deflate_quick(deflate_state *s, int flush);
+block_state deflate_medium(deflate_state *s, int flush);
+static block_state deflate_slow(deflate_state *s, int flush);
+static block_state deflate_rle(deflate_state *s, int flush);
+static block_state deflate_huff(deflate_state *s, int flush);
+static void lm_init(deflate_state *s);
+static void putShortMSB(deflate_state *s, unsigned int b);
+ZLIB_INTERNAL void flush_pending(z_stream *strm);
+ZLIB_INTERNAL int read_buf(z_stream *strm, unsigned char *buf, unsigned int size);
 
 #ifdef DEBUG
-local  void check_match (deflate_state *s, IPos start, IPos match, int length);
+static  void check_match(deflate_state *s, IPos start, IPos match, int length);
 #endif
 
 extern void crc_reset(deflate_state *const s);
 extern void crc_finalize(deflate_state *const s);
-extern void copy_with_crc(z_stream *strm, Byte *dst, long size);
+extern void copy_with_crc(z_stream *strm, unsigned char *dst, long size);
 
 /* ===========================================================================
  * Local data
@@ -111,14 +112,14 @@ extern void copy_with_crc(z_stream *strm, Byte *dst, long size);
  * found for specific files.
  */
 typedef struct config_s {
-   ush good_length; /* reduce lazy search above this match length */
-   ush max_lazy;    /* do not perform lazy search above this match length */
-   ush nice_length; /* quit search above this match length */
-   ush max_chain;
+   unsigned short good_length; /* reduce lazy search above this match length */
+   unsigned short max_lazy;    /* do not perform lazy search above this match length */
+   unsigned short nice_length; /* quit search above this match length */
+   unsigned short max_chain;
    compress_func func;
 } config;
 
-local const config configuration_table[10] = {
+static const config configuration_table[10] = {
 /*      good lazy nice chain */
 /* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
 
@@ -151,9 +152,6 @@ local const config configuration_table[10] = {
  * meaning.
  */
 
-#define EQUAL 0
-/* result of memcmp for equal strings */
-
 /* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */
 #define RANK(f) (((f) << 1) - ((f) > 4 ? 9 : 0))
 
@@ -162,12 +160,12 @@ local const config configuration_table[10] = {
  * Insert string str in the dictionary and set match_head to the previous head
  * of the hash chain (the most recent string with same hash key). Return
  * the previous length of the hash chain.
- * IN  assertion: all calls to to INSERT_STRING are made with consecutive
+ * IN  assertion: all calls to INSERT_STRING are made with consecutive
  *    input characters and the first MIN_MATCH bytes of str are valid
  *    (except for the last MIN_MATCH-1 bytes of the input file).
  */
 #ifdef X86_SSE4_2_CRC_HASH
-local inline Pos insert_string_sse(deflate_state *z_const s, z_const Pos str)
+static inline Pos insert_string_sse(deflate_state *const s, const Pos str)
 {
     Pos ret;
     unsigned *ip, val, h = 0;
@@ -191,7 +189,7 @@ local inline Pos insert_string_sse(deflate_state *z_const s, z_const Pos str)
 }
 #endif
 
-local inline Pos insert_string_c(deflate_state *z_const s, z_const Pos str)
+static inline Pos insert_string_c(deflate_state *const s, const Pos str)
 {
     Pos ret;
 
@@ -202,7 +200,7 @@ local inline Pos insert_string_c(deflate_state *z_const s, z_const Pos str)
     return ret;
 }
 
-local inline Pos insert_string(deflate_state *z_const s, z_const Pos str)
+static inline Pos insert_string(deflate_state *const s, const Pos str)
 {
 #ifdef X86_SSE4_2_CRC_HASH
     if (x86_cpu_has_sse42)
@@ -213,9 +211,9 @@ local inline Pos insert_string(deflate_state *z_const s, z_const Pos str)
 
 
 #ifndef NOT_TWEAK_COMPILER
-local inline void
-bulk_insert_str(deflate_state *s, Pos startpos, uInt count) {
-    uInt idx;
+static inline void
+bulk_insert_str(deflate_state *s, Pos startpos, unsigned int count) {
+    unsigned int idx;
     for (idx = 0; idx < count; idx++) {
         insert_string(s, startpos + idx);
     }
@@ -228,14 +226,13 @@ bulk_insert_str(deflate_state *s, Pos startpos, uInt count) {
  */
 #define CLEAR_HASH(s) \
     s->head[s->hash_size-1] = NIL; \
-    memset((Byte *)s->head, 0, (unsigned)(s->hash_size-1)*sizeof(*s->head));
+    memset((unsigned char *)s->head, 0, (unsigned int)(s->hash_size-1)*sizeof(*s->head));
 
 /* ========================================================================= */
-int ZEXPORT deflateInit_(strm, level, version, stream_size)
-    z_stream *strm;
-    int level;
-    const char *version;
-    int stream_size;
+int ZEXPORT deflateInit_(z_stream *strm,
+                         int level,
+                         const char *version,
+                         int stream_size)
 {
     return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
                          Z_DEFAULT_STRATEGY, version, stream_size);
@@ -243,23 +240,21 @@ int ZEXPORT deflateInit_(strm, level, version, stream_size)
 }
 
 /* ========================================================================= */
-int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
-                  version, stream_size)
-    z_stream *strm;
-    int  level;
-    int  method;
-    int  windowBits;
-    int  memLevel;
-    int  strategy;
-    const char *version;
-    int stream_size;
+int ZEXPORT deflateInit2_(z_stream *strm,
+                          int level,
+                          int method,
+                          int windowBits,
+                          int memLevel,
+                          int strategy,
+                          const char *version,
+                          int stream_size)
 {
     unsigned window_padding = 0;
     deflate_state *s;
     int wrap = 1;
     static const char my_version[] = ZLIB_VERSION;
 
-    ush *overlay;
+    unsigned short *overlay;
     /* We overlay pending_buf and d_buf+l_buf. This works since the average
      * output size for (length,distance) codes is <= 24 bits.
      */
@@ -268,27 +263,18 @@ int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
     x86_check_features();
 #endif
 
-    if (version == Z_NULL || version[0] != my_version[0] ||
+    if (version == NULL || version[0] != my_version[0] ||
         stream_size != sizeof(z_stream)) {
         return Z_VERSION_ERROR;
     }
-    if (strm == Z_NULL) return Z_STREAM_ERROR;
+    if (strm == NULL) return Z_STREAM_ERROR;
 
-    strm->msg = Z_NULL;
-    if (strm->zalloc == (alloc_func)0) {
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
+    strm->msg = NULL;
+    if (strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {
         strm->zalloc = zcalloc;
-        strm->opaque = (void *)0;
-#endif
-    }
-    if (strm->zfree == (free_func)0)
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
         strm->zfree = zcfree;
-#endif
+        strm->opaque = NULL;
+    }
 
     if (level == Z_DEFAULT_COMPRESSION) level = 6;
 
@@ -296,12 +282,10 @@ int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
         wrap = 0;
         windowBits = -windowBits;
     }
-#ifdef GZIP
     else if (windowBits > 15) {
         wrap = 2;       /* write gzip wrapper instead */
         windowBits -= 16;
     }
-#endif
     if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
         windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
         strategy < 0 || strategy > Z_FIXED) {
@@ -314,13 +298,13 @@ int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
         windowBits = 13;
 #endif
 
-    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
-    if (s == Z_NULL) return Z_MEM_ERROR;
+    s = (deflate_state *) z_stream_alloc(strm, sizeof(deflate_state));
+    if (s == NULL) return Z_MEM_ERROR;
     strm->state = (struct internal_state *)s;
     s->strm = strm;
 
     s->wrap = wrap;
-    s->gzhead = Z_NULL;
+    s->gzhead = NULL;
     s->w_bits = windowBits;
     s->w_size = 1 << s->w_bits;
     s->w_mask = s->w_size - 1;
@@ -340,48 +324,47 @@ int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
     window_padding = 8;
 #endif
 
-    s->window = (Byte *) ZALLOC(strm, s->w_size + window_padding, 2*sizeof(Byte));
-    s->prev   = (Pos *)  ZALLOC(strm, s->w_size, sizeof(Pos));
-    s->head   = (Pos *)  ZALLOC(strm, s->hash_size, sizeof(Pos));
+    s->window = (unsigned char *) z_stream_allocarray(strm, s->w_size + window_padding, 2*sizeof(unsigned char));
+    s->prev   = (Pos *)  z_stream_allocarray(strm, s->w_size, sizeof(Pos));
+    s->head   = (Pos *)  z_stream_allocarray(strm, s->hash_size, sizeof(Pos));
 
     s->high_water = 0;      /* nothing written to s->window yet */
 
     s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
 
-    overlay = (ush *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
-    s->pending_buf = (uch *) overlay;
-    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);
+    overlay = (unsigned short *) z_stream_allocarray(strm, s->lit_bufsize, sizeof(unsigned short)+2);
+    s->pending_buf = (unsigned char *) overlay;
+    s->pending_buf_size = (unsigned long)s->lit_bufsize * (sizeof(unsigned short)+2L);
 
-    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
-        s->pending_buf == Z_NULL) {
+    if (s->window == NULL || s->prev == NULL || s->head == NULL ||
+        s->pending_buf == NULL) {
         s->status = FINISH_STATE;
         strm->msg = ERR_MSG(Z_MEM_ERROR);
         deflateEnd (strm);
         return Z_MEM_ERROR;
     }
-    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
-    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
+    s->d_buf = overlay + s->lit_bufsize/sizeof(unsigned short);
+    s->l_buf = s->pending_buf + (1+sizeof(unsigned short))*s->lit_bufsize;
 
     s->level = level;
     s->strategy = strategy;
-    s->method = (Byte)method;
+    s->method = (unsigned char)method;
 
     return deflateReset(strm);
 }
 
 /* ========================================================================= */
-int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
-    z_stream *strm;
-    const Byte *dictionary;
-    uInt  dictLength;
+int ZEXPORT deflateSetDictionary(z_stream *strm,
+                                 const unsigned char *dictionary,
+                                 unsigned int dictLength)
 {
     deflate_state *s;
-    uInt str, n;
+    unsigned int str, n;
     int wrap;
-    unsigned avail;
-    z_const unsigned char *next;
+    unsigned int avail;
+    const unsigned char *next;
 
-    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL)
+    if (strm == NULL || strm->state == NULL || dictionary == NULL)
         return Z_STREAM_ERROR;
     s = strm->state;
     wrap = s->wrap;
@@ -409,7 +392,7 @@ int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
     avail = strm->avail_in;
     next = strm->next_in;
     strm->avail_in = dictLength;
-    strm->next_in = (z_const Byte *)dictionary;
+    strm->next_in = (const unsigned char *)dictionary;
     fill_window(s);
     while (s->lookahead >= MIN_MATCH) {
         str = s->strstart;
@@ -437,18 +420,17 @@ int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
 }
 
 /* ========================================================================= */
-int ZEXPORT deflateResetKeep (strm)
-    z_stream *strm;
+int ZEXPORT deflateResetKeep(z_stream *strm)
 {
     deflate_state *s;
 
-    if (strm == Z_NULL || strm->state == Z_NULL ||
+    if (strm == NULL || strm->state == NULL ||
         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {
         return Z_STREAM_ERROR;
     }
 
     strm->total_in = strm->total_out = 0;
-    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
+    strm->msg = NULL; /* use zfree if we ever allocate msg dynamically */
     strm->data_type = Z_UNKNOWN;
 
     s = (deflate_state *)strm->state;
@@ -460,10 +442,8 @@ int ZEXPORT deflateResetKeep (strm)
     }
     s->status = s->wrap ? INIT_STATE : BUSY_STATE;
     strm->adler =
-#ifdef GZIP
-        s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
-#endif
-        adler32(0L, Z_NULL, 0);
+        s->wrap == 2 ? crc32(0L, NULL, 0) :
+        adler32(0L, NULL, 0);
     s->last_flush = Z_NO_FLUSH;
 
     _tr_init(s);
@@ -472,8 +452,7 @@ int ZEXPORT deflateResetKeep (strm)
 }
 
 /* ========================================================================= */
-int ZEXPORT deflateReset (strm)
-    z_stream *strm;
+int ZEXPORT deflateReset(z_stream *strm)
 {
     int ret;
 
@@ -484,48 +463,45 @@ int ZEXPORT deflateReset (strm)
 }
 
 /* ========================================================================= */
-int ZEXPORT deflateSetHeader (strm, head)
-    z_stream *strm;
-    gz_headerp head;
+int ZEXPORT deflateSetHeader(z_stream *strm,
+                             gz_header *head)
 {
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    if (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;
     if (strm->state->wrap != 2) return Z_STREAM_ERROR;
     strm->state->gzhead = head;
     return Z_OK;
 }
 
 /* ========================================================================= */
-int ZEXPORT deflatePending (strm, pending, bits)
-    unsigned *pending;
-    int *bits;
-    z_stream *strm;
+int ZEXPORT deflatePending(z_stream *strm,
+                           unsigned int *pending,
+                           int *bits)
 {
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    if (pending != Z_NULL)
+    if (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;
+    if (pending != NULL)
         *pending = strm->state->pending;
-    if (bits != Z_NULL)
+    if (bits != NULL)
         *bits = strm->state->bi_valid;
     return Z_OK;
 }
 
 /* ========================================================================= */
-int ZEXPORT deflatePrime (strm, bits, value)
-    z_stream *strm;
-    int bits;
-    int value;
+int ZEXPORT deflatePrime(z_stream *strm,
+                         int bits,
+                         int value)
 {
     deflate_state *s;
     int put;
 
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    if (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;
     s = strm->state;
-    if ((Byte *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))
+    if ((unsigned char *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))
         return Z_BUF_ERROR;
     do {
         put = Buf_size - s->bi_valid;
         if (put > bits)
             put = bits;
-        s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);
+        s->bi_buf |= (unsigned short)((value & ((1 << put) - 1)) << s->bi_valid);
         s->bi_valid += put;
         _tr_flush_bits(s);
         value >>= put;
@@ -535,16 +511,15 @@ int ZEXPORT deflatePrime (strm, bits, value)
 }
 
 /* ========================================================================= */
-int ZEXPORT deflateParams(strm, level, strategy)
-    z_stream *strm;
-    int level;
-    int strategy;
+int ZEXPORT deflateParams(z_stream *strm,
+                          int level,
+                          int strategy)
 {
     deflate_state *s;
     compress_func func;
     int err = Z_OK;
 
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    if (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;
     s = strm->state;
 
     if (level == Z_DEFAULT_COMPRESSION) level = 6;
@@ -572,16 +547,15 @@ int ZEXPORT deflateParams(strm, level, strategy)
 }
 
 /* ========================================================================= */
-int ZEXPORT deflateTune(strm, good_length, max_lazy, nice_length, max_chain)
-    z_stream *strm;
-    int good_length;
-    int max_lazy;
-    int nice_length;
-    int max_chain;
+int ZEXPORT deflateTune(z_stream *strm,
+                        int good_length,
+                        int max_lazy,
+                        int nice_length,
+                        int max_chain)
 {
     deflate_state *s;
 
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    if (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;
     s = strm->state;
     s->good_match = good_length;
     s->max_lazy_match = max_lazy;
@@ -607,20 +581,19 @@ int ZEXPORT deflateTune(strm, good_length, max_lazy, nice_length, max_chain)
  * upper bound of about 14% expansion does not seem onerous for output buffer
  * allocation.
  */
-uLong ZEXPORT deflateBound(strm, sourceLen)
-    z_stream *strm;
-    uLong sourceLen;
+unsigned long ZEXPORT deflateBound(z_stream *strm,
+                                   unsigned long sourceLen)
 {
     deflate_state *s;
-    uLong complen, wraplen;
-    Byte *str;
+    unsigned long complen, wraplen;
+    unsigned char *str;
 
     /* conservative upper bound for compressed data */
     complen = sourceLen +
               ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;
 
     /* if can't get parameters, return conservative bound plus zlib wrapper */
-    if (strm == Z_NULL || strm->state == Z_NULL)
+    if (strm == NULL || strm->state == NULL)
         return complen + 6;
 
     /* compute wrapper length */
@@ -634,16 +607,16 @@ uLong ZEXPORT deflateBound(strm, sourceLen)
         break;
     case 2:                                 /* gzip wrapper */
         wraplen = 18;
-        if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */
-            if (s->gzhead->extra != Z_NULL)
+        if (s->gzhead != NULL) {            /* user-supplied gzip header */
+            if (s->gzhead->extra != NULL)
                 wraplen += 2 + s->gzhead->extra_len;
             str = s->gzhead->name;
-            if (str != Z_NULL)
+            if (str != NULL)
                 do {
                     wraplen++;
                 } while (*str++);
             str = s->gzhead->comment;
-            if (str != Z_NULL)
+            if (str != NULL)
                 do {
                     wraplen++;
                 } while (*str++);
@@ -669,10 +642,11 @@ uLong ZEXPORT deflateBound(strm, sourceLen)
  * IN assertion: the stream state is correct and there is enough room in
  * pending_buf.
  */
-local void putShortMSB (deflate_state *s, uInt b)
+static void putShortMSB(deflate_state *s,
+                        unsigned int b)
 {
-    put_byte(s, (Byte)(b >> 8));
-    put_byte(s, (Byte)(b & 0xff));
+    put_byte(s, (unsigned char)(b >> 8));
+    put_byte(s, (unsigned char)(b & 0xff));
 }
 
 /* =========================================================================
@@ -681,8 +655,7 @@ local void putShortMSB (deflate_state *s, uInt b)
  * to avoid allocating a large strm->next_out buffer and copying into it.
  * (See also read_buf()).
  */
-ZLIB_INTERNAL void flush_pending(strm)
-    z_stream *strm;
+ZLIB_INTERNAL void flush_pending(z_stream *strm)
 {
     unsigned len;
     deflate_state *s = strm->state;
@@ -704,25 +677,24 @@ ZLIB_INTERNAL void flush_pending(strm)
 }
 
 /* ========================================================================= */
-int ZEXPORT deflate (strm, flush)
-    z_stream *strm;
-    int flush;
+int ZEXPORT deflate(z_stream *strm,
+                    int flush)
 {
     int old_flush; /* value of flush param for previous deflate call */
     deflate_state *s;
 
-    if (strm == Z_NULL || strm->state == Z_NULL ||
+    if (strm == NULL || strm->state == NULL ||
         flush > Z_BLOCK || flush < 0) {
         return Z_STREAM_ERROR;
     }
     s = strm->state;
 
-    if (strm->next_out == Z_NULL ||
-        (strm->next_in == Z_NULL && strm->avail_in != 0) ||
-        (s->status == FINISH_STATE && flush != Z_FINISH)) {
-        ERR_RETURN(strm, Z_STREAM_ERROR);
-    }
-    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);
+    if (strm->next_out == NULL ||
+        (strm->next_in == NULL && strm->avail_in != 0) ||
+        (s->status == FINISH_STATE && flush != Z_FINISH))
+        return strm->msg = ERR_MSG(Z_STREAM_ERROR), Z_STREAM_ERROR;
+    if (strm->avail_out == 0)
+        return strm->msg = ERR_MSG(Z_BUF_ERROR), Z_BUF_ERROR;
 
     s->strm = strm; /* just in case */
     old_flush = s->last_flush;
@@ -730,13 +702,12 @@ int ZEXPORT deflate (strm, flush)
 
     /* Write the header */
     if (s->status == INIT_STATE) {
-#ifdef GZIP
         if (s->wrap == 2) {
             crc_reset(s);
             put_byte(s, 31);
             put_byte(s, 139);
             put_byte(s, 8);
-            if (s->gzhead == Z_NULL) {
+            if (s->gzhead == NULL) {
                 put_byte(s, 0);
                 put_byte(s, 0);
                 put_byte(s, 0);
@@ -751,19 +722,19 @@ int ZEXPORT deflate (strm, flush)
             else {
                 put_byte(s, (s->gzhead->text ? 1 : 0) +
                             (s->gzhead->hcrc ? 2 : 0) +
-                            (s->gzhead->extra == Z_NULL ? 0 : 4) +
-                            (s->gzhead->name == Z_NULL ? 0 : 8) +
-                            (s->gzhead->comment == Z_NULL ? 0 : 16)
+                            (s->gzhead->extra == NULL ? 0 : 4) +
+                            (s->gzhead->name == NULL ? 0 : 8) +
+                            (s->gzhead->comment == NULL ? 0 : 16)
                         );
-                put_byte(s, (Byte)(s->gzhead->time & 0xff));
-                put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));
-                put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));
-                put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));
+                put_byte(s, (unsigned char)(s->gzhead->time & 0xff));
+                put_byte(s, (unsigned char)((s->gzhead->time >> 8) & 0xff));
+                put_byte(s, (unsigned char)((s->gzhead->time >> 16) & 0xff));
+                put_byte(s, (unsigned char)((s->gzhead->time >> 24) & 0xff));
                 put_byte(s, s->level == 9 ? 2 :
                             (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
                              4 : 0));
                 put_byte(s, s->gzhead->os & 0xff);
-                if (s->gzhead->extra != Z_NULL) {
+                if (s->gzhead->extra != NULL) {
                     put_byte(s, s->gzhead->extra_len & 0xff);
                     put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);
                 }
@@ -773,12 +744,9 @@ int ZEXPORT deflate (strm, flush)
                 s->gzindex = 0;
                 s->status = EXTRA_STATE;
             }
-        }
-        else
-#endif
-        {
-            uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
-            uInt level_flags;
+        } else {
+            unsigned int header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
+            unsigned int level_flags;
 
             if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)
                 level_flags = 0;
@@ -797,16 +765,15 @@ int ZEXPORT deflate (strm, flush)
 
             /* Save the adler32 of the preset dictionary: */
             if (s->strstart != 0) {
-                putShortMSB(s, (uInt)(strm->adler >> 16));
-                putShortMSB(s, (uInt)(strm->adler & 0xffff));
+                putShortMSB(s, (unsigned int)(strm->adler >> 16));
+                putShortMSB(s, (unsigned int)(strm->adler & 0xffff));
             }
-            strm->adler = adler32(0L, Z_NULL, 0);
+            strm->adler = adler32(0L, NULL, 0);
         }
     }
-#ifdef GZIP
     if (s->status == EXTRA_STATE) {
-        if (s->gzhead->extra != Z_NULL) {
-            uInt beg = s->pending;  /* start of bytes to update crc */
+        if (s->gzhead->extra != NULL) {
+            unsigned int beg = s->pending;  /* start of bytes to update crc */
 
             while (s->gzindex < (s->gzhead->extra_len & 0xffff)) {
                 if (s->pending == s->pending_buf_size) {
@@ -833,8 +800,8 @@ int ZEXPORT deflate (strm, flush)
             s->status = NAME_STATE;
     }
     if (s->status == NAME_STATE) {
-        if (s->gzhead->name != Z_NULL) {
-            uInt beg = s->pending;  /* start of bytes to update crc */
+        if (s->gzhead->name != NULL) {
+            unsigned int beg = s->pending;  /* start of bytes to update crc */
             int val;
 
             do {
@@ -864,8 +831,8 @@ int ZEXPORT deflate (strm, flush)
             s->status = COMMENT_STATE;
     }
     if (s->status == COMMENT_STATE) {
-        if (s->gzhead->comment != Z_NULL) {
-            uInt beg = s->pending;  /* start of bytes to update crc */
+        if (s->gzhead->comment != NULL) {
+            unsigned int beg = s->pending;  /* start of bytes to update crc */
             int val;
 
             do {
@@ -897,16 +864,15 @@ int ZEXPORT deflate (strm, flush)
             if (s->pending + 2 > s->pending_buf_size)
                 flush_pending(strm);
             if (s->pending + 2 <= s->pending_buf_size) {
-                put_byte(s, (Byte)(strm->adler & 0xff));
-                put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
-                strm->adler = crc32(0L, Z_NULL, 0);
+                put_byte(s, (unsigned char)(strm->adler & 0xff));
+                put_byte(s, (unsigned char)((strm->adler >> 8) & 0xff));
+                strm->adler = crc32(0L, NULL, 0);
                 s->status = BUSY_STATE;
             }
         }
         else
             s->status = BUSY_STATE;
     }
-#endif
 
     /* Flush as much pending output as possible */
     if (s->pending != 0) {
@@ -927,14 +893,12 @@ int ZEXPORT deflate (strm, flush)
      * returning Z_STREAM_END instead of Z_BUF_ERROR.
      */
     } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&
-               flush != Z_FINISH) {
-        ERR_RETURN(strm, Z_BUF_ERROR);
-    }
+               flush != Z_FINISH)
+        return strm->msg = ERR_MSG(Z_BUF_ERROR), Z_BUF_ERROR;
 
     /* User must not provide more input after the first FINISH: */
-    if (s->status == FINISH_STATE && strm->avail_in != 0) {
-        ERR_RETURN(strm, Z_BUF_ERROR);
-    }
+    if (s->status == FINISH_STATE && strm->avail_in != 0)
+        return strm->msg = ERR_MSG(Z_BUF_ERROR), Z_BUF_ERROR;
 
     /* Start a new block or continue the current one.
      */
@@ -999,23 +963,19 @@ int ZEXPORT deflate (strm, flush)
     if (s->wrap <= 0) return Z_STREAM_END;
 
     /* Write the trailer */
-#ifdef GZIP
     if (s->wrap == 2) {
         crc_finalize(s);
-        put_byte(s, (Byte)(strm->adler & 0xff));
-        put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
-        put_byte(s, (Byte)((strm->adler >> 16) & 0xff));
-        put_byte(s, (Byte)((strm->adler >> 24) & 0xff));
-        put_byte(s, (Byte)(strm->total_in & 0xff));
-        put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));
-        put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));
-        put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));
-    }
-    else
-#endif
-    {
-        putShortMSB(s, (uInt)(strm->adler >> 16));
-        putShortMSB(s, (uInt)(strm->adler & 0xffff));
+        put_byte(s, (unsigned char)(strm->adler & 0xff));
+        put_byte(s, (unsigned char)((strm->adler >> 8) & 0xff));
+        put_byte(s, (unsigned char)((strm->adler >> 16) & 0xff));
+        put_byte(s, (unsigned char)((strm->adler >> 24) & 0xff));
+        put_byte(s, (unsigned char)(strm->total_in & 0xff));
+        put_byte(s, (unsigned char)((strm->total_in >> 8) & 0xff));
+        put_byte(s, (unsigned char)((strm->total_in >> 16) & 0xff));
+        put_byte(s, (unsigned char)((strm->total_in >> 24) & 0xff));
+    } else {
+        putShortMSB(s, (unsigned int)(strm->adler >> 16));
+        putShortMSB(s, (unsigned int)(strm->adler & 0xffff));
     }
     flush_pending(strm);
     /* If avail_out is zero, the application will call deflate again
@@ -1026,12 +986,11 @@ int ZEXPORT deflate (strm, flush)
 }
 
 /* ========================================================================= */
-int ZEXPORT deflateEnd (strm)
-    z_stream *strm;
+int ZEXPORT deflateEnd(z_stream *strm)
 {
     int status;
 
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    if (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;
 
     status = strm->state->status;
     if (status != INIT_STATE &&
@@ -1045,13 +1004,13 @@ int ZEXPORT deflateEnd (strm)
     }
 
     /* Deallocate in reverse order of allocations: */
-    TRY_FREE(strm, strm->state->pending_buf);
-    TRY_FREE(strm, strm->state->head);
-    TRY_FREE(strm, strm->state->prev);
-    TRY_FREE(strm, strm->state->window);
+    z_stream_free(strm, strm->state->pending_buf);
+    z_stream_free(strm, strm->state->head);
+    z_stream_free(strm, strm->state->prev);
+    z_stream_free(strm, strm->state->window);
 
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
+    z_stream_free(strm, strm->state);
+    strm->state = NULL;
 
     return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
 }
@@ -1059,49 +1018,47 @@ int ZEXPORT deflateEnd (strm)
 /* =========================================================================
  * Copy the source state to the destination state.
  */
-int ZEXPORT deflateCopy (dest, source)
-    z_stream *dest;
-    z_stream *source;
+int ZEXPORT deflateCopy(z_stream *dest,
+                        z_stream *source)
 {
     deflate_state *ds;
     deflate_state *ss;
-    ush *overlay;
+    unsigned short *overlay;
 
 
-    if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {
+    if (source == NULL || dest == NULL || source->state == NULL)
         return Z_STREAM_ERROR;
-    }
 
     ss = source->state;
 
-    memcpy((void *)dest, (void *)source, sizeof(z_stream));
+    memcpy(dest, source, sizeof(z_stream));
 
-    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
-    if (ds == Z_NULL) return Z_MEM_ERROR;
+    ds = (deflate_state *) z_stream_alloc(dest, sizeof(deflate_state));
+    if (ds == NULL) return Z_MEM_ERROR;
     dest->state = (struct internal_state *) ds;
-    memcpy((void *)ds, (void *)ss, sizeof(deflate_state));
+    memcpy(ds, ss, sizeof(deflate_state));
     ds->strm = dest;
 
-    ds->window = (Byte *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
-    ds->prev   = (Pos *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
-    ds->head   = (Pos *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
-    overlay = (ush *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);
-    ds->pending_buf = (uch *) overlay;
+    ds->window = (unsigned char *) z_stream_allocarray(dest, ds->w_size, 2*sizeof(unsigned char));
+    ds->prev   = (Pos *)  z_stream_allocarray(dest, ds->w_size, sizeof(Pos));
+    ds->head   = (Pos *)  z_stream_allocarray(dest, ds->hash_size, sizeof(Pos));
+    overlay = (unsigned short *) z_stream_allocarray(dest, ds->lit_bufsize, sizeof(unsigned short)+2);
+    ds->pending_buf = (unsigned char *) overlay;
 
-    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
-        ds->pending_buf == Z_NULL) {
+    if (ds->window == NULL || ds->prev == NULL || ds->head == NULL ||
+        ds->pending_buf == NULL) {
         deflateEnd (dest);
         return Z_MEM_ERROR;
     }
 
-    memcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
-    memcpy((void *)ds->prev, (void *)ss->prev, ds->w_size * sizeof(Pos));
-    memcpy((void *)ds->head, (void *)ss->head, ds->hash_size * sizeof(Pos));
-    memcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);
+    memcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(unsigned char));
+    memcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));
+    memcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));
+    memcpy(ds->pending_buf, ss->pending_buf, (unsigned int)ds->pending_buf_size);
 
     ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
-    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
-    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;
+    ds->d_buf = overlay + ds->lit_bufsize/sizeof(unsigned short);
+    ds->l_buf = ds->pending_buf + (1+sizeof(unsigned short))*ds->lit_bufsize;
 
     ds->l_desc.dyn_tree = ds->dyn_ltree;
     ds->d_desc.dyn_tree = ds->dyn_dtree;
@@ -1117,20 +1074,20 @@ int ZEXPORT deflateCopy (dest, source)
  * allocating a large strm->next_in buffer and copying from it.
  * (See also flush_pending()).
  */
-ZLIB_INTERNAL int read_buf(z_stream *strm, Byte *buf, unsigned size)
+ZLIB_INTERNAL int read_buf(z_stream *strm,
+                    unsigned char *buf,
+                    unsigned int size)
 {
-    unsigned len = strm->avail_in;
+    unsigned int len = strm->avail_in;
 
     if (len > size) len = size;
     if (len == 0) return 0;
 
     strm->avail_in  -= len;
 
-#ifdef GZIP
     if (strm->state->wrap == 2)
         copy_with_crc(strm, buf, len);
-    else 
-#endif
+    else
     {
         memcpy(buf, strm->next_in, len);
         if (strm->state->wrap == 1)
@@ -1145,9 +1102,9 @@ ZLIB_INTERNAL int read_buf(z_stream *strm, Byte *buf, unsigned size)
 /* ===========================================================================
  * Initialize the "longest match" routines for a new zlib stream
  */
-local void lm_init (deflate_state *s)
+static void lm_init(deflate_state *s)
 {
-    s->window_size = (ulg)2L*s->w_size;
+    s->window_size = (unsigned long)2L*s->w_size;
 
     CLEAR_HASH(s);
 
@@ -1171,11 +1128,14 @@ local void lm_init (deflate_state *s)
 /* ===========================================================================
  * Check that the match at match_start is indeed a match.
  */
-local void check_match(deflate_state *s, IPos start, IPos match, int length)
+static void check_match(deflate_state *s,
+                        IPos start,
+                        IPos match,
+                        int length)
 {
     /* check that the match is indeed a match */
     if (memcmp(s->window + match,
-                s->window + start, length) != EQUAL) {
+                s->window + start, length) != 0) {
         fprintf(stderr, " start %u, match %u, length %d\n",
                 start, match, length);
         do {
@@ -1205,9 +1165,9 @@ local void check_match(deflate_state *s, IPos start, IPos match, int length)
 #ifdef X86_SSE2_FILL_WINDOW
 extern void fill_window_sse(deflate_state *s);
 #endif
-local void fill_window_c(deflate_state *s);
+static void fill_window_c(deflate_state *s);
 
-local void fill_window(deflate_state *s)
+static void fill_window(deflate_state *s)
 {
 #ifdef X86_SSE2_FILL_WINDOW
 #ifndef X86_NOCHECK_SSE2
@@ -1223,24 +1183,24 @@ local void fill_window(deflate_state *s)
     fill_window_c(s);
 }
 
-local void fill_window_c(deflate_state *s)
+static void fill_window_c(deflate_state *s)
 {
-    register unsigned n;
-    register Pos *p;
-    unsigned more;    /* Amount of free space at the end of the window. */
-    uInt wsize = s->w_size;
+    unsigned int n;
+    Pos *p;
+    unsigned int more;    /* Amount of free space at the end of the window. */
+    unsigned int wsize = s->w_size;
 
     Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
 
     do {
-        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
+        more = (unsigned int)(s->window_size -(unsigned long)s->lookahead -(unsigned long)s->strstart);
 
         /* If the window is almost full and there is insufficient lookahead,
          * move the upper half to the lower one to make room in the upper half.
          */
         if (s->strstart >= wsize+MAX_DIST(s)) {
 
-            memcpy(s->window, s->window+wsize, (unsigned)wsize);
+            memcpy(s->window, s->window+wsize, (unsigned int)wsize);
             s->match_start -= wsize;
             s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
             s->block_start -= (long) wsize;
@@ -1255,7 +1215,7 @@ local void fill_window_c(deflate_state *s)
             p = &s->head[n];
 #ifdef NOT_TWEAK_COMPILER
             do {
-                unsigned m;
+                unsigned int m;
                 m = *--p;
                 *p = (Pos)(m >= wsize ? m-wsize : NIL);
             } while (--n);
@@ -1283,7 +1243,7 @@ local void fill_window_c(deflate_state *s)
             p = &s->prev[n];
 #ifdef NOT_TWEAK_COMPILER
             do {
-                unsigned m;
+                unsigned int m;
                 m = *--p;
                 *p = (Pos)(m >= wsize ? m-wsize : NIL);
                 /* If n is not on any hash chain, prev[n] is garbage but
@@ -1323,7 +1283,7 @@ local void fill_window_c(deflate_state *s)
 
         /* Initialize the hash value now that we have some input: */
         if (s->lookahead + s->insert >= MIN_MATCH) {
-            uInt str = s->strstart - s->insert;
+            unsigned int str = s->strstart - s->insert;
             s->ins_h = s->window[str];
             if (str >= 1)
                 UPDATE_HASH(s, s->ins_h, str + 1 - (MIN_MATCH-1));
@@ -1354,8 +1314,8 @@ local void fill_window_c(deflate_state *s)
      * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
      */
     if (s->high_water < s->window_size) {
-        ulg curr = s->strstart + (ulg)(s->lookahead);
-        ulg init;
+        unsigned long curr = s->strstart + (unsigned long)(s->lookahead);
+        unsigned long init;
 
         if (s->high_water < curr) {
             /* Previous high water mark below current data -- zero WIN_INIT
@@ -1364,23 +1324,23 @@ local void fill_window_c(deflate_state *s)
             init = s->window_size - curr;
             if (init > WIN_INIT)
                 init = WIN_INIT;
-            memset(s->window + curr, 0, (unsigned)init);
+            memset(s->window + curr, 0, (unsigned int)init);
             s->high_water = curr + init;
         }
-        else if (s->high_water < (ulg)curr + WIN_INIT) {
+        else if (s->high_water < (unsigned long)curr + WIN_INIT) {
             /* High water mark at or above current data, but below current data
              * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
              * to end of window, whichever is less.
              */
-            init = (ulg)curr + WIN_INIT - s->high_water;
+            init = (unsigned long)curr + WIN_INIT - s->high_water;
             if (init > s->window_size - s->high_water)
                 init = s->window_size - s->high_water;
-            memset(s->window + s->high_water, 0, (unsigned)init);
+            memset(s->window + s->high_water, 0, (unsigned int)init);
             s->high_water += init;
         }
     }
 
-    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
+    Assert((unsigned long)s->strstart <= s->window_size - MIN_LOOKAHEAD,
            "not enough room for search");
 }
 
@@ -1390,9 +1350,9 @@ local void fill_window_c(deflate_state *s)
  */
 #define FLUSH_BLOCK_ONLY(s, last) { \
    _tr_flush_block(s, (s->block_start >= 0L ? \
-                   (char *)&s->window[(unsigned)s->block_start] : \
-                   (char *)Z_NULL), \
-                (ulg)((long)s->strstart - s->block_start), \
+                   (char *)&s->window[(unsigned int)s->block_start] : \
+                   (char *)NULL), \
+                (unsigned long)((long)s->strstart - s->block_start), \
                 (last)); \
    s->block_start = s->strstart; \
    flush_pending(s->strm); \
@@ -1414,13 +1374,14 @@ local void fill_window_c(deflate_state *s)
  * NOTE: this function should be optimized to avoid extra copying from
  * window to pending_buf.
  */
-local block_state deflate_stored(deflate_state *s, int flush)
+static block_state deflate_stored(deflate_state *s,
+                                  int flush)
 {
     /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
      * to pending_buf_size, and each stored block has a 5 byte header:
      */
-    ulg max_block_size = 0xffff;
-    ulg max_start;
+    unsigned long max_block_size = 0xffff;
+    unsigned long max_start;
 
     if (max_block_size > s->pending_buf_size - 5) {
         max_block_size = s->pending_buf_size - 5;
@@ -1446,18 +1407,17 @@ local block_state deflate_stored(deflate_state *s, int flush)
 
         /* Emit a stored block if pending_buf will be full: */
         max_start = s->block_start + max_block_size;
-        if (s->strstart == 0 || (ulg)s->strstart >= max_start) {
+        if (s->strstart == 0 || (unsigned long)s->strstart >= max_start) {
             /* strstart == 0 is possible when wraparound on 16-bit machine */
-            s->lookahead = (uInt)(s->strstart - max_start);
-            s->strstart = (uInt)max_start;
+            s->lookahead = (unsigned int)(s->strstart - max_start);
+            s->strstart = (unsigned int)max_start;
             FLUSH_BLOCK(s, 0);
         }
         /* Flush if we may have to slide, otherwise block_start may become
          * negative and the data will be gone:
          */
-        if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {
+        if (s->strstart - (unsigned int)s->block_start >= MAX_DIST(s))
             FLUSH_BLOCK(s, 0);
-        }
     }
     s->insert = 0;
     if (flush == Z_FINISH) {
@@ -1476,7 +1436,8 @@ local block_state deflate_stored(deflate_state *s, int flush)
  * new strings in the dictionary only for unmatched strings or for short
  * matches. It is used only for the fast compression options.
  */
-local block_state deflate_fast(deflate_state *s, int flush)
+static block_state deflate_fast(deflate_state *s,
+                                int flush)
 {
     IPos hash_head;       /* head of the hash chain */
     int bflush;           /* set if current block must be flushed */
@@ -1578,7 +1539,8 @@ local block_state deflate_fast(deflate_state *s, int flush)
  * evaluation for matches: a match is finally adopted only if there is
  * no better match at the next window position.
  */
-local block_state deflate_slow(deflate_state *s, int flush)
+static block_state deflate_slow(deflate_state *s,
+                                int flush)
 {
     IPos hash_head;          /* head of hash chain */
     int bflush;              /* set if current block must be flushed */
@@ -1637,7 +1599,7 @@ local block_state deflate_slow(deflate_state *s, int flush)
          * match is not better, output the previous match:
          */
         if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
-            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
+            unsigned int max_insert = s->strstart + s->lookahead - MIN_MATCH;
             /* Do not insert strings in hash table beyond this. */
 
             check_match(s, s->strstart-1, s->prev_match, s->prev_length);
@@ -1664,8 +1626,8 @@ local block_state deflate_slow(deflate_state *s, int flush)
             s->strstart++;
 #else
             {
-                uInt mov_fwd = s->prev_length - 2;
-                uInt insert_cnt = mov_fwd;
+                unsigned int mov_fwd = s->prev_length - 2;
+                unsigned int insert_cnt = mov_fwd;
                 if (unlikely(insert_cnt > max_insert - s->strstart))
                     insert_cnt = max_insert - s->strstart;
 
@@ -1722,11 +1684,12 @@ local block_state deflate_slow(deflate_state *s, int flush)
  * one.  Do not maintain a hash table.  (It will be regenerated if this run of
  * deflate switches away from Z_RLE.)
  */
-local block_state deflate_rle(deflate_state *s, int flush)
+static block_state deflate_rle(deflate_state *s,
+                               int flush)
 {
     int bflush;             /* set if current block must be flushed */
-    uInt prev;              /* byte at distance one to match */
-    Byte *scan, *strend;   /* scan goes up to strend for length of run */
+    unsigned int prev;      /* byte at distance one to match */
+    unsigned char *scan, *strend;   /* scan goes up to strend for length of run */
 
     for (;;) {
         /* Make sure that we always have enough lookahead, except
@@ -1758,7 +1721,7 @@ local block_state deflate_rle(deflate_state *s, int flush)
                 if (s->match_length > s->lookahead)
                     s->match_length = s->lookahead;
             }
-            Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
+            Assert(scan <= s->window+(unsigned int)(s->window_size-1), "wild scan");
         }
 
         /* Emit match if have run of MIN_MATCH or longer, else emit literal */
@@ -1793,7 +1756,8 @@ local block_state deflate_rle(deflate_state *s, int flush)
  * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
  * (It will be regenerated if this run of deflate switches away from Huffman.)
  */
-local block_state deflate_huff(deflate_state *s, int flush)
+static block_state deflate_huff(deflate_state *s,
+                                int flush)
 {
     int bflush;             /* set if current block must be flushed */
 
diff --git a/deflate.h b/deflate.h
index a76a94d..f5688ca 100644
--- a/deflate.h
+++ b/deflate.h
@@ -15,14 +15,6 @@
 
 #include "zutil.h"
 
-/* define NO_GZIP when compiling if you want to disable gzip header and
-   trailer creation by deflate().  NO_GZIP would be used to avoid linking in
-   the crc code when it is not needed.  For shared libraries, gzip encoding
-   should be left enabled. */
-#ifndef NO_GZIP
-#  define GZIP
-#endif
-
 #define NIL 0
 /* Tail of hash chains */
 
@@ -71,12 +63,12 @@
 /* Data structure describing a single value and its code string. */
 typedef struct ct_data_s {
     union {
-        ush  freq;       /* frequency count */
-        ush  code;       /* bit string */
+        unsigned short  freq;       /* frequency count */
+        unsigned short  code;       /* bit string */
     } fc;
     union {
-        ush  dad;        /* father node in Huffman tree */
-        ush  len;        /* length of bit string */
+        unsigned short  dad;        /* father node in Huffman tree */
+        unsigned short  len;        /* length of bit string */
     } dl;
 } ct_data;
 
@@ -93,47 +85,47 @@ typedef struct tree_desc_s {
     static_tree_desc *stat_desc; /* the corresponding static tree */
 } tree_desc;
 
-typedef ush Pos;
-typedef unsigned IPos;
+typedef unsigned short Pos;
+typedef unsigned int IPos;
 
 /* A Pos is an index in the character window. We use short instead of int to
  * save space in the various tables. IPos is used only for parameter passing.
  */
 
 typedef struct internal_state {
-    z_stream *strm;      /* pointer back to this zlib stream */
-    int   status;        /* as the name implies */
-    Byte *pending_buf;  /* output still pending */
-    ulg   pending_buf_size; /* size of pending_buf */
-    Byte *pending_out;  /* next pending byte to output to the stream */
-    uInt   pending;      /* nb of bytes in the pending buffer */
-    int   wrap;          /* bit 0 true for zlib, bit 1 true for gzip */
-    gz_headerp  gzhead;  /* gzip header information to write */
-    uInt   gzindex;      /* where in extra, name, or comment */
-    Byte  method;        /* can only be DEFLATED */
-    int   last_flush;    /* value of flush param for previous deflate call */
+    z_stream      *strm;             /* pointer back to this zlib stream */
+    int            status;           /* as the name implies */
+    unsigned char *pending_buf;      /* output still pending */
+    unsigned long  pending_buf_size; /* size of pending_buf */
+    unsigned char *pending_out;      /* next pending byte to output to the stream */
+    unsigned int   pending;          /* nb of bytes in the pending buffer */
+    int            wrap;             /* bit 0 true for zlib, bit 1 true for gzip */
+    gz_header*     gzhead;           /* gzip header information to write */
+    unsigned int   gzindex;          /* where in extra, name, or comment */
+    unsigned char  method;           /* can only be DEFLATED */
+    int            last_flush;       /* value of flush param for previous deflate call */
 
 #ifdef X86_PCLMULQDQ_CRC
-    unsigned __attribute__((aligned(16))) crc0[4 * 5];
+    unsigned int __attribute__((aligned(16))) crc0[4 * 5];
 #endif
 
                 /* used by deflate.c: */
 
-    uInt  w_size;        /* LZ77 window size (32K by default) */
-    uInt  w_bits;        /* log2(w_size)  (8..16) */
-    uInt  w_mask;        /* w_size - 1 */
+    unsigned int  w_size; /* LZ77 window size (32K by default) */
+    unsigned int  w_bits; /* log2(w_size)  (8..16) */
+    unsigned int  w_mask; /* w_size - 1 */
 
-    Byte *window;
+    unsigned char *window;
     /* Sliding window. Input bytes are read into the second half of the window,
      * and move to the first half later to keep a dictionary of at least wSize
      * bytes. With this organization, matches are limited to a distance of
      * wSize-MAX_MATCH bytes, but this ensures that IO is always
      * performed with a length multiple of the block size. Also, it limits
-     * the window size to 64K, which is quite useful on MSDOS.
+     * the window size to 64K.
      * To do: use the user input buffer as sliding window.
      */
 
-    ulg window_size;
+    unsigned long window_size;
     /* Actual size of window: 2*wSize, except when the user input buffer
      * is directly used as sliding window.
      */
@@ -146,12 +138,12 @@ typedef struct internal_state {
 
     Pos *head; /* Heads of the hash chains or NIL. */
 
-    uInt  ins_h;          /* hash index of string to be inserted */
-    uInt  hash_size;      /* number of elements in hash table */
-    uInt  hash_bits;      /* log2(hash_size) */
-    uInt  hash_mask;      /* hash_size-1 */
+    unsigned int  ins_h;          /* hash index of string to be inserted */
+    unsigned int  hash_size;      /* number of elements in hash table */
+    unsigned int  hash_bits;      /* log2(hash_size) */
+    unsigned int  hash_mask;      /* hash_size-1 */
 
-    uInt  hash_shift;
+    unsigned int  hash_shift;
     /* Number of bits by which ins_h must be shifted at each input
      * step. It must be such that after MIN_MATCH steps, the oldest
      * byte no longer takes part in the hash key, that is:
@@ -163,25 +155,25 @@ typedef struct internal_state {
      * negative when the window is moved backwards.
      */
 
-    uInt match_length;           /* length of best match */
-    IPos prev_match;             /* previous match */
-    int match_available;         /* set if previous match exists */
-    uInt strstart;               /* start of string to insert */
-    uInt match_start;            /* start of matching string */
-    uInt lookahead;              /* number of valid bytes ahead in window */
+    unsigned int match_length;    /* length of best match */
+    IPos         prev_match;      /* previous match */
+    int          match_available; /* set if previous match exists */
+    unsigned int strstart;        /* start of string to insert */
+    unsigned int match_start;     /* start of matching string */
+    unsigned int lookahead;       /* number of valid bytes ahead in window */
 
-    uInt prev_length;
+    unsigned int prev_length;
     /* Length of the best match at previous step. Matches not greater than this
      * are discarded. This is used in the lazy match evaluation.
      */
 
-    uInt max_chain_length;
+    unsigned int max_chain_length;
     /* To speed up deflation, hash chains are never searched beyond this
      * length.  A higher limit improves compression ratio but degrades the
      * speed.
      */
 
-    uInt max_lazy_match;
+    unsigned int max_lazy_match;
     /* Attempt to find a better match only when the current match is strictly
      * smaller than this value. This mechanism is used only for compression
      * levels >= 4.
@@ -195,7 +187,7 @@ typedef struct internal_state {
     int level;    /* compression level (1..9) */
     int strategy; /* favor or force Huffman coding*/
 
-    uInt good_match;
+    unsigned int good_match;
     /* Use a faster search when the previous match is longer than this */
 
     int nice_match; /* Stop searching when current match exceeds this */
@@ -210,7 +202,7 @@ typedef struct internal_state {
     struct tree_desc_s d_desc;               /* desc. for distance tree */
     struct tree_desc_s bl_desc;              /* desc. for bit length tree */
 
-    ush bl_count[MAX_BITS+1];
+    unsigned short bl_count[MAX_BITS+1];
     /* number of codes at each bit length for an optimal tree */
 
     int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
@@ -220,13 +212,13 @@ typedef struct internal_state {
      * The same heap array is used to build all trees.
      */
 
-    uch depth[2*L_CODES+1];
+    unsigned char depth[2*L_CODES+1];
     /* Depth of each subtree used as tie breaker for trees of equal frequency
      */
 
-    uch *l_buf;          /* buffer for literals or lengths */
+    unsigned char *l_buf;          /* buffer for literals or lengths */
 
-    uInt  lit_bufsize;
+    unsigned int lit_bufsize;
     /* Size of match buffer for literals/lengths.  There are 4 reasons for
      * limiting lit_bufsize to 64K:
      *   - frequencies can be kept in 16 bit counters
@@ -246,25 +238,25 @@ typedef struct internal_state {
      *   - I can't count above 4
      */
 
-    uInt last_lit;      /* running index in l_buf */
+    unsigned int last_lit;      /* running index in l_buf */
 
-    ush *d_buf;
+    unsigned short *d_buf;
     /* Buffer for distances. To simplify the code, d_buf and l_buf have
      * the same number of elements. To use different lengths, an extra flag
      * array would be necessary.
      */
 
-    ulg opt_len;        /* bit length of current block with optimal trees */
-    ulg static_len;     /* bit length of current block with static trees */
-    uInt matches;       /* number of string matches in current block */
-    uInt insert;        /* bytes at end of window left to insert */
+    unsigned long opt_len;    /* bit length of current block with optimal trees */
+    unsigned long static_len; /* bit length of current block with static trees */
+    unsigned int  matches;    /* number of string matches in current block */
+    unsigned int  insert;     /* bytes at end of window left to insert */
 
 #ifdef DEBUG
-    ulg compressed_len; /* total bit length of compressed file mod 2^32 */
-    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */
+    unsigned long compressed_len; /* total bit length of compressed file mod 2^32 */
+    unsigned long bits_sent;      /* bit length of compressed data sent mod 2^32 */
 #endif
 
-    ush bi_buf;
+    unsigned short bi_buf;
     /* Output buffer. bits are inserted starting at the bottom (least
      * significant bits).
      */
@@ -273,7 +265,7 @@ typedef struct internal_state {
      * are always zero.
      */
 
-    ulg high_water;
+    unsigned long high_water;
     /* High water mark offset in window for initialized bytes -- bytes above
      * this are set to zero in order to avoid memory check warnings when
      * longest match routines access bytes past the input.  This is then
@@ -310,12 +302,12 @@ typedef enum {
  */
 #define put_short(s, w) { \
     s->pending += 2; \
-    *(ush*)(&s->pending_buf[s->pending - 2]) = (w) ; \
+    *(unsigned short*)(&s->pending_buf[s->pending - 2]) = (w) ; \
 }
 #else
 #define put_short(s, w) { \
-    put_byte(s, (uch)((w) & 0xff)); \
-    put_byte(s, (uch)((ush)(w) >> 8)); \
+    put_byte(s, (unsigned char)((w) & 0xff)); \
+    put_byte(s, (unsigned char)((unsigned short)(w) >> 8)); \
 }
 #endif
 
@@ -334,13 +326,13 @@ typedef enum {
    memory checker errors from longest match routines */
 
         /* in trees.c */
-void ZLIB_INTERNAL _tr_init (deflate_state *s);
-int ZLIB_INTERNAL _tr_tally (deflate_state *s, unsigned dist, unsigned lc);
-void ZLIB_INTERNAL _tr_flush_block (deflate_state *s, char *buf, ulg stored_len, int last);
-void ZLIB_INTERNAL _tr_flush_bits (deflate_state *s);
+void ZLIB_INTERNAL _tr_init(deflate_state *s);
+int ZLIB_INTERNAL _tr_tally(deflate_state *s, unsigned int dist, unsigned int lc);
+void ZLIB_INTERNAL _tr_flush_block(deflate_state *s, char *buf, unsigned long stored_len, int last);
+void ZLIB_INTERNAL _tr_flush_bits(deflate_state *s);
 void ZLIB_INTERNAL _tr_align (deflate_state *s);
-void ZLIB_INTERNAL _tr_stored_block (deflate_state *s, char *buf, ulg stored_len, int last);
-void ZLIB_INTERNAL bi_windup (deflate_state *s);
+void ZLIB_INTERNAL _tr_stored_block(deflate_state *s, char *buf, unsigned long stored_len, int last);
+void ZLIB_INTERNAL bi_windup(deflate_state *s);
 
 #define d_code(dist) \
    ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>7)])
@@ -352,24 +344,19 @@ void ZLIB_INTERNAL bi_windup (deflate_state *s);
 #ifndef DEBUG
 /* Inline versions of _tr_tally for speed: */
 
-#if defined(GEN_TREES_H)
-  extern uch ZLIB_INTERNAL _length_code[];
-  extern uch ZLIB_INTERNAL _dist_code[];
-#else
-  extern const uch ZLIB_INTERNAL _length_code[];
-  extern const uch ZLIB_INTERNAL _dist_code[];
-#endif
+extern const unsigned char ZLIB_INTERNAL _length_code[];
+extern const unsigned char ZLIB_INTERNAL _dist_code[];
 
 # define _tr_tally_lit(s, c, flush) \
-  { uch cc = (c); \
+  { unsigned char cc = (c); \
     s->d_buf[s->last_lit] = 0; \
     s->l_buf[s->last_lit++] = cc; \
     s->dyn_ltree[cc].Freq++; \
     flush = (s->last_lit == s->lit_bufsize-1); \
    }
 # define _tr_tally_dist(s, distance, length, flush) \
-  { uch len = (length); \
-    ush dist = (distance); \
+  { unsigned char len = (length); \
+    unsigned short dist = (distance); \
     s->d_buf[s->last_lit] = dist; \
     s->l_buf[s->last_lit++] = len; \
     dist--; \
@@ -421,25 +408,25 @@ void ZLIB_INTERNAL bi_windup (deflate_state *s);
  * Send a value on a given number of bits.
  * IN assertion: length <= 16 and value fits in length bits.
  */
-local void send_bits(deflate_state *s,
-                     int value,  /* value to send */
-                     int length  /* number of bits */
+static void send_bits(deflate_state *s,
+                      int value,  /* value to send */
+                      int length  /* number of bits */
 {
     Tracevv((stderr," l %2d v %4x ", length, value));
     Assert(length > 0 && length <= 15, "invalid length");
-    s->bits_sent += (ulg)length;
+    s->bits_sent += (unsigned long)length;
 
     /* If not enough room in bi_buf, use (valid) bits from bi_buf and
      * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
      * unused bits in value.
      */
     if (s->bi_valid > (int)Buf_size - length) {
-        s->bi_buf |= (ush)value << s->bi_valid;
+        s->bi_buf |= (unsigned short)value << s->bi_valid;
         put_short(s, s->bi_buf);
-        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
+        s->bi_buf = (unsigned short)value >> (Buf_size - s->bi_valid);
         s->bi_valid += length - Buf_size;
     } else {
-        s->bi_buf |= (ush)value << s->bi_valid;
+        s->bi_buf |= (unsigned short)value << s->bi_valid;
         s->bi_valid += length;
     }
 }
@@ -448,12 +435,12 @@ local void send_bits(deflate_state *s,
 { int len = length;\
   if (s->bi_valid > (int)Buf_size - len) {\
     int val = value;\
-    s->bi_buf |= (ush)val << s->bi_valid;\
+    s->bi_buf |= (unsigned short)val << s->bi_valid;\
     put_short(s, s->bi_buf);\
-    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
+    s->bi_buf = (unsigned short)val >> (Buf_size - s->bi_valid);\
     s->bi_valid += len - Buf_size;\
   } else {\
-    s->bi_buf |= (ush)(value) << s->bi_valid;\
+    s->bi_buf |= (unsigned short)(value) << s->bi_valid;\
     s->bi_valid += len;\
   }\
 }
diff --git a/deflate_medium.c b/deflate_medium.c
index 0d4d98a..cdebd1c 100644
--- a/deflate_medium.c
+++ b/deflate_medium.c
@@ -10,10 +10,10 @@
 #include "deflate.h"
 
 struct match {
-    uInt    match_start;
-    uInt    match_length;    
-    uInt    strstart;
-    uInt    orgstart;
+    unsigned int    match_start;
+    unsigned int    match_length;    
+    unsigned int    strstart;
+    unsigned int    orgstart;
 };
 
 #define MAX_DIST2  ((1 << MAX_WBITS) - MIN_LOOKAHEAD)
diff --git a/gzclose.c b/gzclose.c
index caeb99a..e96442b 100644
--- a/gzclose.c
+++ b/gzclose.c
@@ -8,18 +8,13 @@
 /* gzclose() is in a separate file so that it is linked in only if it is used.
    That way the other gzclose functions can be used instead to avoid linking in
    unneeded compression or decompression routines. */
-int ZEXPORT gzclose(file)
-    gzFile file;
+int ZEXPORT gzclose(gzFile file)
 {
-#ifndef NO_GZCOMPRESS
-    gz_statep state;
+    gz_state *state;
 
     if (file == NULL)
         return Z_STREAM_ERROR;
-    state = (gz_statep)file;
+    state = (gz_state *)file;
 
     return state->mode == GZ_READ ? gzclose_r(file) : gzclose_w(file);
-#else
-    return gzclose_r(file);
-#endif
 }
diff --git a/gzguts.h b/gzguts.h
index 5bbd15c..5067c57 100644
--- a/gzguts.h
+++ b/gzguts.h
@@ -3,89 +3,21 @@
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
-#ifdef _LARGEFILE64_SOURCE
-#  ifndef _LARGEFILE_SOURCE
-#    define _LARGEFILE_SOURCE 1
-#  endif
-#  ifdef _FILE_OFFSET_BITS
-#    undef _FILE_OFFSET_BITS
-#  endif
-#endif
-
-#ifdef HAVE_HIDDEN
+#if defined(HAVE_HIDDEN) && !defined(_WIN32)
 #  define ZLIB_INTERNAL __attribute__((visibility ("hidden")))
 #else
 #  define ZLIB_INTERNAL
 #endif
 
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
 #include <stdio.h>
-#include "zlib.h"
-#include <string.h>
 #include <stdlib.h>
-#include <limits.h>
-#include <fcntl.h>
-
-#ifdef _WIN32
-#  include <stddef.h>
-#endif
-
-#if defined(_MSC_VER) || defined(_WIN32)
-#  include <io.h>
-#endif
-
-#ifdef WINAPI_FAMILY
-#  define open _open
-#  define read _read
-#  define write _write
-#  define close _close
-#endif
-
-#ifdef NO_DEFLATE       /* for compatibility with old definition */
-#  define NO_GZCOMPRESS
-#endif
-
-/* In Win32, vsnprintf is available as the "non-ANSI" _vsnprintf. */
-#if !defined(STDC99) && !defined(__CYGWIN__) && defined(WIN32)
-#  if !defined(vsnprintf)
-#    if !defined(_MSC_VER) || ( defined(_MSC_VER) && _MSC_VER < 1500 )
-#       define vsnprintf _vsnprintf
-#    endif
-#  endif
-#endif
-
-/* unlike snprintf (which is required in C99, yet still not supported by
-   Microsoft more than a decade later!), _snprintf does not guarantee null
-   termination of the result -- however this is only used in gzlib.c where
-   the result is assured to fit in the space provided */
-#ifdef _MSC_VER
-#  define snprintf _snprintf
-#endif
-
-#ifndef local
-#  define local static
-#endif
-/* compile with -Dlocal if your debugger can't find static symbols */
-
-/* get errno and strerror definition */
-#if defined UNDER_CE
-#  include <windows.h>
-#  define zstrerror() gz_strwinerror((DWORD)GetLastError())
-#else
-#  ifndef NO_STRERROR
-#    include <errno.h>
-#    define zstrerror() strerror(errno)
-#  else
-#    define zstrerror() "stdio error (consult errno)"
-#  endif
-#endif
+#include <string.h>
+#include <unistd.h>
 
-/* provide prototypes for these when building zlib without LFS */
-#if !defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0
-    ZEXTERN gzFile ZEXPORT gzopen64 (const char *, const char *);
-    ZEXTERN z_off64_t ZEXPORT gzseek64 (gzFile, z_off64_t, int);
-    ZEXTERN z_off64_t ZEXPORT gztell64 (gzFile);
-    ZEXTERN z_off64_t ZEXPORT gzoffset64 (gzFile);
-#endif
+#include "zlib.h"
 
 /* default memLevel */
 #if MAX_MEM_LEVEL >= 8
@@ -109,6 +41,14 @@
 #define COPY 1      /* copy input directly */
 #define GZIP 2      /* decompress a gzip stream */
 
+/* zlib exposes this as part of its ABI via the gzgetc() macro that has been
+   removed from this libz. We keep it this way for zlib ABI compatibility. */
+struct gzFile_s {
+    unsigned int have;
+    unsigned char *next;
+    off_t pos;
+};
+
 /* internal gzip file state data structure */
 typedef struct {
         /* exposed contents for gzgetc() macro */
@@ -120,21 +60,21 @@ typedef struct {
     int mode;               /* see gzip modes above */
     int fd;                 /* file descriptor */
     char *path;             /* path or fd for error messages */
-    unsigned size;          /* buffer size, zero if not allocated yet */
-    unsigned want;          /* requested buffer size, default is GZBUFSIZE */
+    unsigned int size;      /* buffer size, zero if not allocated yet */
+    unsigned int want;      /* requested buffer size, default is GZBUFSIZE */
     unsigned char *in;      /* input buffer */
     unsigned char *out;     /* output buffer (double-sized when reading) */
     int direct;             /* 0 if processing gzip, 1 if transparent */
         /* just for reading */
     int how;                /* 0: get header, 1: copy, 2: decompress */
-    z_off64_t start;        /* where the gzip data started, for rewinding */
+    off_t start;            /* where the gzip data started, for rewinding */
     int eof;                /* true if end of input file reached */
     int past;               /* true if read requested past end */
         /* just for writing */
     int level;              /* compression level */
     int strategy;           /* compression strategy */
         /* seek request */
-    z_off64_t skip;         /* amount to skip (already rewound if backwards) */
+    off_t skip;             /* amount to skip (already rewound if backwards) */
     int seek;               /* true if seek request pending */
         /* error information */
     int err;                /* error code */
@@ -145,17 +85,8 @@ typedef struct {
 typedef gz_state *gz_statep;
 
 /* shared functions */
-void ZLIB_INTERNAL gz_error (gz_statep, int, const char *);
-#if defined UNDER_CE
-char ZLIB_INTERNAL *gz_strwinerror (DWORD error);
-#endif
+void ZLIB_INTERNAL gz_error(gz_statep, int, const char *);
 
-/* GT_OFF(x), where x is an unsigned value, is true if x > maximum z_off64_t
-   value -- needed when comparing unsigned to z_off64_t, which is signed
-   (possible z_off64_t types off_t, off64_t, and long are all signed) */
-#ifdef INT_MAX
-#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > INT_MAX)
-#else
-unsigned ZLIB_INTERNAL gz_intmax (void);
-#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > gz_intmax())
-#endif
+/* GT_OFF(x), where x is an unsigned value, is true if x > maximum off_t
+   value -- needed when comparing unsigned to off_t, which is signed. */
+# define GT_OFF(x) (sizeof(int) == sizeof(off_t) && (x) > INT_MAX)
diff --git a/gzlib.c b/gzlib.c
index 028a2d3..ffe504a 100644
--- a/gzlib.c
+++ b/gzlib.c
@@ -5,73 +5,8 @@
 
 #include "gzguts.h"
 
-#if defined(_WIN32) && !defined(__BORLANDC__)
-#  define LSEEK _lseeki64
-#else
-#if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0
-#  define LSEEK lseek64
-#else
-#  define LSEEK lseek
-#endif
-#endif
-
-/* Local functions */
-local void gz_reset (gz_statep);
-local gzFile gz_open (const void *, int, const char *);
-
-#if defined UNDER_CE
-
-/* Map the Windows error number in ERROR to a locale-dependent error message
-   string and return a pointer to it.  Typically, the values for ERROR come
-   from GetLastError.
-
-   The string pointed to shall not be modified by the application, but may be
-   overwritten by a subsequent call to gz_strwinerror
-
-   The gz_strwinerror function does not change the current setting of
-   GetLastError. */
-char ZLIB_INTERNAL *gz_strwinerror (DWORD error)
-{
-    static char buf[1024];
-
-    wchar_t *msgbuf;
-    DWORD lasterr = GetLastError();
-    DWORD chars = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
-        | FORMAT_MESSAGE_ALLOCATE_BUFFER,
-        NULL,
-        error,
-        0, /* Default language */
-        (LPVOID)&msgbuf,
-        0,
-        NULL);
-    if (chars != 0) {
-        /* If there is an \r\n appended, zap it.  */
-        if (chars >= 2
-            && msgbuf[chars - 2] == '\r' && msgbuf[chars - 1] == '\n') {
-            chars -= 2;
-            msgbuf[chars] = 0;
-        }
-
-        if (chars > sizeof (buf) - 1) {
-            chars = sizeof (buf) - 1;
-            msgbuf[chars] = 0;
-        }
-
-        wcstombs(buf, msgbuf, chars + 1);
-        LocalFree(msgbuf);
-    }
-    else {
-        sprintf(buf, "unknown win32 error (%ld)", error);
-    }
-
-    SetLastError(lasterr);
-    return buf;
-}
-
-#endif /* UNDER_CE */
-
 /* Reset gzip file state */
-local void gz_reset(gz_statep state)
+static void gz_reset(gz_state *state)
 {
     state->x.have = 0;              /* no output data available */
     if (state->mode == GZ_READ) {   /* for reading ... */
@@ -86,10 +21,11 @@ local void gz_reset(gz_statep state)
 }
 
 /* Open a gzip file either by name or file descriptor. */
-local gzFile gz_open(const void *path, int fd, const char *mode)
+static gzFile gz_open(const char *path,
+                      int fd,
+                      const char* mode)
 {
-    gz_statep state;
-    size_t len;
+    gz_state *state;
     int oflag;
 #ifdef O_CLOEXEC
     int cloexec = 0;
@@ -103,7 +39,7 @@ local gzFile gz_open(const void *path, int fd, const char *mode)
         return NULL;
 
     /* allocate gzFile structure to return */
-    state = (gz_statep)malloc(sizeof(gz_state));
+    state = (gz_state *)malloc(sizeof(gz_state));
     if (state == NULL)
         return NULL;
     state->size = 0;            /* no buffers allocated yet */
@@ -123,14 +59,12 @@ local gzFile gz_open(const void *path, int fd, const char *mode)
             case 'r':
                 state->mode = GZ_READ;
                 break;
-#ifndef NO_GZCOMPRESS
             case 'w':
                 state->mode = GZ_WRITE;
                 break;
             case 'a':
                 state->mode = GZ_APPEND;
                 break;
-#endif
             case '+':       /* can't read and write at the same time */
                 free(state);
                 return NULL;
@@ -183,35 +117,14 @@ local gzFile gz_open(const void *path, int fd, const char *mode)
     }
 
     /* save the path name for error messages */
-#ifdef _WIN32
-    if (fd == -2) {
-        len = wcstombs(NULL, path, 0);
-        if (len == (size_t)-1)
-            len = 0;
-    }
-    else
-#endif
-        len = strlen((const char *)path);
-    state->path = (char *)malloc(len + 1);
+    state->path = strdup(path);
     if (state->path == NULL) {
         free(state);
         return NULL;
     }
-#ifdef _WIN32
-    if (fd == -2)
-        if (len)
-            wcstombs(state->path, path, len + 1);
-        else
-            *(state->path) = 0;
-    else
-#endif
-        snprintf(state->path, len + 1, "%s", (const char *)path);
 
     /* compute the flags for open() */
     oflag =
-#ifdef O_LARGEFILE
-        O_LARGEFILE |
-#endif
 #ifdef O_BINARY
         O_BINARY |
 #endif
@@ -229,11 +142,7 @@ local gzFile gz_open(const void *path, int fd, const char *mode)
            O_APPEND)));
 
     /* open the file with the appropriate flags (or just use fd) */
-    state->fd = fd > -1 ? fd : (
-#ifdef _WIN32
-        fd == -2 ? _wopen(path, oflag, 0666) :
-#endif
-        open((const char *)path, oflag, 0666));
+    state->fd = fd >= 0 ? fd : open(path, oflag, 0666);
     if (state->fd == -1) {
         free(state->path);
         free(state);
@@ -244,7 +153,7 @@ local gzFile gz_open(const void *path, int fd, const char *mode)
 
     /* save the current position for rewinding (only if reading) */
     if (state->mode == GZ_READ) {
-        state->start = LSEEK(state->fd, 0, SEEK_CUR);
+        state->start = lseek(state->fd, 0, SEEK_CUR);
         if (state->start == -1) state->start = 0;
     }
 
@@ -256,58 +165,46 @@ local gzFile gz_open(const void *path, int fd, const char *mode)
 }
 
 /* -- see zlib.h -- */
-gzFile ZEXPORT gzopen(path, mode)
-    const char *path;
-    const char *mode;
+gzFile ZEXPORT gzopen(const char *path,
+                      const char *mode)
 {
     return gz_open(path, -1, mode);
 }
 
 /* -- see zlib.h -- */
-gzFile ZEXPORT gzopen64(path, mode)
-    const char *path;
-    const char *mode;
+gzFile ZEXPORT gzopen64(const char *path,
+                        const char *mode)
 {
     return gz_open(path, -1, mode);
 }
 
 /* -- see zlib.h -- */
-gzFile ZEXPORT gzdopen(fd, mode)
-    int fd;
-    const char *mode;
+gzFile ZEXPORT gzdopen(int fd,
+                       const char *mode)
 {
-    char *path;         /* identifier for error messages */
-    gzFile gz;
+    if ( fd < 0 )
+        return NULL;
 
-    if (fd == -1 || (path = (char *)malloc(7 + 3 * sizeof(int))) == NULL)
+    char* path;
+    if ( asprintf(&path, "<fd:%d>", fd) < 0 )
         return NULL;
-    snprintf(path, 7 + 3 * sizeof(int), "<fd:%d>", fd); /* for debugging */
-    gz = gz_open(path, fd, mode);
+
+    gzFile gz = gz_open(path, fd, mode);
+
     free(path);
     return gz;
 }
 
 /* -- see zlib.h -- */
-#ifdef _WIN32
-gzFile ZEXPORT gzopen_w(path, mode)
-    const wchar_t *path;
-    const char *mode;
+int ZEXPORT gzbuffer(gzFile file,
+                     unsigned int size)
 {
-    return gz_open(path, -2, mode);
-}
-#endif
-
-/* -- see zlib.h -- */
-int ZEXPORT gzbuffer(file, size)
-    gzFile file;
-    unsigned size;
-{
-    gz_statep state;
+    gz_state *state;
 
     /* get internal structure and check integrity */
     if (file == NULL)
         return -1;
-    state = (gz_statep)file;
+    state = (gz_state *)file;
     if (state->mode != GZ_READ && state->mode != GZ_WRITE)
         return -1;
 
@@ -323,15 +220,14 @@ int ZEXPORT gzbuffer(file, size)
 }
 
 /* -- see zlib.h -- */
-int ZEXPORT gzrewind(file)
-    gzFile file;
+int ZEXPORT gzrewind(gzFile file)
 {
-    gz_statep state;
+    gz_state *state;
 
     /* get internal structure */
     if (file == NULL)
         return -1;
-    state = (gz_statep)file;
+    state = (gz_state *)file;
 
     /* check that we're reading and that there's no error */
     if (state->mode != GZ_READ ||
@@ -339,26 +235,25 @@ int ZEXPORT gzrewind(file)
         return -1;
 
     /* back up and start over */
-    if (LSEEK(state->fd, state->start, SEEK_SET) == -1)
+    if (lseek(state->fd, state->start, SEEK_SET) == -1)
         return -1;
     gz_reset(state);
     return 0;
 }
 
 /* -- see zlib.h -- */
-z_off64_t ZEXPORT gzseek64(file, offset, whence)
-    gzFile file;
-    z_off64_t offset;
-    int whence;
+off_t ZEXPORT gzseek64(gzFile file,
+                       off_t offset,
+                       int whence)
 {
-    unsigned n;
-    z_off64_t ret;
-    gz_statep state;
+    unsigned int n;
+    off_t ret;
+    gz_state *state;
 
     /* get internal structure and check integrity */
     if (file == NULL)
         return -1;
-    state = (gz_statep)file;
+    state = (gz_state *)file;
     if (state->mode != GZ_READ && state->mode != GZ_WRITE)
         return -1;
 
@@ -380,7 +275,7 @@ z_off64_t ZEXPORT gzseek64(file, offset, whence)
     /* if within raw area while reading, just go there */
     if (state->mode == GZ_READ && state->how == COPY &&
             state->x.pos + offset >= 0) {
-        ret = LSEEK(state->fd, offset - state->x.have, SEEK_CUR);
+        ret = lseek(state->fd, offset - state->x.have, SEEK_CUR);
         if (ret == -1)
             return -1;
         state->x.have = 0;
@@ -406,8 +301,8 @@ z_off64_t ZEXPORT gzseek64(file, offset, whence)
 
     /* if reading, skip what's in output buffer (one less gzgetc() check) */
     if (state->mode == GZ_READ) {
-        n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?
-            (unsigned)offset : state->x.have;
+        n = GT_OFF(state->x.have) || (off_t)state->x.have > offset ?
+            (unsigned int)offset : state->x.have;
         state->x.have -= n;
         state->x.next += n;
         state->x.pos += n;
@@ -423,27 +318,31 @@ z_off64_t ZEXPORT gzseek64(file, offset, whence)
 }
 
 /* -- see zlib.h -- */
-z_off_t ZEXPORT gzseek(file, offset, whence)
-    gzFile file;
-    z_off_t offset;
-    int whence;
+off_t ZEXPORT gzseek(gzFile file,
+                               off_t offset,
+                               int whence)
 {
-    z_off64_t ret;
+    off_t ret;
+    off_t prev;
 
-    ret = gzseek64(file, (z_off64_t)offset, whence);
-    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
+    prev = gzseek64(file, 0, SEEK_CUR);
+    ret = gzseek64(file, offset, whence);
+    if (ret != (off_t) ret) {
+        gzseek64(file, prev, SEEK_SET);
+        return -1;
+    }
+    return (off_t)ret;
 }
 
 /* -- see zlib.h -- */
-z_off64_t ZEXPORT gztell64(file)
-    gzFile file;
+off_t ZEXPORT gztell64(gzFile file)
 {
-    gz_statep state;
+    gz_state *state;
 
     /* get internal structure and check integrity */
     if (file == NULL)
         return -1;
-    state = (gz_statep)file;
+    state = (gz_state *)file;
     if (state->mode != GZ_READ && state->mode != GZ_WRITE)
         return -1;
 
@@ -452,31 +351,29 @@ z_off64_t ZEXPORT gztell64(file)
 }
 
 /* -- see zlib.h -- */
-z_off_t ZEXPORT gztell(file)
-    gzFile file;
+off_t ZEXPORT gztell(gzFile file)
 {
-    z_off64_t ret;
+    off_t ret;
 
     ret = gztell64(file);
-    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
+    return ret == (off_t)ret ? (off_t)ret : -1;
 }
 
 /* -- see zlib.h -- */
-z_off64_t ZEXPORT gzoffset64(file)
-    gzFile file;
+off_t ZEXPORT gzoffset64(gzFile file)
 {
-    z_off64_t offset;
-    gz_statep state;
+    off_t offset;
+    gz_state *state;
 
     /* get internal structure and check integrity */
     if (file == NULL)
         return -1;
-    state = (gz_statep)file;
+    state = (gz_state *)file;
     if (state->mode != GZ_READ && state->mode != GZ_WRITE)
         return -1;
 
     /* compute and return effective offset in file */
-    offset = LSEEK(state->fd, 0, SEEK_CUR);
+    offset = lseek(state->fd, 0, SEEK_CUR);
     if (offset == -1)
         return -1;
     if (state->mode == GZ_READ)             /* reading */
@@ -485,25 +382,23 @@ z_off64_t ZEXPORT gzoffset64(file)
 }
 
 /* -- see zlib.h -- */
-z_off_t ZEXPORT gzoffset(file)
-    gzFile file;
+off_t ZEXPORT gzoffset(gzFile file)
 {
-    z_off64_t ret;
+    off_t ret;
 
     ret = gzoffset64(file);
-    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
+    return ret == (off_t)ret ? (off_t)ret : -1;
 }
 
 /* -- see zlib.h -- */
-int ZEXPORT gzeof(file)
-    gzFile file;
+int ZEXPORT gzeof(gzFile file)
 {
-    gz_statep state;
+    gz_state *state;
 
     /* get internal structure and check integrity */
     if (file == NULL)
         return 0;
-    state = (gz_statep)file;
+    state = (gz_state *)file;
     if (state->mode != GZ_READ && state->mode != GZ_WRITE)
         return 0;
 
@@ -512,16 +407,15 @@ int ZEXPORT gzeof(file)
 }
 
 /* -- see zlib.h -- */
-const char * ZEXPORT gzerror(file, errnum)
-    gzFile file;
-    int *errnum;
+const char * ZEXPORT gzerror(gzFile file,
+                             int *errnum)
 {
-    gz_statep state;
+    gz_state *state;
 
     /* get internal structure and check integrity */
     if (file == NULL)
         return NULL;
-    state = (gz_statep)file;
+    state = (gz_state *)file;
     if (state->mode != GZ_READ && state->mode != GZ_WRITE)
         return NULL;
 
@@ -533,15 +427,14 @@ const char * ZEXPORT gzerror(file, errnum)
 }
 
 /* -- see zlib.h -- */
-void ZEXPORT gzclearerr(file)
-    gzFile file;
+void ZEXPORT gzclearerr(gzFile file)
 {
-    gz_statep state;
+    gz_state *state;
 
     /* get internal structure and check integrity */
     if (file == NULL)
         return;
-    state = (gz_statep)file;
+    state = (gz_state *)file;
     if (state->mode != GZ_READ && state->mode != GZ_WRITE)
         return;
 
@@ -559,7 +452,9 @@ void ZEXPORT gzclearerr(file)
    memory).  Simply save the error message as a static string.  If there is an
    allocation failure constructing the error message, then convert the error to
    out of memory. */
-void ZLIB_INTERNAL gz_error(gz_statep state, int err, const char *msg)
+void ZLIB_INTERNAL gz_error(gz_state *state,
+                            int err,
+                            const char *msg)
 {
     /* free previously allocated message and clear */
     if (state->msg != NULL) {
@@ -581,32 +476,10 @@ void ZLIB_INTERNAL gz_error(gz_statep state, int err, const char *msg)
     if (err == Z_MEM_ERROR)
         return;
 
-    /* construct error message with path */
-    if ((state->msg = (char *)malloc(strlen(state->path) + strlen(msg) + 3)) ==
-            NULL) {
+    char* state_msg;
+    if ( asprintf(&state_msg, "%s: %s", state->path, msg) < 0 ) {
         state->err = Z_MEM_ERROR;
         return;
     }
-    snprintf(state->msg, strlen(state->path) + strlen(msg) + 3,
-             "%s%s%s", state->path, ": ", msg);
-    return;
+    state->msg = state_msg;
 }
-
-#ifndef INT_MAX
-/* portably return maximum value for an int (when limits.h presumed not
-   available) -- we need to do this to cover cases where 2's complement not
-   used, since C standard permits 1's complement and sign-bit representations,
-   otherwise we could just use ((unsigned)-1) >> 1 */
-unsigned ZLIB_INTERNAL gz_intmax()
-{
-    unsigned p, q;
-
-    p = 1;
-    do {
-        q = p;
-        p <<= 1;
-        p++;
-    } while (p > q);
-    return q >> 1;
-}
-#endif
diff --git a/gzread.c b/gzread.c
index 7448b84..99e13fd 100644
--- a/gzread.c
+++ b/gzread.c
@@ -6,18 +6,21 @@
 #include "gzguts.h"
 
 /* Local functions */
-local int gz_load (gz_statep, unsigned char *, unsigned, unsigned *);
-local int gz_avail (gz_statep);
-local int gz_look (gz_statep);
-local int gz_decomp (gz_statep);
-local int gz_fetch (gz_statep);
-local int gz_skip (gz_statep, z_off64_t);
+static int gz_load(gz_state *, unsigned char *, unsigned, unsigned int *);
+static int gz_avail(gz_state *);
+static int gz_look(gz_state *);
+static int gz_decomp(gz_state *);
+static int gz_fetch(gz_state *);
+static int gz_skip(gz_state *, off_t);
 
 /* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from
    state->fd, and update state->eof, state->err, and state->msg as appropriate.
    This function needs to loop on read(), since read() is not guaranteed to
    read the number of bytes requested, depending on the type of descriptor. */
-local int gz_load(gz_statep state, unsigned char *buf, unsigned len, unsigned *have)
+static int gz_load(gz_state *state,
+                   unsigned char *buf,
+                   unsigned int len,
+                   unsigned int *have)
 {
     int ret;
 
@@ -29,7 +32,7 @@ local int gz_load(gz_statep state, unsigned char *buf, unsigned len, unsigned *h
         *have += ret;
     } while (*have < len);
     if (ret < 0) {
-        gz_error(state, Z_ERRNO, zstrerror());
+        gz_error(state, Z_ERRNO, strerror(errno));
         return -1;
     }
     if (ret == 0)
@@ -44,22 +47,16 @@ local int gz_load(gz_statep state, unsigned char *buf, unsigned len, unsigned *h
    If strm->avail_in != 0, then the current data is moved to the beginning of
    the input buffer, and then the remainder of the buffer is loaded with the
    available data from the input file. */
-local int gz_avail(gz_statep state)
+static int gz_avail(gz_state *state)
 {
-    unsigned got;
-    z_stream *strm = &(state->strm);
+    unsigned int got;
+    z_stream *strm = &state->strm;
 
     if (state->err != Z_OK && state->err != Z_BUF_ERROR)
         return -1;
     if (state->eof == 0) {
-        if (strm->avail_in) {       /* copy what's there to the start */
-            unsigned char *p = state->in;
-            unsigned const char *q = strm->next_in;
-            unsigned n = strm->avail_in;
-            do {
-                *p++ = *q++;
-            } while (--n);
-        }
+        if (strm->avail_in) /* copy what's there to the start */
+            memmove(state->in, strm->next_in, strm->avail_in);
         if (gz_load(state, state->in + strm->avail_in,
                     state->size - strm->avail_in, &got) == -1)
             return -1;
@@ -78,9 +75,9 @@ local int gz_avail(gz_statep state)
    case, all further file reads will be directly to either the output buffer or
    a user buffer.  If decompressing, the inflate state will be initialized.
    gz_look() will return 0 on success or -1 on failure. */
-local int gz_look(gz_statep state)
+static int gz_look(gz_state *state)
 {
-    z_stream *strm = &(state->strm);
+    z_stream *strm = &state->strm;
 
     /* allocate read buffers and inflate memory */
     if (state->size == 0) {
@@ -88,22 +85,20 @@ local int gz_look(gz_statep state)
         state->in = (unsigned char *)malloc(state->want);
         state->out = (unsigned char *)malloc(state->want << 1);
         if (state->in == NULL || state->out == NULL) {
-            if (state->out != NULL)
-                free(state->out);
-            if (state->in != NULL)
-                free(state->in);
+            free(state->out);
+            free(state->in);
             gz_error(state, Z_MEM_ERROR, "out of memory");
             return -1;
         }
         state->size = state->want;
 
         /* allocate inflate memory */
-        state->strm.zalloc = Z_NULL;
-        state->strm.zfree = Z_NULL;
-        state->strm.opaque = Z_NULL;
+        state->strm.zalloc = NULL;
+        state->strm.zfree = NULL;
+        state->strm.opaque = NULL;
         state->strm.avail_in = 0;
-        state->strm.next_in = Z_NULL;
-        if (inflateInit2(&(state->strm), 15 + 16) != Z_OK) {    /* gunzip */
+        state->strm.next_in = NULL;
+        if (inflateInit2(&state->strm, 15 + 16) != Z_OK) {    /* gunzip */
             free(state->out);
             free(state->in);
             state->size = 0;
@@ -163,11 +158,11 @@ local int gz_look(gz_statep state)
    data.  If the gzip stream completes, state->how is reset to LOOK to look for
    the next gzip stream or raw data, once state->x.have is depleted.  Returns 0
    on success, -1 on failure. */
-local int gz_decomp(gz_statep state)
+static int gz_decomp(gz_state *state)
 {
     int ret = Z_OK;
-    unsigned had;
-    z_stream *strm = &(state->strm);
+    unsigned int had;
+    z_stream *strm = &state->strm;
 
     /* fill output buffer up to end of deflate stream */
     had = strm->avail_out;
@@ -216,9 +211,9 @@ local int gz_decomp(gz_statep state)
    looked for to determine whether to copy or decompress.  Returns -1 on error,
    otherwise 0.  gz_fetch() will leave state->how as COPY or GZIP unless the
    end of the input file has been reached and all data has been processed.  */
-local int gz_fetch(gz_statep state)
+static int gz_fetch(gz_state *state)
 {
-    z_stream *strm = &(state->strm);
+    z_stream *strm = &state->strm;
 
     do {
         switch(state->how) {
@@ -229,7 +224,7 @@ local int gz_fetch(gz_statep state)
                 return 0;
             break;
         case COPY:      /* -> COPY */
-            if (gz_load(state, state->out, state->size << 1, &(state->x.have))
+            if (gz_load(state, state->out, state->size << 1, &state->x.have)
                     == -1)
                 return -1;
             state->x.next = state->out;
@@ -245,16 +240,17 @@ local int gz_fetch(gz_statep state)
 }
 
 /* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */
-local int gz_skip(gz_statep state, z_off64_t len)
+static int gz_skip(gz_state *state,
+                   off_t len)
 {
-    unsigned n;
+    unsigned int n;
 
     /* skip over len bytes or reach end-of-file, whichever comes first */
     while (len)
         /* skip over whatever is in output buffer */
         if (state->x.have) {
-            n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?
-                (unsigned)len : state->x.have;
+            n = GT_OFF(state->x.have) || (off_t)state->x.have > len ?
+                (unsigned int)len : state->x.have;
             state->x.have -= n;
             state->x.next += n;
             state->x.pos += n;
@@ -275,20 +271,19 @@ local int gz_skip(gz_statep state, z_off64_t len)
 }
 
 /* -- see zlib.h -- */
-int ZEXPORT gzread(file, buf, len)
-    gzFile file;
-    void *buf;
-    unsigned len;
+int ZEXPORT gzread(gzFile file,
+                   void* buf,
+                   unsigned int len)
 {
-    unsigned got, n;
-    gz_statep state;
+    unsigned int got, n;
+    gz_state *state;
     z_stream *strm;
 
     /* get internal structure */
     if (file == NULL)
         return -1;
-    state = (gz_statep)file;
-    strm = &(state->strm);
+    state = (gz_state *)file;
+    strm = &state->strm;
 
     /* check that we're reading and that there's no (serious) error */
     if (state->mode != GZ_READ ||
@@ -297,7 +292,7 @@ int ZEXPORT gzread(file, buf, len)
 
     /* since an int is returned, make sure len fits in one, otherwise return
        with an error (this avoids the flaw in the interface) */
-    if ((int)len < 0) {
+    if ( (unsigned int) INT_MAX < len ) {
         gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");
         return -1;
     }
@@ -359,7 +354,7 @@ int ZEXPORT gzread(file, buf, len)
 
         /* update progress */
         len -= n;
-        buf = (char *)buf + n;
+        buf = (unsigned char *)buf + n;
         got += n;
         state->x.pos += n;
     } while (len);
@@ -369,22 +364,16 @@ int ZEXPORT gzread(file, buf, len)
 }
 
 /* -- see zlib.h -- */
-#ifdef Z_PREFIX_SET
-#  undef z_gzgetc
-#else
-#  undef gzgetc
-#endif
-int ZEXPORT gzgetc(file)
-    gzFile file;
+int ZEXPORT gzgetc(gzFile file)
 {
     int ret;
     unsigned char buf[1];
-    gz_statep state;
+    gz_state *state;
 
     /* get internal structure */
     if (file == NULL)
         return -1;
-    state = (gz_statep)file;
+    state = (gz_state *)file;
 
     /* check that we're reading and that there's no (serious) error */
     if (state->mode != GZ_READ ||
@@ -403,23 +392,22 @@ int ZEXPORT gzgetc(file)
     return ret < 1 ? -1 : buf[0];
 }
 
-int ZEXPORT gzgetc_(file)
-gzFile file;
+/* old zlib ABI compatibility. */
+int ZEXPORT gzgetc_(gzFile file)
 {
     return gzgetc(file);
 }
 
 /* -- see zlib.h -- */
-int ZEXPORT gzungetc(c, file)
-    int c;
-    gzFile file;
+int ZEXPORT gzungetc(int c,
+                     gzFile file)
 {
-    gz_statep state;
+    gz_state *state;
 
     /* get internal structure */
     if (file == NULL)
         return -1;
-    state = (gz_statep)file;
+    state = (gz_state *)file;
 
     /* check that we're reading and that there's no (serious) error */
     if (state->mode != GZ_READ ||
@@ -470,20 +458,19 @@ int ZEXPORT gzungetc(c, file)
 }
 
 /* -- see zlib.h -- */
-char * ZEXPORT gzgets(file, buf, len)
-    gzFile file;
-    char *buf;
-    int len;
+char * ZEXPORT gzgets(gzFile file,
+                      char *buf,
+                      int len)
 {
-    unsigned left, n;
+    unsigned int left, n;
     char *str;
     unsigned char *eol;
-    gz_statep state;
+    gz_state *state;
 
     /* check parameters and get internal structure */
     if (file == NULL || buf == NULL || len < 1)
         return NULL;
-    state = (gz_statep)file;
+    state = (gz_state *)file;
 
     /* check that we're reading and that there's no (serious) error */
     if (state->mode != GZ_READ ||
@@ -501,7 +488,7 @@ char * ZEXPORT gzgets(file, buf, len)
        append a terminating zero to the string (we don't check for a zero in
        the contents, let the user worry about that) */
     str = buf;
-    left = (unsigned)len - 1;
+    left = (unsigned int)len - 1;
     if (left) do {
         /* assure that something is in the output buffer */
         if (state->x.have == 0 && gz_fetch(state) == -1)
@@ -515,7 +502,7 @@ char * ZEXPORT gzgets(file, buf, len)
         n = state->x.have > left ? left : state->x.have;
         eol = (unsigned char *)memchr(state->x.next, '\n', n);
         if (eol != NULL)
-            n = (unsigned)(eol - state->x.next) + 1;
+            n = (unsigned int)(eol - state->x.next) + 1;
 
         /* copy through end-of-line, or remainder if not found */
         memcpy(buf, state->x.next, n);
@@ -534,15 +521,14 @@ char * ZEXPORT gzgets(file, buf, len)
 }
 
 /* -- see zlib.h -- */
-int ZEXPORT gzdirect(file)
-    gzFile file;
+int ZEXPORT gzdirect(gzFile file)
 {
-    gz_statep state;
+    gz_state *state;
 
     /* get internal structure */
     if (file == NULL)
         return 0;
-    state = (gz_statep)file;
+    state = (gz_state *)file;
 
     /* if the state is not known, but we can find out, then do so (this is
        mainly for right after a gzopen() or gzdopen()) */
@@ -554,16 +540,15 @@ int ZEXPORT gzdirect(file)
 }
 
 /* -- see zlib.h -- */
-int ZEXPORT gzclose_r(file)
-    gzFile file;
+int ZEXPORT gzclose_r(gzFile file)
 {
     int ret, err;
-    gz_statep state;
+    gz_state *state;
 
     /* get internal structure */
     if (file == NULL)
         return Z_STREAM_ERROR;
-    state = (gz_statep)file;
+    state = (gz_state *)file;
 
     /* check that we're reading */
     if (state->mode != GZ_READ)
@@ -571,7 +556,7 @@ int ZEXPORT gzclose_r(file)
 
     /* free memory and close file */
     if (state->size) {
-        inflateEnd(&(state->strm));
+        inflateEnd(&state->strm);
         free(state->out);
         free(state->in);
     }
diff --git a/gzwrite.c b/gzwrite.c
index 955d5a5..5b33ffd 100644
--- a/gzwrite.c
+++ b/gzwrite.c
@@ -6,16 +6,16 @@
 #include "gzguts.h"
 
 /* Local functions */
-local int gz_init (gz_statep);
-local int gz_comp (gz_statep, int);
-local int gz_zero (gz_statep, z_off64_t);
+static int gz_init(gz_state *);
+static int gz_comp(gz_state *, int);
+static int gz_zero(gz_state *, off_t);
 
 /* Initialize state for writing a gzip file.  Mark initialization by setting
    state->size to non-zero.  Return -1 on failure or 0 on success. */
-local int gz_init(gz_statep state)
+static int gz_init(gz_state *state)
 {
     int ret;
-    z_stream *strm = &(state->strm);
+    z_stream *strm = &state->strm;
 
     /* allocate input buffer */
     state->in = (unsigned char *)malloc(state->want);
@@ -35,9 +35,9 @@ local int gz_init(gz_statep state)
         }
 
         /* allocate deflate memory, set up for gzip compression */
-        strm->zalloc = Z_NULL;
-        strm->zfree = Z_NULL;
-        strm->opaque = Z_NULL;
+        strm->zalloc = NULL;
+        strm->zfree = NULL;
+        strm->opaque = NULL;
         ret = deflateInit2(strm, state->level, Z_DEFLATED,
                            MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);
         if (ret != Z_OK) {
@@ -66,11 +66,12 @@ local int gz_init(gz_statep state)
    then the deflate() state is reset to start a new gzip stream.  If gz->direct
    is true, then simply write to the output file without compressing, and
    ignore flush. */
-local int gz_comp(gz_statep state, int flush)
+static int gz_comp(gz_state *state,
+                   int flush)
 {
     int ret, got;
-    unsigned have;
-    z_stream *strm = &(state->strm);
+    unsigned int have;
+    z_stream *strm = &state->strm;
 
     /* allocate memory if this is the first time through */
     if (state->size == 0 && gz_init(state) == -1)
@@ -79,8 +80,8 @@ local int gz_comp(gz_statep state, int flush)
     /* write directly if requested */
     if (state->direct) {
         got = write(state->fd, strm->next_in, strm->avail_in);
-        if (got < 0 || (unsigned)got != strm->avail_in) {
-            gz_error(state, Z_ERRNO, zstrerror());
+        if (got < 0 || (unsigned int)got != strm->avail_in) {
+            gz_error(state, Z_ERRNO, strerror(errno));
             return -1;
         }
         strm->avail_in = 0;
@@ -94,10 +95,10 @@ local int gz_comp(gz_statep state, int flush)
            doing Z_FINISH then don't write until we get to Z_STREAM_END */
         if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
             (flush != Z_FINISH || ret == Z_STREAM_END))) {
-            have = (unsigned)(strm->next_out - state->x.next);
+            have = (unsigned int)(strm->next_out - state->x.next);
             if (have && ((got = write(state->fd, state->x.next, have)) < 0 ||
-                         (unsigned)got != have)) {
-                gz_error(state, Z_ERRNO, zstrerror());
+                         (unsigned int)got != have)) {
+                gz_error(state, Z_ERRNO, strerror(errno));
                 return -1;
             }
             if (strm->avail_out == 0) {
@@ -127,11 +128,12 @@ local int gz_comp(gz_statep state, int flush)
 }
 
 /* Compress len zeros to output.  Return -1 on error, 0 on success. */
-local int gz_zero(gz_statep state, z_off64_t len)
+static int gz_zero(gz_state *state,
+                   off_t len)
 {
     int first;
-    unsigned n;
-    z_stream *strm = &(state->strm);
+    unsigned int n;
+    z_stream *strm = &state->strm;
 
     /* consume whatever's left in the input buffer */
     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
@@ -140,8 +142,8 @@ local int gz_zero(gz_statep state, z_off64_t len)
     /* compress len zeros (len guaranteed > 0) */
     first = 1;
     while (len) {
-        n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
-            (unsigned)len : state->size;
+        n = GT_OFF(state->size) || (off_t)state->size > len ?
+            (unsigned int)len : state->size;
         if (first) {
             memset(state->in, 0, n);
             first = 0;
@@ -157,20 +159,19 @@ local int gz_zero(gz_statep state, z_off64_t len)
 }
 
 /* -- see zlib.h -- */
-int ZEXPORT gzwrite(file, buf, len)
-    gzFile file;
-    void const *buf;
-    unsigned len;
+int ZEXPORT gzwrite(gzFile file,
+                    const void *buf,
+                    unsigned int len)
 {
     unsigned put = len;
-    gz_statep state;
+    gz_state *state;
     z_stream *strm;
 
     /* get internal structure */
     if (file == NULL)
         return 0;
-    state = (gz_statep)file;
-    strm = &(state->strm);
+    state = (gz_state *)file;
+    strm = &state->strm;
 
     /* check that we're writing and that there's no error */
     if (state->mode != GZ_WRITE || state->err != Z_OK)
@@ -178,7 +179,7 @@ int ZEXPORT gzwrite(file, buf, len)
 
     /* since an int is returned, make sure len fits in one, otherwise return
        with an error (this avoids the flaw in the interface) */
-    if ((int)len < 0) {
+    if ( (unsigned int) INT_MAX < len ) {
         gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");
         return 0;
     }
@@ -202,11 +203,11 @@ int ZEXPORT gzwrite(file, buf, len)
     if (len < state->size) {
         /* copy to input buffer, compress when full */
         do {
-            unsigned have, copy;
+            unsigned int have, copy;
 
             if (strm->avail_in == 0)
                 strm->next_in = state->in;
-            have = (unsigned)((strm->next_in + strm->avail_in) - state->in);
+            have = (unsigned int)((strm->next_in + strm->avail_in) - state->in);
             copy = state->size - have;
             if (copy > len)
                 copy = len;
@@ -226,7 +227,7 @@ int ZEXPORT gzwrite(file, buf, len)
 
         /* directly compress user buffer to file */
         strm->avail_in = len;
-        strm->next_in = (z_const Byte *)buf;
+        strm->next_in = (const unsigned char *)buf;
         state->x.pos += len;
         if (gz_comp(state, Z_NO_FLUSH) == -1)
             return 0;
@@ -237,20 +238,19 @@ int ZEXPORT gzwrite(file, buf, len)
 }
 
 /* -- see zlib.h -- */
-int ZEXPORT gzputc(file, c)
-    gzFile file;
-    int c;
+int ZEXPORT gzputc(gzFile file,
+                   int c)
 {
-    unsigned have;
+    unsigned int have;
     unsigned char buf[1];
-    gz_statep state;
+    gz_state *state;
     z_stream *strm;
 
     /* get internal structure */
     if (file == NULL)
         return -1;
-    state = (gz_statep)file;
-    strm = &(state->strm);
+    state = (gz_state *)file;
+    strm = &state->strm;
 
     /* check that we're writing and that there's no error */
     if (state->mode != GZ_WRITE || state->err != Z_OK)
@@ -285,15 +285,15 @@ int ZEXPORT gzputc(file, c)
 }
 
 /* -- see zlib.h -- */
-int ZEXPORT gzputs(file, str)
-    gzFile file;
-    const char *str;
+int ZEXPORT gzputs(gzFile file,
+                   const char *str)
 {
     int ret;
-    unsigned len;
+    unsigned int len;
 
     /* write string */
-    len = (unsigned)strlen(str);
+    /* TODO: This doesn't work for strings longer than UINT_MAX! */
+    len = (unsigned int)strlen(str);
     ret = gzwrite(file, str, len);
     return ret == 0 && len != 0 ? -1 : ret;
 }
@@ -301,17 +301,18 @@ int ZEXPORT gzputs(file, str)
 #include <stdarg.h>
 
 /* -- see zlib.h -- */
+/* TODO: This function deserves an audit. */
 int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va)
 {
     int size, len;
-    gz_statep state;
+    gz_state *state;
     z_stream *strm;
 
     /* get internal structure */
     if (file == NULL)
         return -1;
-    state = (gz_statep)file;
-    strm = &(state->strm);
+    state = (gz_state *)file;
+    strm = &state->strm;
 
     /* check that we're writing and that there's no error */
     if (state->mode != GZ_WRITE || state->err != Z_OK)
@@ -335,6 +336,7 @@ int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va)
     /* do the printf() into the input buffer, put length in len */
     size = (int)(state->size);
     state->in[size - 1] = 0;
+    /* TODO: Potential truncation! */
     len = vsnprintf((char *)(state->in), size, format, va);
 
     /* check that printf() results fit in buffer */
@@ -342,7 +344,7 @@ int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va)
         return 0;
 
     /* update buffer and position, defer compression until needed */
-    strm->avail_in = (unsigned)len;
+    strm->avail_in = (unsigned int)len;
     strm->next_in = state->in;
     state->x.pos += len;
     return len;
@@ -360,16 +362,15 @@ int ZEXPORTVA gzprintf(gzFile file, const char *format, ...)
 }
 
 /* -- see zlib.h -- */
-int ZEXPORT gzflush(file, flush)
-    gzFile file;
-    int flush;
+int ZEXPORT gzflush(gzFile file,
+                    int flush)
 {
-    gz_statep state;
+    gz_state *state;
 
     /* get internal structure */
     if (file == NULL)
         return -1;
-    state = (gz_statep)file;
+    state = (gz_state *)file;
 
     /* check that we're writing and that there's no error */
     if (state->mode != GZ_WRITE || state->err != Z_OK)
@@ -392,19 +393,18 @@ int ZEXPORT gzflush(file, flush)
 }
 
 /* -- see zlib.h -- */
-int ZEXPORT gzsetparams(file, level, strategy)
-    gzFile file;
-    int level;
-    int strategy;
+int ZEXPORT gzsetparams(gzFile file,
+                        int level,
+                        int strategy)
 {
-    gz_statep state;
+    gz_state *state;
     z_stream *strm;
 
     /* get internal structure */
     if (file == NULL)
         return Z_STREAM_ERROR;
-    state = (gz_statep)file;
-    strm = &(state->strm);
+    state = (gz_state *)file;
+    strm = &state->strm;
 
     /* check that we're writing and that there's no error */
     if (state->mode != GZ_WRITE || state->err != Z_OK)
@@ -434,16 +434,15 @@ int ZEXPORT gzsetparams(file, level, strategy)
 }
 
 /* -- see zlib.h -- */
-int ZEXPORT gzclose_w(file)
-    gzFile file;
+int ZEXPORT gzclose_w(gzFile file)
 {
     int ret = Z_OK;
-    gz_statep state;
+    gz_state *state;
 
     /* get internal structure */
     if (file == NULL)
         return Z_STREAM_ERROR;
-    state = (gz_statep)file;
+    state = (gz_state *)file;
 
     /* check that we're writing */
     if (state->mode != GZ_WRITE)
@@ -461,7 +460,7 @@ int ZEXPORT gzclose_w(file)
         ret = state->err;
     if (state->size) {
         if (!state->direct) {
-            (void)deflateEnd(&(state->strm));
+            (void)deflateEnd(&state->strm);
             free(state->out);
         }
         free(state->in);
diff --git a/infback.c b/infback.c
index 922eeeb..f1a5569 100644
--- a/infback.c
+++ b/infback.c
@@ -16,48 +16,38 @@
 #include "inffast.h"
 
 /* function prototypes */
-local void fixedtables (struct inflate_state *state);
+static void fixedtables(struct inflate_state *state);
 
 /*
    strm provides memory allocation functions in zalloc and zfree, or
-   Z_NULL to use the library memory allocation functions.
+   NULL to use the library memory allocation functions.
 
    windowBits is in the range 8..15, and window is a user-supplied
    window and output buffer that is 2**windowBits bytes.
  */
-int ZEXPORT inflateBackInit_(strm, windowBits, window, version, stream_size)
-z_stream *strm;
-int windowBits;
-unsigned char *window;
-const char *version;
-int stream_size;
+int ZEXPORT inflateBackInit_(z_stream *strm,
+                             int windowBits,
+                             unsigned char *window,
+                             const char *version,
+                             int stream_size)
 {
     struct inflate_state *state;
 
-    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
+    if (version == NULL || version[0] != ZLIB_VERSION[0] ||
         stream_size != (int)(sizeof(z_stream)))
         return Z_VERSION_ERROR;
-    if (strm == Z_NULL || window == Z_NULL ||
+    if (strm == NULL || window == NULL ||
         windowBits < 8 || windowBits > 15)
         return Z_STREAM_ERROR;
-    strm->msg = Z_NULL;                 /* in case we return an error */
-    if (strm->zalloc == (alloc_func)0) {
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
+    strm->msg = NULL;                 /* in case we return an error */
+    if (strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {
         strm->zalloc = zcalloc;
-        strm->opaque = (void *)0;
-#endif
+        strm->zfree = zcfree;
+        strm->opaque = NULL;
     }
-    if (strm->zfree == (free_func)0)
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
-    strm->zfree = zcfree;
-#endif
-    state = (struct inflate_state *)ZALLOC(strm, 1,
-                                               sizeof(struct inflate_state));
-    if (state == Z_NULL) return Z_MEM_ERROR;
+    state = (struct inflate_state *)
+        z_stream_alloc(strm,  sizeof(struct inflate_state));
+    if (state == NULL) return Z_MEM_ERROR;
     Tracev((stderr, "inflate: allocated\n"));
     strm->state = (struct internal_state *)state;
     state->dmax = 32768U;
@@ -71,50 +61,11 @@ int stream_size;
 
 /*
    Return state with length and distance decoding tables and index sizes set to
-   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
-   If BUILDFIXED is defined, then instead this routine builds the tables the
-   first time it's called, and returns those tables the first time and
-   thereafter.  This reduces the size of the code by about 2K bytes, in
-   exchange for a little execution time.  However, BUILDFIXED should not be
-   used for threaded applications, since the rewriting of the tables and virgin
-   may not be thread-safe.
+   fixed code decoding.  This returns fixed tables from inffixed.h.
  */
-local void fixedtables(struct inflate_state *state)
+static void fixedtables(struct inflate_state *state)
 {
-#ifdef BUILDFIXED
-    static int virgin = 1;
-    static code *lenfix, *distfix;
-    static code fixed[544];
-
-    /* build fixed huffman tables if first call (may not be thread safe) */
-    if (virgin) {
-        unsigned sym, bits;
-        static code *next;
-
-        /* literal/length table */
-        sym = 0;
-        while (sym < 144) state->lens[sym++] = 8;
-        while (sym < 256) state->lens[sym++] = 9;
-        while (sym < 280) state->lens[sym++] = 7;
-        while (sym < 288) state->lens[sym++] = 8;
-        next = fixed;
-        lenfix = next;
-        bits = 9;
-        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
-
-        /* distance table */
-        sym = 0;
-        while (sym < 32) state->lens[sym++] = 5;
-        distfix = next;
-        bits = 5;
-        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
-
-        /* do this just once */
-        virgin = 0;
-    }
-#else /* !BUILDFIXED */
-#   include "inffixed.h"
-#endif /* BUILDFIXED */
+#include "inffixed.h"
     state->lencode = lenfix;
     state->lenbits = 9;
     state->distcode = distfix;
@@ -159,7 +110,7 @@ local void fixedtables(struct inflate_state *state)
         if (have == 0) { \
             have = in(in_desc, &next); \
             if (have == 0) { \
-                next = Z_NULL; \
+                next = NULL; \
                 ret = Z_BUF_ERROR; \
                 goto inf_leave; \
             } \
@@ -181,13 +132,13 @@ local void fixedtables(struct inflate_state *state)
    an error. */
 #define NEEDBITS(n) \
     do { \
-        while (bits < (unsigned)(n)) \
+        while (bits < (unsigned int)(n)) \
             PULLBYTE(); \
     } while (0)
 
 /* Return the low n bits of the bit accumulator (n < 16) */
 #define BITS(n) \
-    ((unsigned)hold & ((1U << (n)) - 1))
+    ((unsigned int)hold & ((1U << (n)) - 1))
 
 /* Remove n bits from the bit accumulator */
 #define DROPBITS(n) \
@@ -239,47 +190,46 @@ local void fixedtables(struct inflate_state *state)
 
    in() should return zero on failure.  out() should return non-zero on
    failure.  If either in() or out() fails, than inflateBack() returns a
-   Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it
+   Z_BUF_ERROR.  strm->next_in can be checked for NULL to see whether it
    was in() or out() that caused in the error.  Otherwise,  inflateBack()
    returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format
    error, or Z_MEM_ERROR if it could not allocate memory for the state.
    inflateBack() can also return Z_STREAM_ERROR if the input parameters
-   are not correct, i.e. strm is Z_NULL or the state was not initialized.
+   are not correct, i.e. strm is NULL or the state was not initialized.
  */
-int ZEXPORT inflateBack(strm, in, in_desc, out, out_desc)
-z_stream *strm;
-in_func in;
-void *in_desc;
-out_func out;
-void *out_desc;
+int ZEXPORT inflateBack(z_stream *strm,
+                        in_func in,
+                        void *in_desc,
+                        out_func out,
+                        void *out_desc)
 {
     struct inflate_state *state;
-    z_const unsigned char *next;    /* next input */
-    unsigned char *put;     /* next output */
-    unsigned have, left;        /* available input and output */
+    const unsigned char *next;  /* next input */
+    unsigned char *put;         /* next output */
+    unsigned int have, left;    /* available input and output */
     unsigned long hold;         /* bit buffer */
-    unsigned bits;              /* bits in bit buffer */
-    unsigned copy;              /* number of stored or match bytes to copy */
-    unsigned char *from;    /* where to copy match bytes from */
+    unsigned int bits;          /* bits in bit buffer */
+    unsigned int copy;          /* number of stored or match bytes to copy */
+    unsigned char *from;        /* where to copy match bytes from */
     code here;                  /* current decoding table entry */
     code last;                  /* parent table entry */
-    unsigned len;               /* length to copy for repeats, bits to drop */
+    unsigned int len;           /* length to copy for repeats, bits to drop */
     int ret;                    /* return code */
     static const unsigned short order[19] = /* permutation of code lengths */
         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
 
     /* Check that the strm exists and that the state was initialized */
-    if (strm == Z_NULL || strm->state == Z_NULL)
+    if (strm == NULL || strm->state == NULL)
         return Z_STREAM_ERROR;
     state = (struct inflate_state *)strm->state;
 
     /* Reset the state */
-    strm->msg = Z_NULL;
+    strm->msg = NULL;
     state->mode = TYPE;
     state->last = 0;
     state->whave = 0;
     next = strm->next_in;
-    have = next != Z_NULL ? strm->avail_in : 0;
+    have = next != NULL ? strm->avail_in : 0;
     hold = 0;
     bits = 0;
     put = state->window;
@@ -363,13 +313,11 @@ void *out_desc;
             DROPBITS(5);
             state->ncode = BITS(4) + 4;
             DROPBITS(4);
-#ifndef PKZIP_BUG_WORKAROUND
             if (state->nlen > 286 || state->ndist > 30) {
                 strm->msg = (char *)"too many length or distance symbols";
                 state->mode = BAD;
                 break;
             }
-#endif
             Tracev((stderr, "inflate:       table sizes ok\n"));
 
             /* get code length code lengths (not a typo) */
@@ -384,8 +332,8 @@ void *out_desc;
             state->next = state->codes;
             state->lencode = (code const *)(state->next);
             state->lenbits = 7;
-            ret = inflate_table(CODES, state->lens, 19, &(state->next),
-                                &(state->lenbits), state->work);
+            ret = inflate_table(CODES, state->lens, 19, &state->next,
+                                &state->lenbits, state->work);
             if (ret) {
                 strm->msg = (char *)"invalid code lengths set";
                 state->mode = BAD;
@@ -398,7 +346,7 @@ void *out_desc;
             while (state->have < state->nlen + state->ndist) {
                 for (;;) {
                     here = state->lencode[BITS(state->lenbits)];
-                    if ((unsigned)(here.bits) <= bits) break;
+                    if ((unsigned int)(here.bits) <= bits) break;
                     PULLBYTE();
                 }
                 if (here.val < 16) {
@@ -414,7 +362,7 @@ void *out_desc;
                             state->mode = BAD;
                             break;
                         }
-                        len = (unsigned)(state->lens[state->have - 1]);
+                        len = (unsigned int)(state->lens[state->have - 1]);
                         copy = 3 + BITS(2);
                         DROPBITS(2);
                     }
@@ -458,8 +406,8 @@ void *out_desc;
             state->next = state->codes;
             state->lencode = (code const *)(state->next);
             state->lenbits = 9;
-            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
-                                &(state->lenbits), state->work);
+            ret = inflate_table(LENS, state->lens, state->nlen, &state->next,
+                                &state->lenbits, state->work);
             if (ret) {
                 strm->msg = (char *)"invalid literal/lengths set";
                 state->mode = BAD;
@@ -468,7 +416,7 @@ void *out_desc;
             state->distcode = (code const *)(state->next);
             state->distbits = 6;
             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
-                            &(state->next), &(state->distbits), state->work);
+                            &state->next, &state->distbits, state->work);
             if (ret) {
                 strm->msg = (char *)"invalid distances set";
                 state->mode = BAD;
@@ -491,7 +439,7 @@ void *out_desc;
             /* get a literal, length, or end-of-block code */
             for (;;) {
                 here = state->lencode[BITS(state->lenbits)];
-                if ((unsigned)(here.bits) <= bits) break;
+                if ((unsigned int)(here.bits) <= bits) break;
                 PULLBYTE();
             }
             if (here.op && (here.op & 0xf0) == 0) {
@@ -499,13 +447,13 @@ void *out_desc;
                 for (;;) {
                     here = state->lencode[last.val +
                             (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
+                    if ((unsigned int)(last.bits + here.bits) <= bits) break;
                     PULLBYTE();
                 }
                 DROPBITS(last.bits);
             }
             DROPBITS(here.bits);
-            state->length = (unsigned)here.val;
+            state->length = (unsigned int)here.val;
 
             /* process literal */
             if (here.op == 0) {
@@ -534,7 +482,7 @@ void *out_desc;
             }
 
             /* length code -- get extra bits, if any */
-            state->extra = (unsigned)(here.op) & 15;
+            state->extra = (unsigned int)(here.op) & 15;
             if (state->extra != 0) {
                 NEEDBITS(state->extra);
                 state->length += BITS(state->extra);
@@ -545,7 +493,7 @@ void *out_desc;
             /* get distance code */
             for (;;) {
                 here = state->distcode[BITS(state->distbits)];
-                if ((unsigned)(here.bits) <= bits) break;
+                if ((unsigned int)(here.bits) <= bits) break;
                 PULLBYTE();
             }
             if ((here.op & 0xf0) == 0) {
@@ -553,7 +501,7 @@ void *out_desc;
                 for (;;) {
                     here = state->distcode[last.val +
                             (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
+                    if ((unsigned int)(last.bits + here.bits) <= bits) break;
                     PULLBYTE();
                 }
                 DROPBITS(last.bits);
@@ -564,10 +512,10 @@ void *out_desc;
                 state->mode = BAD;
                 break;
             }
-            state->offset = (unsigned)here.val;
+            state->offset = (unsigned int)here.val;
 
             /* get distance extra bits, if any */
-            state->extra = (unsigned)(here.op) & 15;
+            state->extra = (unsigned int)(here.op) & 15;
             if (state->extra != 0) {
                 NEEDBITS(state->extra);
                 state->offset += BITS(state->extra);
@@ -627,13 +575,12 @@ void *out_desc;
     return ret;
 }
 
-int ZEXPORT inflateBackEnd(strm)
-z_stream *strm;
+int ZEXPORT inflateBackEnd(z_stream *strm)
 {
-    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
+    if (strm == NULL || strm->state == NULL || strm->zfree == (free_func)0)
         return Z_STREAM_ERROR;
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
+    z_stream_free(strm, strm->state);
+    strm->state = NULL;
     Tracev((stderr, "inflate: end\n"));
     return Z_OK;
 }
diff --git a/inffast.c b/inffast.c
index 3e36746..4ae5295 100644
--- a/inffast.c
+++ b/inffast.c
@@ -8,34 +8,15 @@
 #include "inflate.h"
 #include "inffast.h"
 
-/* Allow machine dependent optimization for post-increment or pre-increment.
-   Based on testing to date,
-   Pre-increment preferred for:
-   - PowerPC G3 (Adler)
-   - MIPS R5000 (Randers-Pehrson)
-   Post-increment preferred for:
-   - none
-   No measurable difference:
-   - Pentium III (Anderson)
-   - M68060 (Nikl)
- */
-#ifdef POSTINC
-#  define OFF 0
-#  define PUP(a) *(a)++
-#else
-#  define OFF 1
-#  define PUP(a) *++(a)
-#endif
-
 /* Return the low n bits of the bit accumulator (n < 16) */
 #define BITS(n) \
-    ((unsigned)hold & ((1U << (n)) - 1))
+    ((unsigned int)hold & ((1U << (n)) - 1))
 
 /* Remove n bits from the bit accumulator */
 #define DROPBITS(n) \
     do { \
         hold >>= (n); \
-        bits -= (unsigned)(n); \
+        bits -= (unsigned int)(n); \
     } while (0)
 
 /*
@@ -73,45 +54,42 @@
       requires strm->avail_out >= 258 for each loop to avoid checking for
       output space.
  */
-void ZLIB_INTERNAL inflate_fast(z_stream *strm, unsigned start)
+void ZLIB_INTERNAL inflate_fast(
+    z_stream *strm,
+    unsigned int start /* inflate()'s starting value for strm->avail_out */)
 {
-    /* start: inflate()'s starting value for strm->avail_out */
     struct inflate_state *state;
-    z_const unsigned char *in;      /* local strm->next_in */
-    z_const unsigned char *last;    /* have enough input while in < last */
-    unsigned char *out;     /* local strm->next_out */
-    unsigned char *beg;     /* inflate()'s initial strm->next_out */
-    unsigned char *end;     /* while out < end, enough space available */
-#ifdef INFLATE_STRICT
-    unsigned dmax;              /* maximum distance from zlib header */
-#endif
-    unsigned wsize;             /* window size or zero if not using window */
-    unsigned whave;             /* valid bytes in the window */
-    unsigned wnext;             /* window write index */
-    unsigned char *window;  /* allocated sliding window, if wsize != 0 */
-    unsigned long hold;         /* local strm->hold */
-    unsigned bits;              /* local strm->bits */
-    code const *lcode;      /* local strm->lencode */
-    code const *dcode;      /* local strm->distcode */
-    unsigned lmask;             /* mask for first level of length codes */
-    unsigned dmask;             /* mask for first level of distance codes */
-    code here;                  /* retrieved table entry */
-    unsigned op;                /* code bits, operation, extra bits, or */
-                                /*  window position, window bytes to copy */
-    unsigned len;               /* match length, unused bytes */
-    unsigned dist;              /* match distance */
-    unsigned char *from;    /* where to copy match from */
+    const unsigned char *in;   /* local strm->next_in */
+    const unsigned char *last; /* have enough input while in < last */
+    unsigned char *out;        /* local strm->next_out */
+    unsigned char *beg;        /* inflate()'s initial strm->next_out */
+    unsigned char *end;        /* while out < end, enough space available */
+    unsigned int dmax;         /* maximum distance from zlib header */
+    unsigned int wsize;        /* window size or zero if not using window */
+    unsigned int whave;        /* valid bytes in the window */
+    unsigned int wnext;        /* window write index */
+    unsigned char *window;     /* allocated sliding window, if wsize != 0 */
+    unsigned long hold;        /* local strm->hold */
+    unsigned int bits;         /* local strm->bits */
+    const code *lcode;         /* local strm->lencode */
+    const code *dcode;         /* local strm->distcode */
+    unsigned int lmask;        /* mask for first level of length codes */
+    unsigned int dmask;        /* mask for first level of distance codes */
+    code here;                 /* retrieved table entry */
+    unsigned int op;           /* code bits, operation, extra bits, or */
+                               /*  window position, window bytes to copy */
+    unsigned int len;          /* match length, unused bytes */
+    unsigned int dist;         /* match distance */
+    unsigned char *from;       /* where to copy match from */
 
     /* copy state to local variables */
     state = (struct inflate_state *)strm->state;
-    in = strm->next_in - OFF;
+    in = strm->next_in;
     last = in + (strm->avail_in - 5);
-    out = strm->next_out - OFF;
+    out = strm->next_out;
     beg = out - (start - strm->avail_out);
     end = out + (strm->avail_out - 257);
-#ifdef INFLATE_STRICT
     dmax = state->dmax;
-#endif
     wsize = state->wsize;
     whave = state->whave;
     wnext = state->wnext;
@@ -127,27 +105,27 @@ void ZLIB_INTERNAL inflate_fast(z_stream *strm, unsigned start)
        input data or output space */
     do {
         if (bits < 15) {
-            hold += (unsigned long)(PUP(in)) << bits;
+            hold += (unsigned long)(*in++) << bits;
             bits += 8;
-            hold += (unsigned long)(PUP(in)) << bits;
+            hold += (unsigned long)(*in++) << bits;
             bits += 8;
         }
         here = lcode[hold & lmask];
       dolen:
         DROPBITS(here.bits);
-        op = (unsigned)(here.op);
+        op = (unsigned int)(here.op);
         if (op == 0) {                          /* literal */
             Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                     "inflate:         literal '%c'\n" :
                     "inflate:         literal 0x%02x\n", here.val));
-            PUP(out) = (unsigned char)(here.val);
+            *out++ = (unsigned char)(here.val);
         }
         else if (op & 16) {                     /* length base */
-            len = (unsigned)(here.val);
+            len = (unsigned int)(here.val);
             op &= 15;                           /* number of extra bits */
             if (op) {
                 if (bits < op) {
-                    hold += (unsigned long)(PUP(in)) << bits;
+                    hold += (unsigned long)(*in++) << bits;
                     bits += 8;
                 }
                 len += BITS(op);
@@ -155,37 +133,35 @@ void ZLIB_INTERNAL inflate_fast(z_stream *strm, unsigned start)
             }
             Tracevv((stderr, "inflate:         length %u\n", len));
             if (bits < 15) {
-                hold += (unsigned long)(PUP(in)) << bits;
+                hold += (unsigned long)(*in++) << bits;
                 bits += 8;
-                hold += (unsigned long)(PUP(in)) << bits;
+                hold += (unsigned long)(*in++) << bits;
                 bits += 8;
             }
             here = dcode[hold & dmask];
           dodist:
             DROPBITS(here.bits);
-            op = (unsigned)(here.op);
+            op = (unsigned int)(here.op);
             if (op & 16) {                      /* distance base */
-                dist = (unsigned)(here.val);
+                dist = (unsigned int)(here.val);
                 op &= 15;                       /* number of extra bits */
                 if (bits < op) {
-                    hold += (unsigned long)(PUP(in)) << bits;
+                    hold += (unsigned long)(*in++) << bits;
                     bits += 8;
                     if (bits < op) {
-                        hold += (unsigned long)(PUP(in)) << bits;
+                        hold += (unsigned long)(*in++) << bits;
                         bits += 8;
                     }
                 }
                 dist += BITS(op);
-#ifdef INFLATE_STRICT
                 if (dist > dmax) {
                     strm->msg = (char *)"invalid distance too far back";
                     state->mode = BAD;
                     break;
                 }
-#endif
                 DROPBITS(op);
                 Tracevv((stderr, "inflate:         distance %u\n", dist));
-                op = (unsigned)(out - beg);     /* max distance in output */
+                op = (unsigned int)(out - beg); /* max distance in output */
                 if (dist > op) {                /* see if copy from window */
                     op = dist - op;             /* distance back in window */
                     if (op > whave) {
@@ -195,33 +171,14 @@ void ZLIB_INTERNAL inflate_fast(z_stream *strm, unsigned start)
                             state->mode = BAD;
                             break;
                         }
-#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
-                        if (len <= op - whave) {
-                            do {
-                                PUP(out) = 0;
-                            } while (--len);
-                            continue;
-                        }
-                        len -= op - whave;
-                        do {
-                            PUP(out) = 0;
-                        } while (--op > whave);
-                        if (op == 0) {
-                            from = out - dist;
-                            do {
-                                PUP(out) = PUP(from);
-                            } while (--len);
-                            continue;
-                        }
-#endif
                     }
-                    from = window - OFF;
+                    from = window;
                     if (wnext == 0) {           /* very common case */
                         from += wsize - op;
                         if (op < len) {         /* some from window */
                             len -= op;
                             do {
-                                PUP(out) = PUP(from);
+                                *out++ = *from++;
                             } while (--op);
                             from = out - dist;  /* rest from output */
                         }
@@ -232,14 +189,14 @@ void ZLIB_INTERNAL inflate_fast(z_stream *strm, unsigned start)
                         if (op < len) {         /* some from end of window */
                             len -= op;
                             do {
-                                PUP(out) = PUP(from);
+                                *out++ = *from++;
                             } while (--op);
-                            from = window - OFF;
+                            from = window;
                             if (wnext < len) {  /* some from start of window */
                                 op = wnext;
                                 len -= op;
                                 do {
-                                    PUP(out) = PUP(from);
+                                    *out++ = *from++;
                                 } while (--op);
                                 from = out - dist;      /* rest from output */
                             }
@@ -250,35 +207,35 @@ void ZLIB_INTERNAL inflate_fast(z_stream *strm, unsigned start)
                         if (op < len) {         /* some from window */
                             len -= op;
                             do {
-                                PUP(out) = PUP(from);
+                                *out++ = *from++;
                             } while (--op);
                             from = out - dist;  /* rest from output */
                         }
                     }
                     while (len > 2) {
-                        PUP(out) = PUP(from);
-                        PUP(out) = PUP(from);
-                        PUP(out) = PUP(from);
+                        *out++ = *from++;
+                        *out++ = *from++;
+                        *out++ = *from++;
                         len -= 3;
                     }
                     if (len) {
-                        PUP(out) = PUP(from);
+                        *out++ = *from++;
                         if (len > 1)
-                            PUP(out) = PUP(from);
+                            *out++ = *from++;
                     }
                 }
                 else {
                     from = out - dist;          /* copy direct from output */
                     do {                        /* minimum length is three */
-                        PUP(out) = PUP(from);
-                        PUP(out) = PUP(from);
-                        PUP(out) = PUP(from);
+                        *out++ = *from++;
+                        *out++ = *from++;
+                        *out++ = *from++;
                         len -= 3;
                     } while (len > 2);
                     if (len) {
-                        PUP(out) = PUP(from);
+                        *out++ = *from++;
                         if (len > 1)
-                            PUP(out) = PUP(from);
+                            *out++ = *from++;
                     }
                 }
             }
@@ -315,14 +272,13 @@ void ZLIB_INTERNAL inflate_fast(z_stream *strm, unsigned start)
     hold &= (1U << bits) - 1;
 
     /* update state and return */
-    strm->next_in = in + OFF;
-    strm->next_out = out + OFF;
-    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
-    strm->avail_out = (unsigned)(out < end ?
-                                 257 + (end - out) : 257 - (out - end));
+    strm->next_in = in;
+    strm->next_out = out;
+    strm->avail_in = (unsigned int)(in < last ? 5 + (last - in) : 5 - (in - last));
+    strm->avail_out = (unsigned int)(out < end ?
+                                     257 + (end - out) : 257 - (out - end));
     state->hold = hold;
     state->bits = bits;
-    return;
 }
 
 /*
diff --git a/inffast.h b/inffast.h
index 5b8a1f6..5d2a82e 100644
--- a/inffast.h
+++ b/inffast.h
@@ -8,4 +8,4 @@
    subject to change. Applications should only use zlib.h.
  */
 
-void ZLIB_INTERNAL inflate_fast (z_stream *strm, unsigned start);
+void ZLIB_INTERNAL inflate_fast(z_stream *strm, unsigned int start);
diff --git a/inflate.c b/inflate.c
index a03c7cd..8774277 100644
--- a/inflate.c
+++ b/inflate.c
@@ -75,7 +75,7 @@
  *   for the in() and out() functions
  * - Changed inflateBack() argument and in_func typedef to swap the length
  *   and buffer address return values for the input function
- * - Check next_in and next_out for Z_NULL on entry to inflate()
+ * - Check next_in and next_out for NULL on entry to inflate()
  *
  * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.
  */
@@ -85,36 +85,28 @@
 #include "inflate.h"
 #include "inffast.h"
 
-#ifdef MAKEFIXED
-#  ifndef BUILDFIXED
-#    define BUILDFIXED
-#  endif
-#endif
-
 /* function prototypes */
-local void fixedtables (struct inflate_state *state);
-local int updatewindow (z_stream *strm, const unsigned char *end, unsigned copy);
-#ifdef BUILDFIXED
-   void makefixed (void);
-#endif
-local unsigned syncsearch (unsigned *have, const unsigned char *buf, unsigned len);
-
-int ZEXPORT inflateResetKeep(strm)
-z_stream *strm;
+static void fixedtables(struct inflate_state *state);
+static int updatewindow(z_stream *strm, const unsigned char *end,
+                        unsigned int copy);
+static unsigned int syncsearch(unsigned int *have, const unsigned char *buf,
+                               unsigned int len);
+
+int ZEXPORT inflateResetKeep(z_stream *strm)
 {
     struct inflate_state *state;
 
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    if (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;
     state = (struct inflate_state *)strm->state;
     strm->total_in = strm->total_out = state->total = 0;
-    strm->msg = Z_NULL;
+    strm->msg = NULL;
     if (state->wrap)        /* to support ill-conceived Java test suite */
         strm->adler = state->wrap & 1;
     state->mode = HEAD;
     state->last = 0;
     state->havedict = 0;
     state->dmax = 32768U;
-    state->head = Z_NULL;
+    state->head = NULL;
     state->hold = 0;
     state->bits = 0;
     state->lencode = state->distcode = state->next = state->codes;
@@ -124,12 +116,11 @@ z_stream *strm;
     return Z_OK;
 }
 
-int ZEXPORT inflateReset(strm)
-z_stream *strm;
+int ZEXPORT inflateReset(z_stream *strm)
 {
     struct inflate_state *state;
 
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    if (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;
     state = (struct inflate_state *)strm->state;
     state->wsize = 0;
     state->whave = 0;
@@ -137,15 +128,14 @@ z_stream *strm;
     return inflateResetKeep(strm);
 }
 
-int ZEXPORT inflateReset2(strm, windowBits)
-z_stream *strm;
-int windowBits;
+int ZEXPORT inflateReset2(z_stream *strm,
+                          int windowBits)
 {
     int wrap;
     struct inflate_state *state;
 
     /* get the state */
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    if (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;
     state = (struct inflate_state *)strm->state;
 
     /* extract wrap request from windowBits parameter */
@@ -155,84 +145,70 @@ int windowBits;
     }
     else {
         wrap = (windowBits >> 4) + 1;
-#ifdef GUNZIP
         if (windowBits < 48)
             windowBits &= 15;
-#endif
     }
 
     /* set number of window bits, free window if different */
     if (windowBits && (windowBits < 8 || windowBits > 15))
         return Z_STREAM_ERROR;
-    if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {
-        ZFREE(strm, state->window);
-        state->window = Z_NULL;
+    if (state->window != NULL && state->wbits != (unsigned int)windowBits) {
+        z_stream_free(strm, state->window);
+        state->window = NULL;
     }
 
     /* update state and reset the rest of it */
     state->wrap = wrap;
-    state->wbits = (unsigned)windowBits;
+    state->wbits = (unsigned int)windowBits;
     return inflateReset(strm);
 }
 
-int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
-z_stream *strm;
-int windowBits;
-const char *version;
-int stream_size;
+int ZEXPORT inflateInit2_(z_stream *strm,
+                          int windowBits,
+                          const char *version,
+                          int stream_size)
 {
     int ret;
     struct inflate_state *state;
 
-    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
+    if (version == NULL || version[0] != ZLIB_VERSION[0] ||
         stream_size != (int)(sizeof(z_stream)))
         return Z_VERSION_ERROR;
-    if (strm == Z_NULL) return Z_STREAM_ERROR;
-    strm->msg = Z_NULL;                 /* in case we return an error */
-    if (strm->zalloc == (alloc_func)0) {
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
+    if (strm == NULL) return Z_STREAM_ERROR;
+    strm->msg = NULL;                 /* in case we return an error */
+    if (strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {
         strm->zalloc = zcalloc;
-        strm->opaque = (void *)0;
-#endif
-    }
-    if (strm->zfree == (free_func)0)
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
         strm->zfree = zcfree;
-#endif
+        strm->opaque = NULL;
+    }
     state = (struct inflate_state *)
-            ZALLOC(strm, 1, sizeof(struct inflate_state));
-    if (state == Z_NULL) return Z_MEM_ERROR;
+            z_stream_alloc(strm, sizeof(struct inflate_state));
+    if (state == NULL) return Z_MEM_ERROR;
     Tracev((stderr, "inflate: allocated\n"));
     strm->state = (struct internal_state *)state;
-    state->window = Z_NULL;
+    state->window = NULL;
     ret = inflateReset2(strm, windowBits);
     if (ret != Z_OK) {
-        ZFREE(strm, state);
-        strm->state = Z_NULL;
+        z_stream_free(strm, state);
+        strm->state = NULL;
     }
     return ret;
 }
 
-int ZEXPORT inflateInit_(strm, version, stream_size)
-z_stream *strm;
-const char *version;
-int stream_size;
+int ZEXPORT inflateInit_(z_stream *strm,
+                         const char *version,
+                         int stream_size)
 {
     return inflateInit2_(strm, DEF_WBITS, version, stream_size);
 }
 
-int ZEXPORT inflatePrime(strm, bits, value)
-z_stream *strm;
-int bits;
-int value;
+int ZEXPORT inflatePrime(z_stream *strm,
+                         int bits,
+                         int value)
 {
     struct inflate_state *state;
 
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    if (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;
     state = (struct inflate_state *)strm->state;
     if (bits < 0) {
         state->hold = 0;
@@ -248,117 +224,17 @@ int value;
 
 /*
    Return state with length and distance decoding tables and index sizes set to
-   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
-   If BUILDFIXED is defined, then instead this routine builds the tables the
-   first time it's called, and returns those tables the first time and
-   thereafter.  This reduces the size of the code by about 2K bytes, in
-   exchange for a little execution time.  However, BUILDFIXED should not be
-   used for threaded applications, since the rewriting of the tables and virgin
-   may not be thread-safe.
+   fixed code decoding.  This returns fixed tables from inffixed.h.
  */
-local void fixedtables(struct inflate_state *state)
+static void fixedtables(struct inflate_state *state)
 {
-#ifdef BUILDFIXED
-    static int virgin = 1;
-    static code *lenfix, *distfix;
-    static code fixed[544];
-
-    /* build fixed huffman tables if first call (may not be thread safe) */
-    if (virgin) {
-        unsigned sym, bits;
-        static code *next;
-
-        /* literal/length table */
-        sym = 0;
-        while (sym < 144) state->lens[sym++] = 8;
-        while (sym < 256) state->lens[sym++] = 9;
-        while (sym < 280) state->lens[sym++] = 7;
-        while (sym < 288) state->lens[sym++] = 8;
-        next = fixed;
-        lenfix = next;
-        bits = 9;
-        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
-
-        /* distance table */
-        sym = 0;
-        while (sym < 32) state->lens[sym++] = 5;
-        distfix = next;
-        bits = 5;
-        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
-
-        /* do this just once */
-        virgin = 0;
-    }
-#else /* !BUILDFIXED */
-#   include "inffixed.h"
-#endif /* BUILDFIXED */
+#include "inffixed.h"
     state->lencode = lenfix;
     state->lenbits = 9;
     state->distcode = distfix;
     state->distbits = 5;
 }
 
-#ifdef MAKEFIXED
-#include <stdio.h>
-
-/*
-   Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also
-   defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes
-   those tables to stdout, which would be piped to inffixed.h.  A small program
-   can simply call makefixed to do this:
-
-    void makefixed(void);
-
-    int main(void)
-    {
-        makefixed();
-        return 0;
-    }
-
-   Then that can be linked with zlib built with MAKEFIXED defined and run:
-
-    a.out > inffixed.h
- */
-void makefixed()
-{
-    unsigned low, size;
-    struct inflate_state state;
-
-    fixedtables(&state);
-    puts("    /* inffixed.h -- table for decoding fixed codes");
-    puts("     * Generated automatically by makefixed().");
-    puts("     */");
-    puts("");
-    puts("    /* WARNING: this file should *not* be used by applications.");
-    puts("       It is part of the implementation of this library and is");
-    puts("       subject to change. Applications should only use zlib.h.");
-    puts("     */");
-    puts("");
-    size = 1U << 9;
-    printf("    static const code lenfix[%u] = {", size);
-    low = 0;
-    for (;;) {
-        if ((low % 7) == 0) printf("\n        ");
-        printf("{%u,%u,%d}", (low & 127) == 99 ? 64 : state.lencode[low].op,
-               state.lencode[low].bits, state.lencode[low].val);
-        if (++low == size) break;
-        putchar(',');
-    }
-    puts("\n    };");
-    size = 1U << 5;
-    printf("\n    static const code distfix[%u] = {", size);
-    low = 0;
-    for (;;) {
-        if ((low % 6) == 0) printf("\n        ");
-        printf("{%u,%u,%d}", state.distcode[low].op, state.distcode[low].bits,
-               state.distcode[low].val);
-        if (++low == size) break;
-        putchar(',');
-    }
-    puts("\n    };");
-}
-#endif /* MAKEFIXED */
-
 /*
    Update the window with the last wsize (normally 32K) bytes written before
    returning.  If window does not exist yet, create it.  This is only called
@@ -373,19 +249,20 @@ void makefixed()
    output will fall in the output data, making match copies simpler and faster.
    The advantage may be dependent on the size of the processor's data caches.
  */
-local int updatewindow(z_stream *strm, const Byte *end, unsigned copy)
+static int updatewindow(z_stream *strm,
+                        const unsigned char *end,
+                        unsigned int copy)
 {
     struct inflate_state *state;
-    unsigned dist;
+    unsigned int dist;
 
     state = (struct inflate_state *)strm->state;
 
     /* if it hasn't been done already, allocate space for the window */
-    if (state->window == Z_NULL) {
+    if (state->window == NULL) {
         state->window = (unsigned char *)
-                        ZALLOC(strm, 1U << state->wbits,
-                               sizeof(unsigned char));
-        if (state->window == Z_NULL) return 1;
+                        z_stream_alloc(strm, 1U << state->wbits);
+        if (state->window == NULL) return 1;
     }
 
     /* if window not in use yet, initialize */
@@ -423,23 +300,18 @@ local int updatewindow(z_stream *strm, const Byte *end, unsigned copy)
 /* Macros for inflate(): */
 
 /* check function to use adler32() for zlib or crc32() for gzip */
-#ifdef GUNZIP
-#  define UPDATE(check, buf, len) \
+#define UPDATE(check, buf, len) \
     (state->flags ? crc32(check, buf, len) : adler32(check, buf, len))
-#else
-#  define UPDATE(check, buf, len) adler32(check, buf, len)
-#endif
 
 /* check macros for header crc */
-#ifdef GUNZIP
-#  define CRC2(check, word) \
+#define CRC2(check, word) \
     do { \
         hbuf[0] = (unsigned char)(word); \
         hbuf[1] = (unsigned char)((word) >> 8); \
         check = crc32(check, hbuf, 2); \
     } while (0)
 
-#  define CRC4(check, word) \
+#define CRC4(check, word) \
     do { \
         hbuf[0] = (unsigned char)(word); \
         hbuf[1] = (unsigned char)((word) >> 8); \
@@ -447,7 +319,6 @@ local int updatewindow(z_stream *strm, const Byte *end, unsigned copy)
         hbuf[3] = (unsigned char)((word) >> 24); \
         check = crc32(check, hbuf, 4); \
     } while (0)
-#endif
 
 /* Load registers with state in inflate() for speed */
 #define LOAD() \
@@ -492,19 +363,19 @@ local int updatewindow(z_stream *strm, const Byte *end, unsigned copy)
    not enough available input to do that, then return from inflate(). */
 #define NEEDBITS(n) \
     do { \
-        while (bits < (unsigned)(n)) \
+        while (bits < (unsigned int)(n)) \
             PULLBYTE(); \
     } while (0)
 
 /* Return the low n bits of the bit accumulator (n < 16) */
 #define BITS(n) \
-    ((unsigned)hold & ((1U << (n)) - 1))
+    ((unsigned int)hold & ((1U << (n)) - 1))
 
 /* Remove n bits from the bit accumulator */
 #define DROPBITS(n) \
     do { \
         hold >>= (n); \
-        bits -= (unsigned)(n); \
+        bits -= (unsigned int)(n); \
     } while (0)
 
 /* Remove zero to seven bits as needed to go to a byte boundary */
@@ -596,31 +467,28 @@ local int updatewindow(z_stream *strm, const Byte *end, unsigned copy)
    will return Z_BUF_ERROR if it has not reached the end of the stream.
  */
 
-int ZEXPORT inflate(strm, flush)
-z_stream *strm;
-int flush;
+int ZEXPORT inflate(z_stream *strm,
+                    int flush)
 {
     struct inflate_state *state;
-    z_const unsigned char *next;    /* next input */
-    unsigned char *put;     /* next output */
-    unsigned have, left;        /* available input and output */
+    const unsigned char *next;  /* next input */
+    unsigned char *put;         /* next output */
+    unsigned int have, left;    /* available input and output */
     unsigned long hold;         /* bit buffer */
-    unsigned bits;              /* bits in bit buffer */
-    unsigned in, out;           /* save starting available input and output */
-    unsigned copy;              /* number of stored or match bytes to copy */
-    unsigned char *from;    /* where to copy match bytes from */
+    unsigned int bits;          /* bits in bit buffer */
+    unsigned int in, out;       /* save starting available input and output */
+    unsigned int copy;          /* number of stored or match bytes to copy */
+    unsigned char *from;        /* where to copy match bytes from */
     code here;                  /* current decoding table entry */
     code last;                  /* parent table entry */
-    unsigned len;               /* length to copy for repeats, bits to drop */
+    unsigned int len;           /* length to copy for repeats, bits to drop */
     int ret;                    /* return code */
-#ifdef GUNZIP
     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
-#endif
     static const unsigned short order[19] = /* permutation of code lengths */
         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
 
-    if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
-        (strm->next_in == Z_NULL && strm->avail_in != 0))
+    if (strm == NULL || strm->state == NULL || strm->next_out == NULL ||
+        (strm->next_in == NULL && strm->avail_in != 0))
         return Z_STREAM_ERROR;
 
     state = (struct inflate_state *)strm->state;
@@ -637,21 +505,17 @@ int flush;
                 break;
             }
             NEEDBITS(16);
-#ifdef GUNZIP
             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
-                state->check = crc32(0L, Z_NULL, 0);
+                state->check = crc32(0L, NULL, 0);
                 CRC2(state->check, hold);
                 INITBITS();
                 state->mode = FLAGS;
                 break;
             }
             state->flags = 0;           /* expect zlib header */
-            if (state->head != Z_NULL)
+            if (state->head != NULL)
                 state->head->done = -1;
             if (!(state->wrap & 1) ||   /* check if zlib header allowed */
-#else
-            if (
-#endif
                 ((BITS(8) << 8) + (hold >> 8)) % 31) {
                 strm->msg = (char *)"incorrect header check";
                 state->mode = BAD;
@@ -673,11 +537,10 @@ int flush;
             }
             state->dmax = 1U << len;
             Tracev((stderr, "inflate:   zlib header ok\n"));
-            strm->adler = state->check = adler32(0L, Z_NULL, 0);
+            strm->adler = state->check = adler32(0L, NULL, 0);
             state->mode = hold & 0x200 ? DICTID : TYPE;
             INITBITS();
             break;
-#ifdef GUNZIP
         case FLAGS:
             NEEDBITS(16);
             state->flags = (int)(hold);
@@ -691,21 +554,21 @@ int flush;
                 state->mode = BAD;
                 break;
             }
-            if (state->head != Z_NULL)
+            if (state->head != NULL)
                 state->head->text = (int)((hold >> 8) & 1);
             if (state->flags & 0x0200) CRC2(state->check, hold);
             INITBITS();
             state->mode = TIME;
         case TIME:
             NEEDBITS(32);
-            if (state->head != Z_NULL)
+            if (state->head != NULL)
                 state->head->time = hold;
             if (state->flags & 0x0200) CRC4(state->check, hold);
             INITBITS();
             state->mode = OS;
         case OS:
             NEEDBITS(16);
-            if (state->head != Z_NULL) {
+            if (state->head != NULL) {
                 state->head->xflags = (int)(hold & 0xff);
                 state->head->os = (int)(hold >> 8);
             }
@@ -715,22 +578,22 @@ int flush;
         case EXLEN:
             if (state->flags & 0x0400) {
                 NEEDBITS(16);
-                state->length = (unsigned)(hold);
-                if (state->head != Z_NULL)
-                    state->head->extra_len = (unsigned)hold;
+                state->length = (unsigned int)(hold);
+                if (state->head != NULL)
+                    state->head->extra_len = (unsigned int)hold;
                 if (state->flags & 0x0200) CRC2(state->check, hold);
                 INITBITS();
             }
-            else if (state->head != Z_NULL)
-                state->head->extra = Z_NULL;
+            else if (state->head != NULL)
+                state->head->extra = NULL;
             state->mode = EXTRA;
         case EXTRA:
             if (state->flags & 0x0400) {
                 copy = state->length;
                 if (copy > have) copy = have;
                 if (copy) {
-                    if (state->head != Z_NULL &&
-                        state->head->extra != Z_NULL) {
+                    if (state->head != NULL &&
+                        state->head->extra != NULL) {
                         len = state->head->extra_len - state->length;
                         memcpy(state->head->extra + len, next,
                                 len + copy > state->head->extra_max ?
@@ -751,9 +614,9 @@ int flush;
                 if (have == 0) goto inf_leave;
                 copy = 0;
                 do {
-                    len = (unsigned)(next[copy++]);
-                    if (state->head != Z_NULL &&
-                            state->head->name != Z_NULL &&
+                    len = (unsigned int)(next[copy++]);
+                    if (state->head != NULL &&
+                            state->head->name != NULL &&
                             state->length < state->head->name_max)
                         state->head->name[state->length++] = len;
                 } while (len && copy < have);
@@ -763,8 +626,8 @@ int flush;
                 next += copy;
                 if (len) goto inf_leave;
             }
-            else if (state->head != Z_NULL)
-                state->head->name = Z_NULL;
+            else if (state->head != NULL)
+                state->head->name = NULL;
             state->length = 0;
             state->mode = COMMENT;
         case COMMENT:
@@ -772,9 +635,9 @@ int flush;
                 if (have == 0) goto inf_leave;
                 copy = 0;
                 do {
-                    len = (unsigned)(next[copy++]);
-                    if (state->head != Z_NULL &&
-                            state->head->comment != Z_NULL &&
+                    len = (unsigned int)(next[copy++]);
+                    if (state->head != NULL &&
+                            state->head->comment != NULL &&
                             state->length < state->head->comm_max)
                         state->head->comment[state->length++] = len;
                 } while (len && copy < have);
@@ -784,8 +647,8 @@ int flush;
                 next += copy;
                 if (len) goto inf_leave;
             }
-            else if (state->head != Z_NULL)
-                state->head->comment = Z_NULL;
+            else if (state->head != NULL)
+                state->head->comment = NULL;
             state->mode = HCRC;
         case HCRC:
             if (state->flags & 0x0200) {
@@ -797,14 +660,13 @@ int flush;
                 }
                 INITBITS();
             }
-            if (state->head != Z_NULL) {
+            if (state->head != NULL) {
                 state->head->hcrc = (int)((state->flags >> 9) & 1);
                 state->head->done = 1;
             }
-            strm->adler = state->check = crc32(0L, Z_NULL, 0);
+            strm->adler = state->check = crc32(0L, NULL, 0);
             state->mode = TYPE;
             break;
-#endif
         case DICTID:
             NEEDBITS(32);
             strm->adler = state->check = ZSWAP32(hold);
@@ -815,7 +677,7 @@ int flush;
                 RESTORE();
                 return Z_NEED_DICT;
             }
-            strm->adler = state->check = adler32(0L, Z_NULL, 0);
+            strm->adler = state->check = adler32(0L, NULL, 0);
             state->mode = TYPE;
         case TYPE:
             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;
@@ -863,7 +725,7 @@ int flush;
                 state->mode = BAD;
                 break;
             }
-            state->length = (unsigned)hold & 0xffff;
+            state->length = (unsigned int)hold & 0xffff;
             Tracev((stderr, "inflate:       stored length %u\n",
                     state->length));
             INITBITS();
@@ -896,13 +758,11 @@ int flush;
             DROPBITS(5);
             state->ncode = BITS(4) + 4;
             DROPBITS(4);
-#ifndef PKZIP_BUG_WORKAROUND
             if (state->nlen > 286 || state->ndist > 30) {
                 strm->msg = (char *)"too many length or distance symbols";
                 state->mode = BAD;
                 break;
             }
-#endif
             Tracev((stderr, "inflate:       table sizes ok\n"));
             state->have = 0;
             state->mode = LENLENS;
@@ -917,8 +777,8 @@ int flush;
             state->next = state->codes;
             state->lencode = (const code *)(state->next);
             state->lenbits = 7;
-            ret = inflate_table(CODES, state->lens, 19, &(state->next),
-                                &(state->lenbits), state->work);
+            ret = inflate_table(CODES, state->lens, 19, &state->next,
+                                &state->lenbits, state->work);
             if (ret) {
                 strm->msg = (char *)"invalid code lengths set";
                 state->mode = BAD;
@@ -931,7 +791,7 @@ int flush;
             while (state->have < state->nlen + state->ndist) {
                 for (;;) {
                     here = state->lencode[BITS(state->lenbits)];
-                    if ((unsigned)(here.bits) <= bits) break;
+                    if ((unsigned int)(here.bits) <= bits) break;
                     PULLBYTE();
                 }
                 if (here.val < 16) {
@@ -991,8 +851,8 @@ int flush;
             state->next = state->codes;
             state->lencode = (const code *)(state->next);
             state->lenbits = 9;
-            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
-                                &(state->lenbits), state->work);
+            ret = inflate_table(LENS, state->lens, state->nlen, &state->next,
+                                &state->lenbits, state->work);
             if (ret) {
                 strm->msg = (char *)"invalid literal/lengths set";
                 state->mode = BAD;
@@ -1001,7 +861,7 @@ int flush;
             state->distcode = (const code *)(state->next);
             state->distbits = 6;
             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
-                            &(state->next), &(state->distbits), state->work);
+                                &state->next, &state->distbits, state->work);
             if (ret) {
                 strm->msg = (char *)"invalid distances set";
                 state->mode = BAD;
@@ -1024,7 +884,7 @@ int flush;
             state->back = 0;
             for (;;) {
                 here = state->lencode[BITS(state->lenbits)];
-                if ((unsigned)(here.bits) <= bits) break;
+                if ((unsigned int)(here.bits) <= bits) break;
                 PULLBYTE();
             }
             if (here.op && (here.op & 0xf0) == 0) {
@@ -1032,7 +892,7 @@ int flush;
                 for (;;) {
                     here = state->lencode[last.val +
                             (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
+                    if ((unsigned int)(last.bits + here.bits) <= bits) break;
                     PULLBYTE();
                 }
                 DROPBITS(last.bits);
@@ -1040,7 +900,7 @@ int flush;
             }
             DROPBITS(here.bits);
             state->back += here.bits;
-            state->length = (unsigned)here.val;
+            state->length = (unsigned int)here.val;
             if ((int)(here.op) == 0) {
                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                         "inflate:         literal '%c'\n" :
@@ -1059,7 +919,7 @@ int flush;
                 state->mode = BAD;
                 break;
             }
-            state->extra = (unsigned)(here.op) & 15;
+            state->extra = (unsigned int)(here.op) & 15;
             state->mode = LENEXT;
         case LENEXT:
             if (state->extra) {
@@ -1074,7 +934,7 @@ int flush;
         case DIST:
             for (;;) {
                 here = state->distcode[BITS(state->distbits)];
-                if ((unsigned)(here.bits) <= bits) break;
+                if ((unsigned int)(here.bits) <= bits) break;
                 PULLBYTE();
             }
             if ((here.op & 0xf0) == 0) {
@@ -1082,7 +942,7 @@ int flush;
                 for (;;) {
                     here = state->distcode[last.val +
                             (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
+                    if ((unsigned int)(last.bits + here.bits) <= bits) break;
                     PULLBYTE();
                 }
                 DROPBITS(last.bits);
@@ -1095,8 +955,8 @@ int flush;
                 state->mode = BAD;
                 break;
             }
-            state->offset = (unsigned)here.val;
-            state->extra = (unsigned)(here.op) & 15;
+            state->offset = (unsigned int)here.val;
+            state->extra = (unsigned int)(here.op) & 15;
             state->mode = DISTEXT;
         case DISTEXT:
             if (state->extra) {
@@ -1105,13 +965,11 @@ int flush;
                 DROPBITS(state->extra);
                 state->back += state->extra;
             }
-#ifdef INFLATE_STRICT
             if (state->offset > state->dmax) {
                 strm->msg = (char *)"invalid distance too far back";
                 state->mode = BAD;
                 break;
             }
-#endif
             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
             state->mode = MATCH;
         case MATCH:
@@ -1125,19 +983,6 @@ int flush;
                         state->mode = BAD;
                         break;
                     }
-#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
-                    Trace((stderr, "inflate.c too far\n"));
-                    copy -= state->whave;
-                    if (copy > state->length) copy = state->length;
-                    if (copy > left) copy = left;
-                    left -= copy;
-                    state->length -= copy;
-                    do {
-                        *put++ = 0;
-                    } while (--copy);
-                    if (state->length == 0) state->mode = LEN;
-                    break;
-#endif
                 }
                 if (copy > state->wnext) {
                     copy -= state->wnext;
@@ -1175,11 +1020,7 @@ int flush;
                     strm->adler = state->check =
                         UPDATE(state->check, put - out, out);
                 out = left;
-                if ((
-#ifdef GUNZIP
-                     state->flags ? hold :
-#endif
-                     ZSWAP32(hold)) != state->check) {
+                if ((state->flags ? hold : ZSWAP32(hold)) != state->check) {
                     strm->msg = (char *)"incorrect data check";
                     state->mode = BAD;
                     break;
@@ -1187,7 +1028,6 @@ int flush;
                 INITBITS();
                 Tracev((stderr, "inflate:   check matches trailer\n"));
             }
-#ifdef GUNZIP
             state->mode = LENGTH;
         case LENGTH:
             if (state->wrap && state->flags) {
@@ -1200,7 +1040,6 @@ int flush;
                 INITBITS();
                 Tracev((stderr, "inflate:   length matches trailer\n"));
             }
-#endif
             state->mode = DONE;
         case DONE:
             ret = Z_STREAM_END;
@@ -1245,61 +1084,58 @@ int flush;
     return ret;
 }
 
-int ZEXPORT inflateEnd(strm)
-z_stream *strm;
+int ZEXPORT inflateEnd(z_stream *strm)
 {
     struct inflate_state *state;
-    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
+    if (strm == NULL || strm->state == NULL || strm->zfree == (free_func)0)
         return Z_STREAM_ERROR;
     state = (struct inflate_state *)strm->state;
-    if (state->window != Z_NULL) ZFREE(strm, state->window);
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
+    if (state->window != NULL) z_stream_free(strm, state->window);
+    z_stream_free(strm, state->window);
+    z_stream_free(strm, strm->state);
+    strm->state = NULL;
     Tracev((stderr, "inflate: end\n"));
     return Z_OK;
 }
 
-int ZEXPORT inflateGetDictionary(strm, dictionary, dictLength)
-z_stream *strm;
-Byte *dictionary;
-uInt *dictLength;
+int ZEXPORT inflateGetDictionary(z_stream *strm, unsigned char *dictionary,
+                                 unsigned int *dictLength)
 {
     struct inflate_state *state;
 
     /* check state */
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    if (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;
     state = (struct inflate_state *)strm->state;
 
     /* copy dictionary */
-    if (state->whave && dictionary != Z_NULL) {
+    if (state->whave && dictionary != NULL) {
         memcpy(dictionary, state->window + state->wnext,
                 state->whave - state->wnext);
         memcpy(dictionary + state->whave - state->wnext,
                 state->window, state->wnext);
     }
-    if (dictLength != Z_NULL)
+    if (dictLength != NULL)
         *dictLength = state->whave;
     return Z_OK;
 }
 
-int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)
-z_stream *strm;
-const Byte *dictionary;
-uInt dictLength;
+int ZEXPORT inflateSetDictionary(z_stream *strm,
+                                 const unsigned char *dictionary,
+                                 unsigned int dictLength)
 {
     struct inflate_state *state;
     unsigned long dictid;
     int ret;
 
     /* check state */
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    if (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;
     state = (struct inflate_state *)strm->state;
     if (state->wrap != 0 && state->mode != DICT)
         return Z_STREAM_ERROR;
 
     /* check for correct dictionary identifier */
     if (state->mode == DICT) {
-        dictid = adler32(0L, Z_NULL, 0);
+        dictid = adler32(0L, NULL, 0);
         dictid = adler32(dictid, dictionary, dictLength);
         if (dictid != state->check)
             return Z_DATA_ERROR;
@@ -1317,14 +1153,13 @@ uInt dictLength;
     return Z_OK;
 }
 
-int ZEXPORT inflateGetHeader(strm, head)
-z_stream *strm;
-gz_headerp head;
+int ZEXPORT inflateGetHeader(z_stream *strm,
+                             gz_header *head)
 {
     struct inflate_state *state;
 
     /* check state */
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    if (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;
     state = (struct inflate_state *)strm->state;
     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;
 
@@ -1345,10 +1180,12 @@ gz_headerp head;
    called again with more data and the *have state.  *have is initialized to
    zero for the first call.
  */
-local unsigned syncsearch(unsigned *have, const unsigned char *buf, unsigned len)
+static unsigned int syncsearch(unsigned int *have,
+                               const unsigned char *buf,
+                               unsigned int len)
 {
-    unsigned got;
-    unsigned next;
+    unsigned int got;
+    unsigned int next;
 
     got = *have;
     next = 0;
@@ -1365,16 +1202,15 @@ local unsigned syncsearch(unsigned *have, const unsigned char *buf, unsigned len
     return next;
 }
 
-int ZEXPORT inflateSync(strm)
-z_stream *strm;
+int ZEXPORT inflateSync(z_stream *strm)
 {
-    unsigned len;               /* number of bytes to look at or looked at */
+    unsigned int len;           /* number of bytes to look at or looked at */
     unsigned long in, out;      /* temporary to save total_in and total_out */
     unsigned char buf[4];       /* to restore bit buffer to byte string */
     struct inflate_state *state;
 
     /* check parameters */
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    if (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;
     state = (struct inflate_state *)strm->state;
     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;
 
@@ -1390,11 +1226,11 @@ z_stream *strm;
             state->bits -= 8;
         }
         state->have = 0;
-        syncsearch(&(state->have), buf, len);
+        syncsearch(&state->have, buf, len);
     }
 
     /* search available input */
-    len = syncsearch(&(state->have), strm->next_in, strm->avail_in);
+    len = syncsearch(&state->have, strm->next_in, strm->avail_in);
     strm->avail_in -= len;
     strm->next_in += len;
     strm->total_in += len;
@@ -1416,55 +1252,53 @@ z_stream *strm;
    block. When decompressing, PPP checks that at the end of input packet,
    inflate is waiting for these length bytes.
  */
-int ZEXPORT inflateSyncPoint(strm)
-z_stream *strm;
+int ZEXPORT inflateSyncPoint(z_stream *strm)
 {
     struct inflate_state *state;
 
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    if (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;
     state = (struct inflate_state *)strm->state;
     return state->mode == STORED && state->bits == 0;
 }
 
-int ZEXPORT inflateCopy(dest, source)
-z_stream *dest;
-z_stream *source;
+int ZEXPORT inflateCopy(z_stream *dest,
+                        z_stream *source)
 {
     struct inflate_state *state;
     struct inflate_state *copy;
     unsigned char *window;
-    unsigned wsize;
+    unsigned int wsize;
 
     /* check input */
-    if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
+    if (dest == NULL || source == NULL || source->state == NULL ||
         source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)
         return Z_STREAM_ERROR;
     state = (struct inflate_state *)source->state;
 
     /* allocate space */
     copy = (struct inflate_state *)
-           ZALLOC(source, 1, sizeof(struct inflate_state));
-    if (copy == Z_NULL) return Z_MEM_ERROR;
-    window = Z_NULL;
-    if (state->window != Z_NULL) {
+           z_stream_alloc(source, sizeof(struct inflate_state));
+    if (copy == NULL) return Z_MEM_ERROR;
+    window = NULL;
+    if (state->window != NULL) {
         window = (unsigned char *)
-                 ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
-        if (window == Z_NULL) {
-            ZFREE(source, copy);
+                 z_stream_alloc(source, 1U << state->wbits);
+        if (window == NULL) {
+            z_stream_free(source, copy);
             return Z_MEM_ERROR;
         }
     }
 
     /* copy state */
-    memcpy((void *)dest, (void *)source, sizeof(z_stream));
-    memcpy((void *)copy, (void *)state, sizeof(struct inflate_state));
+    memcpy(dest, source, sizeof(z_stream));
+    memcpy(copy, state, sizeof(struct inflate_state));
     if (state->lencode >= state->codes &&
         state->lencode <= state->codes + ENOUGH - 1) {
         copy->lencode = copy->codes + (state->lencode - state->codes);
         copy->distcode = copy->codes + (state->distcode - state->codes);
     }
     copy->next = copy->codes + (state->next - state->codes);
-    if (window != Z_NULL) {
+    if (window != NULL) {
         wsize = 1U << state->wbits;
         memcpy(window, state->window, wsize);
     }
@@ -1473,29 +1307,24 @@ z_stream *source;
     return Z_OK;
 }
 
-int ZEXPORT inflateUndermine(strm, subvert)
-z_stream *strm;
-int subvert;
+int ZEXPORT inflateUndermine(z_stream *strm,
+                             int subvert)
 {
     struct inflate_state *state;
 
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    if (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;
     state = (struct inflate_state *)strm->state;
-    state->sane = !subvert;
-#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
-    return Z_OK;
-#else
     state->sane = 1;
-    return Z_DATA_ERROR;
-#endif
+    if (subvert)
+        return Z_DATA_ERROR;
+    return Z_OK;
 }
 
-long ZEXPORT inflateMark(strm)
-z_stream *strm;
+long ZEXPORT inflateMark(z_stream *strm)
 {
     struct inflate_state *state;
 
-    if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;
+    if (strm == NULL || strm->state == NULL) return -1L << 16;
     state = (struct inflate_state *)strm->state;
     return ((long)(state->back) << 16) +
         (state->mode == COPY ? state->length :
diff --git a/inflate.h b/inflate.h
index dbd26f0..34ab787 100644
--- a/inflate.h
+++ b/inflate.h
@@ -8,14 +8,6 @@
    subject to change. Applications should only use zlib.h.
  */
 
-/* define NO_GZIP when compiling if you want to disable gzip header and
-   trailer decoding by inflate().  NO_GZIP would be used to avoid linking in
-   the crc code when it is not needed.  For shared libraries, gzip decoding
-   should be left enabled. */
-#ifndef NO_GZIP
-#  define GUNZIP
-#endif
-
 /* Possible inflate modes between inflate() calls */
 typedef enum {
     HEAD,       /* i: waiting for magic header */
@@ -84,39 +76,39 @@ struct inflate_state {
     int wrap;                   /* bit 0 true for zlib, bit 1 true for gzip */
     int havedict;               /* true if dictionary provided */
     int flags;                  /* gzip header method and flags (0 if zlib) */
-    unsigned dmax;              /* zlib header max distance (INFLATE_STRICT) */
+    unsigned int dmax;          /* zlib header max distance (INFLATE_STRICT) */
     unsigned long check;        /* protected copy of check value */
     unsigned long total;        /* protected copy of output count */
-    gz_headerp head;            /* where to save gzip header information */
+    gz_header *head;            /* where to save gzip header information */
         /* sliding window */
-    unsigned wbits;             /* log base 2 of requested window size */
-    unsigned wsize;             /* window size or zero if not using window */
-    unsigned whave;             /* valid bytes in the window */
-    unsigned wnext;             /* window write index */
+    unsigned int wbits;         /* log base 2 of requested window size */
+    unsigned int wsize;         /* window size or zero if not using window */
+    unsigned int whave;         /* valid bytes in the window */
+    unsigned int wnext;         /* window write index */
     unsigned char *window;  /* allocated sliding window, if needed */
         /* bit accumulator */
     unsigned long hold;         /* input bit accumulator */
-    unsigned bits;              /* number of bits in "in" */
+    unsigned int bits;          /* number of bits in "in" */
         /* for string and stored block copying */
-    unsigned length;            /* literal or length of data to copy */
-    unsigned offset;            /* distance back to copy string from */
+    unsigned int length;        /* literal or length of data to copy */
+    unsigned int offset;        /* distance back to copy string from */
         /* for table and code decoding */
-    unsigned extra;             /* extra bits needed */
+    unsigned int extra;         /* extra bits needed */
         /* fixed and dynamic code tables */
-    code const *lencode;    /* starting table for length/literal codes */
-    code const *distcode;   /* starting table for distance codes */
-    unsigned lenbits;           /* index bits for lencode */
-    unsigned distbits;          /* index bits for distcode */
+    const code *lencode;        /* starting table for length/literal codes */
+    const code *distcode;       /* starting table for distance codes */
+    unsigned int lenbits;       /* index bits for lencode */
+    unsigned int distbits;      /* index bits for distcode */
         /* dynamic table building */
-    unsigned ncode;             /* number of code length code lengths */
-    unsigned nlen;              /* number of length code lengths */
-    unsigned ndist;             /* number of distance code lengths */
-    unsigned have;              /* number of code lengths in lens[] */
-    code *next;             /* next available space in codes[] */
+    unsigned int ncode;         /* number of code length code lengths */
+    unsigned int nlen;          /* number of length code lengths */
+    unsigned int ndist;         /* number of distance code lengths */
+    unsigned int have;          /* number of code lengths in lens[] */
+    code *next;                 /* next available space in codes[] */
     unsigned short lens[320];   /* temporary storage for code lengths */
     unsigned short work[288];   /* work area for code table building */
     code codes[ENOUGH];         /* space for code tables */
     int sane;                   /* if false, allow invalid distance too far */
     int back;                   /* bits back of last unprocessed length/lit */
-    unsigned was;               /* initial length of match */
+    unsigned int was;           /* initial length of match */
 };
diff --git a/inftrees.c b/inftrees.c
index 4816596..33aef88 100644
--- a/inftrees.c
+++ b/inftrees.c
@@ -8,6 +8,7 @@
 
 #define MAXBITS 15
 
+ZLIB_INTERNAL
 const char inflate_copyright[] =
    " inflate 1.2.8.f Copyright 1995-2013 Mark Adler ";
 /*
@@ -29,26 +30,30 @@ const char inflate_copyright[] =
    table index bits.  It will differ if the request is greater than the
    longest code or if it is less than the shortest code.
  */
-int ZLIB_INTERNAL inflate_table(codetype type, unsigned short *lens, unsigned codes,
-                                code * *table, unsigned *bits, unsigned short  *work)
+int ZLIB_INTERNAL inflate_table(codetype type,
+                                unsigned short *lens,
+                                unsigned int codes,
+                                code **table,
+                                unsigned int *bits,
+                                unsigned short *work)
 {
-    unsigned len;               /* a code's length in bits */
-    unsigned sym;               /* index of code symbols */
-    unsigned min, max;          /* minimum and maximum code lengths */
-    unsigned root;              /* number of index bits for root table */
-    unsigned curr;              /* number of index bits for current table */
-    unsigned drop;              /* code bits to drop for sub-table */
+    unsigned int len;           /* a code's length in bits */
+    unsigned int sym;           /* index of code symbols */
+    unsigned int min, max;      /* minimum and maximum code lengths */
+    unsigned int root;          /* number of index bits for root table */
+    unsigned int curr;          /* number of index bits for current table */
+    unsigned int drop;          /* code bits to drop for sub-table */
     int left;                   /* number of prefix codes available */
-    unsigned used;              /* code entries in table used */
-    unsigned huff;              /* Huffman code */
-    unsigned incr;              /* for incrementing code, index */
-    unsigned fill;              /* index for replicating entries */
-    unsigned low;               /* low bits for current root entry */
-    unsigned mask;              /* mask for low root bits */
+    unsigned int used;          /* code entries in table used */
+    unsigned int huff;          /* Huffman code */
+    unsigned int incr;          /* for incrementing code, index */
+    unsigned int fill;          /* index for replicating entries */
+    unsigned int low;           /* low bits for current root entry */
+    unsigned int mask;          /* mask for low root bits */
     code here;                  /* table entry for duplication */
-    code *next;             /* next available space in table */
-    const unsigned short *base;     /* base value table to use */
-    const unsigned short *extra;    /* extra bits table to use */
+    code *next;                 /* next available space in table */
+    const unsigned short *base; /* base value table to use */
+    const unsigned short *extra;/* extra bits table to use */
     int end;                    /* use base and extra for symbol > end */
     unsigned short count[MAXBITS+1];    /* number of codes of each length */
     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
@@ -198,7 +203,7 @@ int ZLIB_INTERNAL inflate_table(codetype type, unsigned short *lens, unsigned co
     next = *table;              /* current table to fill in */
     curr = root;                /* current table index bits */
     drop = 0;                   /* current bits to drop from code for index */
-    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
+    low = (unsigned int)(-1);   /* trigger new sub-table when len > root */
     used = 1U << root;          /* use root table entries */
     mask = used - 1;            /* mask for comparing low */
 
diff --git a/inftrees.h b/inftrees.h
index a568d40..cf54ec1 100644
--- a/inftrees.h
+++ b/inftrees.h
@@ -57,6 +57,6 @@ typedef enum {
     DISTS
 } codetype;
 
-int ZLIB_INTERNAL inflate_table (codetype type, unsigned short *lens,
-                             unsigned codes, code * *table,
-                             unsigned *bits, unsigned short *work);
+int ZLIB_INTERNAL inflate_table(codetype type, unsigned short *lens,
+                                unsigned int codes, code **table,
+                                unsigned int *bits, unsigned short *work);
diff --git a/match.c b/match.c
index 541f77c..c69e91e 100644
--- a/match.c
+++ b/match.c
@@ -32,12 +32,12 @@
  * Standard longest_match
  *
  */
-ZLIB_INTERNAL unsigned longest_match(deflate_state *z_const s, IPos cur_match)
+ZLIB_INTERNAL unsigned int longest_match(deflate_state *const s, IPos cur_match)
 {
-	z_const unsigned wmask = s->w_mask;
-	z_const Pos *prev = s->prev;
+	const unsigned int wmask = s->w_mask;
+	const Pos *prev = s->prev;
 
-	unsigned chain_length;
+	unsigned int chain_length;
 	IPos limit;
 	int len, best_len, nice_match;
 	unsigned char *scan, *match, *strend, scan_end, scan_end1;
@@ -60,7 +60,7 @@ ZLIB_INTERNAL unsigned longest_match(deflate_state *z_const s, IPos cur_match)
 	 * Do not looks for matches beyond the end of the input. This is
 	 * necessary to make deflate deterministic
 	 */
-	nice_match = (uInt)s->nice_match > s->lookahead ? s->lookahead : s->nice_match;
+	nice_match = (unsigned int)s->nice_match > s->lookahead ? s->lookahead : s->nice_match;
 
 	/*
 	 * Stop when cur_match becomes <= limit. To simplify the code,
@@ -152,13 +152,13 @@ ZLIB_INTERNAL unsigned longest_match(deflate_state *z_const s, IPos cur_match)
  * UNALIGNED_OK longest_match
  *
  */
-ZLIB_INTERNAL unsigned longest_match(deflate_state *z_const s, IPos cur_match)
+ZLIB_INTERNAL unsigned int longest_match(deflate_state *const s, IPos cur_match)
 {
-	z_const unsigned wmask = s->w_mask;
-	z_const Pos *prev = s->prev;
+	const unsigned int wmask = s->w_mask;
+	const Pos *prev = s->prev;
 
 	unsigned short scan_start, scan_end;
-	unsigned chain_length;
+	unsigned int chain_length;
 	IPos limit;
 	int len, best_len, nice_match;
 	unsigned char *scan, *strend;
@@ -181,7 +181,7 @@ ZLIB_INTERNAL unsigned longest_match(deflate_state *z_const s, IPos cur_match)
 	 * Do not looks for matches beyond the end of the input. This is
 	 * necessary to make deflate deterministic
 	 */
-	nice_match = (uInt)s->nice_match > s->lookahead ? s->lookahead : s->nice_match;
+	nice_match = (unsigned int)s->nice_match > s->lookahead ? s->lookahead : s->nice_match;
 
 	/*
 	 * Stop when cur_match becomes <= limit. To simplify the code,
@@ -240,7 +240,7 @@ ZLIB_INTERNAL unsigned longest_match(deflate_state *z_const s, IPos cur_match)
 		/*
 		 * Here, scan <= window + strstart + 257
 		 */
-		Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
+		Assert(scan <= s->window+(unsigned int)(s->window_size-1), "wild scan");
 		if (*scan == *match)
 			scan++;
 
@@ -264,7 +264,7 @@ ZLIB_INTERNAL unsigned longest_match(deflate_state *z_const s, IPos cur_match)
 		}
 	} while (--chain_length && (cur_match = prev[cur_match & wmask]) > limit);
 
-	if ((unsigned)best_len <= s->lookahead)
+	if ((unsigned int)best_len <= s->lookahead)
 		return best_len;
 	return s->lookahead;
 }
@@ -335,12 +335,12 @@ ZLIB_INTERNAL unsigned longest_match(deflate_state *z_const s, IPos cur_match)
  *       -------------------------------------------------
  */
 
-ZLIB_INTERNAL unsigned longest_match(deflate_state *z_const s, IPos cur_match)
+ZLIB_INTERNAL unsigned int longest_match(deflate_state *const s, IPos cur_match)
 {
-    unsigned chain_length = s->max_chain_length;/* max hash chain length */
-    register Byte *scan = s->window + s->strstart; /* current string */
-    register Byte *match;                       /* matched string */
-    register int len;                           /* length of current match */
+    unsigned int chain_length = s->max_chain_length;/* max hash chain length */
+    unsigned char *scan = s->window + s->strstart; /* current string */
+    unsigned char *match;                       /* matched string */
+    int len;                           /* length of current match */
     int best_len = s->prev_length;              /* best match length so far */
     int nice_match = s->nice_match;             /* stop if match long enough */
     IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
@@ -349,11 +349,11 @@ ZLIB_INTERNAL unsigned longest_match(deflate_state *z_const s, IPos cur_match)
      * we prevent matches with the string of window index 0.
      */
     Pos *prev = s->prev;
-    uInt wmask = s->w_mask;
+    unsigned int wmask = s->w_mask;
 
-    register Byte *strend = s->window + s->strstart + MAX_MATCH;
-    register unsigned short scan_start = *(unsigned short*)scan;
-    register unsigned short scan_end   = *(unsigned short*)(scan+best_len-1);
+    unsigned char *strend = s->window + s->strstart + MAX_MATCH;
+    unsigned short scan_start = *(unsigned short*)scan;
+    unsigned short scan_end   = *(unsigned short*)(scan+best_len-1);
 
     /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
      * It is easy to get rid of this optimization if necessary.
@@ -367,9 +367,9 @@ ZLIB_INTERNAL unsigned longest_match(deflate_state *z_const s, IPos cur_match)
     /* Do not look for matches beyond the end of the input. This is necessary
      * to make deflate deterministic.
      */
-    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
+    if ((unsigned int)nice_match > s->lookahead) nice_match = s->lookahead;
 
-    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
+    Assert((unsigned long)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
 
     do {
         Assert(cur_match < s->strstart, "no future");
@@ -382,7 +382,7 @@ ZLIB_INTERNAL unsigned longest_match(deflate_state *z_const s, IPos cur_match)
          * However the length of the match is limited to the lookahead, so
          * the output of deflate is not affected by the uninitialized values.
          */
-        Byte *win = s->window;
+        unsigned char *win = s->window;
         int cont = 1;
         do {
             match = win + cur_match;
@@ -431,7 +431,7 @@ ZLIB_INTERNAL unsigned longest_match(deflate_state *z_const s, IPos cur_match)
         if (scan > strend)
             scan = strend;
 
-        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
+        Assert(scan <= s->window+(unsigned int)(s->window_size-1), "wild scan");
 
         len = MAX_MATCH - (int)(strend - scan);
         scan = strend - MAX_MATCH;
@@ -453,7 +453,7 @@ ZLIB_INTERNAL unsigned longest_match(deflate_state *z_const s, IPos cur_match)
     } while ((cur_match = prev[cur_match & wmask]) > limit
              && --chain_length != 0);
 
-    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
+    if ((unsigned int)best_len <= s->lookahead) return (unsigned int)best_len;
     return s->lookahead;
 }
 #endif
diff --git a/match.h b/match.h
index d0f3850..91d2fbc 100644
--- a/match.h
+++ b/match.h
@@ -1,2 +1,2 @@
 
-uInt longest_match  (deflate_state *s, IPos cur_match);
+unsigned int longest_match  (deflate_state *s, IPos cur_match);
diff --git a/test/example.c b/test/example.c
index 50fc370..a8528d6 100644
--- a/test/example.c
+++ b/test/example.c
@@ -26,16 +26,16 @@ z_const char hello[] = "hello, hello!";
  */
 
 const char dictionary[] = "hello";
-uLong dictId; /* Adler32 value of the dictionary */
-
-void test_deflate       (Byte *compr, uLong comprLen);
-void test_inflate       (Byte *compr, uLong comprLen, Byte *uncompr, uLong uncomprLen);
-void test_large_deflate (Byte *compr, uLong comprLen, Byte *uncompr, uLong uncomprLen);
-void test_large_inflate (Byte *compr, uLong comprLen, Byte *uncompr, uLong uncomprLen);
-void test_flush         (Byte *compr, uLong *comprLen);
-void test_sync          (Byte *compr, uLong comprLen, Byte *uncompr, uLong uncomprLen);
-void test_dict_deflate  (Byte *compr, uLong comprLen);
-void test_dict_inflate  (Byte *compr, uLong comprLen, Byte *uncompr, uLong uncomprLen);
+unsigned long dictId; /* Adler32 value of the dictionary */
+
+void test_deflate       (unsigned char *compr, unsigned long comprLen);
+void test_inflate       (unsigned char *compr, unsigned long comprLen, unsigned char *uncompr, unsigned long uncomprLen);
+void test_large_deflate (unsigned char *compr, unsigned long comprLen, unsigned char *uncompr, unsigned long uncomprLen);
+void test_large_inflate (unsigned char *compr, unsigned long comprLen, unsigned char *uncompr, unsigned long uncomprLen);
+void test_flush         (unsigned char *compr, unsigned long *comprLen);
+void test_sync          (unsigned char *compr, unsigned long comprLen, unsigned char *uncompr, unsigned long uncomprLen);
+void test_dict_deflate  (unsigned char *compr, unsigned long comprLen);
+void test_dict_inflate  (unsigned char *compr, unsigned long comprLen, unsigned char *uncompr, unsigned long uncomprLen);
 int  main               (int argc, char *argv[]);
 
 
@@ -46,13 +46,13 @@ void myfree (void *, void *);
 
 void *myalloc(void *q, unsigned n, unsigned m)
 {
-    q = Z_NULL;
+    q = NULL;
     return calloc(n, m);
 }
 
 void myfree(void *q, void *p)
 {
-    q = Z_NULL;
+    q = NULL;
     free(p);
 }
 
@@ -64,20 +64,20 @@ static free_func zfree = myfree;
 static alloc_func zalloc = (alloc_func)0;
 static free_func zfree = (free_func)0;
 
-void test_compress      (Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen);
+void test_compress      (unsigned char *compr, unsigned long comprLen,
+                            unsigned char *uncompr, unsigned long uncomprLen);
 void test_gzio          (const char *fname,
-                            Byte *uncompr, uLong uncomprLen);
+                            unsigned char *uncompr, unsigned long uncomprLen);
 
 /* ===========================================================================
  * Test compress() and uncompress()
  */
-void test_compress(Byte *compr, uLong comprLen, Byte *uncompr, uLong uncomprLen)
+void test_compress(unsigned char *compr, unsigned long comprLen, unsigned char *uncompr, unsigned long uncomprLen)
 {
     int err;
-    uLong len = (uLong)strlen(hello)+1;
+    unsigned long len = (unsigned long)strlen(hello)+1;
 
-    err = compress(compr, &comprLen, (const Byte*)hello, len);
+    err = compress(compr, &comprLen, (const unsigned char*)hello, len);
     CHECK_ERR(err, "compress");
 
     strcpy((char*)uncompr, "garbage");
@@ -96,7 +96,7 @@ void test_compress(Byte *compr, uLong comprLen, Byte *uncompr, uLong uncomprLen)
 /* ===========================================================================
  * Test read/write of .gz files
  */
-void test_gzio(const char *fname, Byte *uncompr, uLong uncomprLen)
+void test_gzio(const char *fname, unsigned char *uncompr, unsigned long uncomprLen)
 {
 #ifdef NO_GZCOMPRESS
     fprintf(stderr, "NO_GZCOMPRESS -- gz* functions cannot compress\n");
@@ -104,7 +104,7 @@ void test_gzio(const char *fname, Byte *uncompr, uLong uncomprLen)
     int err;
     int len = (int)strlen(hello)+1;
     gzFile file;
-    z_off_t pos;
+    off_t pos;
 
     file = gzopen(fname, "wb");
     if (file == NULL) {
@@ -120,7 +120,7 @@ void test_gzio(const char *fname, Byte *uncompr, uLong uncomprLen)
         fprintf(stderr, "gzprintf err: %s\n", gzerror(file, &err));
         exit(1);
     }
-    gzseek(file, 1L, SEEK_CUR); /* add one zero byte */
+    gzseek(file, 1L, SEEK_CUR); /* add one zero unsigned char */
     gzclose(file);
 
     file = gzopen(fname, "rb");
@@ -179,11 +179,11 @@ void test_gzio(const char *fname, Byte *uncompr, uLong uncomprLen)
 /* ===========================================================================
  * Test deflate() with small buffers
  */
-void test_deflate(Byte *compr, uLong comprLen)
+void test_deflate(unsigned char *compr, unsigned long comprLen)
 {
     z_stream c_stream; /* compression stream */
     int err;
-    uLong len = (uLong)strlen(hello)+1;
+    unsigned long len = (unsigned long)strlen(hello)+1;
 
     c_stream.zalloc = zalloc;
     c_stream.zfree = zfree;
@@ -215,7 +215,7 @@ void test_deflate(Byte *compr, uLong comprLen)
 /* ===========================================================================
  * Test inflate() with small buffers
  */
-void test_inflate(Byte *compr, uLong comprLen, Byte *uncompr, uLong uncomprLen)
+void test_inflate(unsigned char *compr, unsigned long comprLen, unsigned char *uncompr, unsigned long uncomprLen)
 {
     int err;
     z_stream d_stream; /* decompression stream */
@@ -254,7 +254,7 @@ void test_inflate(Byte *compr, uLong comprLen, Byte *uncompr, uLong uncomprLen)
 /* ===========================================================================
  * Test deflate() with large buffers and dynamic change of compression level
  */
-void test_large_deflate(Byte *compr, uLong comprLen, Byte *uncompr, uLong uncomprLen)
+void test_large_deflate(unsigned char *compr, unsigned long comprLen, unsigned char *uncompr, unsigned long uncomprLen)
 {
     z_stream c_stream; /* compression stream */
     int err;
@@ -267,13 +267,13 @@ void test_large_deflate(Byte *compr, uLong comprLen, Byte *uncompr, uLong uncomp
     CHECK_ERR(err, "deflateInit");
 
     c_stream.next_out = compr;
-    c_stream.avail_out = (uInt)comprLen;
+    c_stream.avail_out = (unsigned int)comprLen;
 
     /* At this point, uncompr is still mostly zeroes, so it should compress
      * very well:
      */
     c_stream.next_in = uncompr;
-    c_stream.avail_in = (uInt)uncomprLen;
+    c_stream.avail_in = (unsigned int)uncomprLen;
     err = deflate(&c_stream, Z_NO_FLUSH);
     CHECK_ERR(err, "deflate");
     if (c_stream.avail_in != 0) {
@@ -284,14 +284,14 @@ void test_large_deflate(Byte *compr, uLong comprLen, Byte *uncompr, uLong uncomp
     /* Feed in already compressed data and switch to no compression: */
     deflateParams(&c_stream, Z_NO_COMPRESSION, Z_DEFAULT_STRATEGY);
     c_stream.next_in = compr;
-    c_stream.avail_in = (uInt)comprLen/2;
+    c_stream.avail_in = (unsigned int)comprLen/2;
     err = deflate(&c_stream, Z_NO_FLUSH);
     CHECK_ERR(err, "deflate");
 
     /* Switch back to compressing mode: */
     deflateParams(&c_stream, Z_BEST_COMPRESSION, Z_FILTERED);
     c_stream.next_in = uncompr;
-    c_stream.avail_in = (uInt)uncomprLen;
+    c_stream.avail_in = (unsigned int)uncomprLen;
     err = deflate(&c_stream, Z_NO_FLUSH);
     CHECK_ERR(err, "deflate");
 
@@ -307,7 +307,7 @@ void test_large_deflate(Byte *compr, uLong comprLen, Byte *uncompr, uLong uncomp
 /* ===========================================================================
  * Test inflate() with large buffers
  */
-void test_large_inflate(Byte *compr, uLong comprLen, Byte *uncompr, uLong uncomprLen)
+void test_large_inflate(unsigned char *compr, unsigned long comprLen, unsigned char *uncompr, unsigned long uncomprLen)
 {
     int err;
     z_stream d_stream; /* decompression stream */
@@ -319,14 +319,14 @@ void test_large_inflate(Byte *compr, uLong comprLen, Byte *uncompr, uLong uncomp
     d_stream.opaque = (void *)0;
 
     d_stream.next_in  = compr;
-    d_stream.avail_in = (uInt)comprLen;
+    d_stream.avail_in = (unsigned int)comprLen;
 
     err = inflateInit(&d_stream);
     CHECK_ERR(err, "inflateInit");
 
     for (;;) {
         d_stream.next_out = uncompr;            /* discard the output */
-        d_stream.avail_out = (uInt)uncomprLen;
+        d_stream.avail_out = (unsigned int)uncomprLen;
         err = inflate(&d_stream, Z_NO_FLUSH);
         if (err == Z_STREAM_END) break;
         CHECK_ERR(err, "large inflate");
@@ -346,11 +346,11 @@ void test_large_inflate(Byte *compr, uLong comprLen, Byte *uncompr, uLong uncomp
 /* ===========================================================================
  * Test deflate() with full flush
  */
-void test_flush(Byte *compr, uLong *comprLen)
+void test_flush(unsigned char *compr, unsigned long *comprLen)
 {
     z_stream c_stream; /* compression stream */
     int err;
-    uInt len = (uInt)strlen(hello)+1;
+    unsigned int len = (unsigned int)strlen(hello)+1;
 
     c_stream.zalloc = zalloc;
     c_stream.zfree = zfree;
@@ -362,7 +362,7 @@ void test_flush(Byte *compr, uLong *comprLen)
     c_stream.next_in  = (z_const unsigned char *)hello;
     c_stream.next_out = compr;
     c_stream.avail_in = 3;
-    c_stream.avail_out = (uInt)*comprLen;
+    c_stream.avail_out = (unsigned int)*comprLen;
     err = deflate(&c_stream, Z_FULL_FLUSH);
     CHECK_ERR(err, "deflate");
 
@@ -382,7 +382,7 @@ void test_flush(Byte *compr, uLong *comprLen)
 /* ===========================================================================
  * Test inflateSync()
  */
-void test_sync(Byte *compr, uLong comprLen, Byte *uncompr, uLong uncomprLen)
+void test_sync(unsigned char *compr, unsigned long comprLen, unsigned char *uncompr, unsigned long uncomprLen)
 {
     int err;
     z_stream d_stream; /* decompression stream */
@@ -400,12 +400,12 @@ void test_sync(Byte *compr, uLong comprLen, Byte *uncompr, uLong uncomprLen)
     CHECK_ERR(err, "inflateInit");
 
     d_stream.next_out = uncompr;
-    d_stream.avail_out = (uInt)uncomprLen;
+    d_stream.avail_out = (unsigned int)uncomprLen;
 
     inflate(&d_stream, Z_NO_FLUSH);
     CHECK_ERR(err, "inflate");
 
-    d_stream.avail_in = (uInt)comprLen-2;   /* read all compressed data */
+    d_stream.avail_in = (unsigned int)comprLen-2;   /* read all compressed data */
     err = inflateSync(&d_stream);           /* but skip the damaged part */
     CHECK_ERR(err, "inflateSync");
 
@@ -424,7 +424,7 @@ void test_sync(Byte *compr, uLong comprLen, Byte *uncompr, uLong uncomprLen)
 /* ===========================================================================
  * Test deflate() with preset dictionary
  */
-void test_dict_deflate(Byte *compr, uLong comprLen)
+void test_dict_deflate(unsigned char *compr, unsigned long comprLen)
 {
     z_stream c_stream; /* compression stream */
     int err;
@@ -437,15 +437,15 @@ void test_dict_deflate(Byte *compr, uLong comprLen)
     CHECK_ERR(err, "deflateInit");
 
     err = deflateSetDictionary(&c_stream,
-                (const Byte*)dictionary, (int)sizeof(dictionary));
+                (const unsigned char*)dictionary, (int)sizeof(dictionary));
     CHECK_ERR(err, "deflateSetDictionary");
 
     dictId = c_stream.adler;
     c_stream.next_out = compr;
-    c_stream.avail_out = (uInt)comprLen;
+    c_stream.avail_out = (unsigned int)comprLen;
 
     c_stream.next_in = (z_const unsigned char *)hello;
-    c_stream.avail_in = (uInt)strlen(hello)+1;
+    c_stream.avail_in = (unsigned int)strlen(hello)+1;
 
     err = deflate(&c_stream, Z_FINISH);
     if (err != Z_STREAM_END) {
@@ -459,7 +459,7 @@ void test_dict_deflate(Byte *compr, uLong comprLen)
 /* ===========================================================================
  * Test inflate() with a preset dictionary
  */
-void test_dict_inflate(Byte *compr, uLong comprLen, Byte *uncompr, uLong uncomprLen)
+void test_dict_inflate(unsigned char *compr, unsigned long comprLen, unsigned char *uncompr, unsigned long uncomprLen)
 {
     int err;
     z_stream d_stream; /* decompression stream */
@@ -471,13 +471,13 @@ void test_dict_inflate(Byte *compr, uLong comprLen, Byte *uncompr, uLong uncompr
     d_stream.opaque = (void *)0;
 
     d_stream.next_in  = compr;
-    d_stream.avail_in = (uInt)comprLen;
+    d_stream.avail_in = (unsigned int)comprLen;
 
     err = inflateInit(&d_stream);
     CHECK_ERR(err, "inflateInit");
 
     d_stream.next_out = uncompr;
-    d_stream.avail_out = (uInt)uncomprLen;
+    d_stream.avail_out = (unsigned int)uncomprLen;
 
     for (;;) {
         err = inflate(&d_stream, Z_NO_FLUSH);
@@ -487,7 +487,7 @@ void test_dict_inflate(Byte *compr, uLong comprLen, Byte *uncompr, uLong uncompr
                 fprintf(stderr, "unexpected dictionary");
                 exit(1);
             }
-            err = inflateSetDictionary(&d_stream, (const Byte*)dictionary,
+            err = inflateSetDictionary(&d_stream, (const unsigned char*)dictionary,
                                        (int)sizeof(dictionary));
         }
         CHECK_ERR(err, "inflate with dict");
@@ -510,9 +510,9 @@ void test_dict_inflate(Byte *compr, uLong comprLen, Byte *uncompr, uLong uncompr
 
 int main(int argc, char *argv[])
 {
-    Byte *compr, *uncompr;
-    uLong comprLen = 10000*sizeof(int); /* don't overflow on MSDOS */
-    uLong uncomprLen = comprLen;
+    unsigned char *compr, *uncompr;
+    unsigned long comprLen = 10000*sizeof(int); /* don't overflow on MSDOS */
+    unsigned long uncomprLen = comprLen;
     static const char* myVersion = ZLIB_VERSION;
 
     if (zlibVersion()[0] != myVersion[0]) {
@@ -526,12 +526,12 @@ int main(int argc, char *argv[])
     printf("zlib version %s = 0x%04x, compile flags = 0x%lx\n",
             ZLIB_VERSION, ZLIB_VERNUM, zlibCompileFlags());
 
-    compr    = (Byte*)calloc((uInt)comprLen, 1);
-    uncompr  = (Byte*)calloc((uInt)uncomprLen, 1);
+    compr    = (unsigned char*)calloc((unsigned int)comprLen, 1);
+    uncompr  = (unsigned char*)calloc((unsigned int)uncomprLen, 1);
     /* compr and uncompr are cleared to avoid reading uninitialized
      * data and to ensure that uncompr compresses well.
      */
-    if (compr == Z_NULL || uncompr == Z_NULL) {
+    if (compr == NULL || uncompr == NULL) {
         printf("out of memory\n");
         exit(1);
     }
diff --git a/trees.c b/trees.c
index 3504fa3..1ebc832 100644
--- a/trees.c
+++ b/trees.c
@@ -32,8 +32,6 @@
 
 /* @(#) $Id$ */
 
-/* #define GEN_TREES_H */
-
 #include "deflate.h"
 
 #ifdef DEBUG
@@ -56,16 +54,16 @@
 #define REPZ_11_138  18
 /* repeat a zero length 11-138 times  (7 bits of repeat count) */
 
-local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
+static const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
    = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
 
-local const int extra_dbits[D_CODES] /* extra bits for each distance code */
+static const int extra_dbits[D_CODES] /* extra bits for each distance code */
    = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
 
-local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
+static const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
    = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
 
-local const uch bl_order[BL_CODES]
+static const unsigned char bl_order[BL_CODES]
    = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
 /* The lengths of the bit length codes are sent in order of decreasing
  * probability, to avoid transmitting the lengths for unused bit length codes.
@@ -77,235 +75,53 @@ local const uch bl_order[BL_CODES]
 
 #define DIST_CODE_LEN  512 /* see definition of array dist_code below */
 
-#if defined(GEN_TREES_H)
-/* non ANSI compilers may not accept trees.h */
-
-ZLIB_INTERNAL ct_data static_ltree[L_CODES+2];
-/* The static literal tree. Since the bit lengths are imposed, there is no
- * need for the L_CODES extra codes used during heap construction. However
- * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
- * below).
- */
-
-local ct_data static_dtree[D_CODES];
-/* The static distance tree. (Actually a trivial tree since all codes use
- * 5 bits.)
- */
-
-uch _dist_code[DIST_CODE_LEN];
-/* Distance codes. The first 256 values correspond to the distances
- * 3 .. 258, the last 256 values correspond to the top 8 bits of
- * the 15 bit distances.
- */
-
-uch _length_code[MAX_MATCH-MIN_MATCH+1];
-/* length code for each normalized match length (0 == MIN_MATCH) */
-
-local int base_length[LENGTH_CODES];
-/* First normalized length for each code (0 = MIN_MATCH) */
-
-local int base_dist[D_CODES];
-/* First normalized distance for each code (0 = distance of 1) */
-
-#else
-#  include "trees.h"
-#endif /* GEN_TREES_H */
+#include "trees.h"
 
 struct static_tree_desc_s {
     const ct_data *static_tree;  /* static tree or NULL */
-    const int *extra_bits;      /* extra bits for each code or NULL */
+    const int *extra_bits;       /* extra bits for each code or NULL */
     int     extra_base;          /* base index for extra_bits */
     int     elems;               /* max number of elements in the tree */
     int     max_length;          /* max bit length for the codes */
 };
 
-local static_tree_desc  static_l_desc =
+static static_tree_desc  static_l_desc =
 {static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};
 
-local static_tree_desc  static_d_desc =
+static static_tree_desc  static_d_desc =
 {static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};
 
-local static_tree_desc  static_bl_desc =
+static static_tree_desc  static_bl_desc =
 {(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};
 
 /* ===========================================================================
- * Local (static) routines in this file.
- */
-
-local void tr_static_init (void);
-local void init_block     (deflate_state *s);
-local void pqdownheap     (deflate_state *s, ct_data *tree, int k);
-local void gen_bitlen     (deflate_state *s, tree_desc *desc);
-local void gen_codes      (ct_data *tree, int max_code, ush *bl_count);
-local void build_tree     (deflate_state *s, tree_desc *desc);
-local void scan_tree      (deflate_state *s, ct_data *tree, int max_code);
-local void send_tree      (deflate_state *s, ct_data *tree, int max_code);
-local int  build_bl_tree  (deflate_state *s);
-local void send_all_trees (deflate_state *s, int lcodes, int dcodes, int blcodes);
-local void compress_block (deflate_state *s, const ct_data *ltree, const ct_data *dtree);
-local int  detect_data_type (deflate_state *s);
-local unsigned bi_reverse (unsigned value, int length);
-local void bi_flush       (deflate_state *s);
-local void copy_block     (deflate_state *s, char *buf, unsigned len, int header);
-
-#ifdef GEN_TREES_H
-local void gen_trees_header (void);
-#endif
-
-/* ===========================================================================
- * Initialize the various 'constant' tables.
- */
-local void tr_static_init()
-{
-#if defined(GEN_TREES_H)
-    static int static_init_done = 0;
-    int n;        /* iterates over tree elements */
-    int bits;     /* bit counter */
-    int length;   /* length value */
-    int code;     /* code value */
-    int dist;     /* distance index */
-    ush bl_count[MAX_BITS+1];
-    /* number of codes at each bit length for an optimal tree */
-
-    if (static_init_done) return;
-
-    /* For some embedded targets, global variables are not initialized: */
-#ifdef NO_INIT_GLOBAL_POINTERS
-    static_l_desc.static_tree = static_ltree;
-    static_l_desc.extra_bits = extra_lbits;
-    static_d_desc.static_tree = static_dtree;
-    static_d_desc.extra_bits = extra_dbits;
-    static_bl_desc.extra_bits = extra_blbits;
-#endif
-
-    /* Initialize the mapping length (0..255) -> length code (0..28) */
-    length = 0;
-    for (code = 0; code < LENGTH_CODES-1; code++) {
-        base_length[code] = length;
-        for (n = 0; n < (1<<extra_lbits[code]); n++) {
-            _length_code[length++] = (uch)code;
-        }
-    }
-    Assert (length == 256, "tr_static_init: length != 256");
-    /* Note that the length 255 (match length 258) can be represented
-     * in two different ways: code 284 + 5 bits or code 285, so we
-     * overwrite length_code[255] to use the best encoding:
-     */
-    _length_code[length-1] = (uch)code;
-
-    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
-    dist = 0;
-    for (code = 0 ; code < 16; code++) {
-        base_dist[code] = dist;
-        for (n = 0; n < (1<<extra_dbits[code]); n++) {
-            _dist_code[dist++] = (uch)code;
-        }
-    }
-    Assert (dist == 256, "tr_static_init: dist != 256");
-    dist >>= 7; /* from now on, all distances are divided by 128 */
-    for ( ; code < D_CODES; code++) {
-        base_dist[code] = dist << 7;
-        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
-            _dist_code[256 + dist++] = (uch)code;
-        }
-    }
-    Assert (dist == 256, "tr_static_init: 256+dist != 512");
-
-    /* Construct the codes of the static literal tree */
-    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
-    n = 0;
-    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
-    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
-    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
-    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
-    /* Codes 286 and 287 do not exist, but we must include them in the
-     * tree construction to get a canonical Huffman tree (longest code
-     * all ones)
-     */
-    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
-
-    /* The static distance tree is trivial: */
-    for (n = 0; n < D_CODES; n++) {
-        static_dtree[n].Len = 5;
-        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
-    }
-    static_init_done = 1;
-
-#  ifdef GEN_TREES_H
-    gen_trees_header();
-#  endif
-#endif /* defined(GEN_TREES_H) */
-}
-
-/* ===========================================================================
- * Genererate the file trees.h describing the static trees.
- */
-#ifdef GEN_TREES_H
-#  ifndef DEBUG
-#    include <stdio.h>
-#  endif
-
-#  define SEPARATOR(i, last, width) \
-      ((i) == (last)? "\n};\n\n" :    \
-       ((i) % (width) == (width)-1 ? ",\n" : ", "))
-
-void gen_trees_header()
-{
-    FILE *header = fopen("trees.h", "w");
-    int i;
-
-    Assert (header != NULL, "Can't open trees.h");
-    fprintf(header,
-            "/* header created automatically with -DGEN_TREES_H */\n\n");
-
-    fprintf(header, "ZLIB_INTERNAL const ct_data static_ltree[L_CODES+2] = {\n");
-    for (i = 0; i < L_CODES+2; i++) {
-        fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
-                static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
-    }
-
-    fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
-    for (i = 0; i < D_CODES; i++) {
-        fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
-                static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
-    }
-
-    fprintf(header, "const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\n");
-    for (i = 0; i < DIST_CODE_LEN; i++) {
-        fprintf(header, "%2u%s", _dist_code[i],
-                SEPARATOR(i, DIST_CODE_LEN-1, 20));
-    }
-
-    fprintf(header,
-        "const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
-    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
-        fprintf(header, "%2u%s", _length_code[i],
-                SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
-    }
-
-    fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
-    for (i = 0; i < LENGTH_CODES; i++) {
-        fprintf(header, "%1u%s", base_length[i],
-                SEPARATOR(i, LENGTH_CODES-1, 20));
-    }
-
-    fprintf(header, "local const int base_dist[D_CODES] = {\n");
-    for (i = 0; i < D_CODES; i++) {
-        fprintf(header, "%5u%s", base_dist[i],
-                SEPARATOR(i, D_CODES-1, 10));
-    }
-
-    fclose(header);
-}
-#endif /* GEN_TREES_H */
+ * Static routines in this file.
+ */
+
+static void init_block(deflate_state *s);
+static void pqdownheap(deflate_state *s, ct_data *tree, int k);
+static void gen_bitlen(deflate_state *s, tree_desc *desc);
+static void gen_codes(ct_data *tree, int max_code, unsigned short *bl_count);
+static void build_tree(deflate_state *s, tree_desc *desc);
+static void scan_tree(deflate_state *s, ct_data *tree, int max_code);
+static void send_tree(deflate_state *s, ct_data *tree, int max_code);
+static int  build_bl_tree(deflate_state *s);
+static void send_all_trees(deflate_state *s, int lcodes, int dcodes,
+                           int blcodes);
+static void compress_block(deflate_state *s, const ct_data *ltree,
+                           const ct_data *dtree);
+static int  detect_data_type(deflate_state *s);
+static unsigned int bi_reverse(unsigned int value, int length);
+ZLIB_INTERNAL void bi_windup(deflate_state *s);
+static void bi_flush(deflate_state *s);
+static void copy_block(deflate_state *s, char *buf, unsigned int len,
+                       int header);
 
 /* ===========================================================================
  * Initialize the tree data structures for a new zlib stream.
  */
 void ZLIB_INTERNAL _tr_init(deflate_state *s)
 {
-    tr_static_init();
-
     s->l_desc.dyn_tree = s->dyn_ltree;
     s->l_desc.stat_desc = &static_l_desc;
 
@@ -329,7 +145,7 @@ void ZLIB_INTERNAL _tr_init(deflate_state *s)
 /* ===========================================================================
  * Initialize a new block.
  */
-local void init_block(deflate_state *s)
+static void init_block(deflate_state *s)
 {
     int n; /* iterates over tree elements */
 
@@ -372,10 +188,10 @@ local void init_block(deflate_state *s)
  * when the heap property is re-established (each father smaller than its
  * two sons).
  */
-local void pqdownheap(deflate_state *s, ct_data *tree, int k)
+static void pqdownheap(deflate_state *s,
+                       ct_data *tree /* the tree to restore */,
+                       int k /* node to move down */)
 {
-    /* tree: the tree to restore */
-    /* k: node to move down */
     int v = s->heap[k];
     int j = k << 1;  /* left son of k */
     while (j <= s->heap_len) {
@@ -406,9 +222,9 @@ local void pqdownheap(deflate_state *s, ct_data *tree, int k)
  *     The length opt_len is updated; static_len is also updated if stree is
  *     not null.
  */
-local void gen_bitlen(deflate_state *s, tree_desc *desc)
+static void gen_bitlen(deflate_state *s,
+                       tree_desc *desc /* the tree descriptor */)
 {
-    /* desc: the tree descriptor */
     ct_data *tree        = desc->dyn_tree;
     int max_code         = desc->max_code;
     const ct_data *stree = desc->stat_desc->static_tree;
@@ -419,7 +235,7 @@ local void gen_bitlen(deflate_state *s, tree_desc *desc)
     int n, m;           /* iterate over the tree elements */
     int bits;           /* bit length */
     int xbits;          /* extra bits */
-    ush f;              /* frequency */
+    unsigned short f;   /* frequency */
     int overflow = 0;   /* number of elements with bit length too large */
 
     for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
@@ -433,7 +249,7 @@ local void gen_bitlen(deflate_state *s, tree_desc *desc)
         n = s->heap[h];
         bits = tree[tree[n].Dad].Len + 1;
         if (bits > max_length) bits = max_length, overflow++;
-        tree[n].Len = (ush)bits;
+        tree[n].Len = (unsigned short)bits;
         /* We overwrite tree[n].Dad which is no longer needed */
 
         if (n > max_code) continue; /* not a leaf node */
@@ -442,8 +258,8 @@ local void gen_bitlen(deflate_state *s, tree_desc *desc)
         xbits = 0;
         if (n >= base) xbits = extra[n-base];
         f = tree[n].Freq;
-        s->opt_len += (ulg)f * (bits + xbits);
-        if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);
+        s->opt_len += (unsigned long)f * (bits + xbits);
+        if (stree) s->static_len += (unsigned long)f * (stree[n].Len + xbits);
     }
     if (overflow == 0) return;
 
@@ -473,11 +289,11 @@ local void gen_bitlen(deflate_state *s, tree_desc *desc)
         while (n != 0) {
             m = s->heap[--h];
             if (m > max_code) continue;
-            if ((unsigned) tree[m].Len != (unsigned) bits) {
+            if ((unsigned int) tree[m].Len != (unsigned int) bits) {
                 Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
                 s->opt_len += ((long)bits - (long)tree[m].Len)
                               *(long)tree[m].Freq;
-                tree[m].Len = (ush)bits;
+                tree[m].Len = (unsigned short)bits;
             }
             n--;
         }
@@ -492,13 +308,13 @@ local void gen_bitlen(deflate_state *s, tree_desc *desc)
  * OUT assertion: the field code is set for all tree elements of non
  *     zero code length.
  */
-local void gen_codes (ct_data *tree, int max_code, ush *bl_count)
+static void gen_codes(
+    ct_data *tree,             /* the tree to decorate */
+    int max_code,              /* largest code with non zero frequency */
+    unsigned short *bl_count   /* number of codes at each bit length */)
 {
-    /* tree: the tree to decorate */
-    /* max_code: largest code with non zero frequency */
-    /* bl_count: number of codes at each bit length */
-    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
-    ush code = 0;              /* running code value */
+    unsigned short next_code[MAX_BITS+1]; /* next code value for each bit length */
+    unsigned short code = 0;              /* running code value */
     int bits;                  /* bit index */
     int n;                     /* code index */
 
@@ -534,9 +350,9 @@ local void gen_codes (ct_data *tree, int max_code, ush *bl_count)
  *     and corresponding code. The length opt_len is updated; static_len is
  *     also updated if stree is not null. The field max_code is set.
  */
-local void build_tree(deflate_state *s, tree_desc *desc)
+static void build_tree(deflate_state *s,
+                       tree_desc *desc /* the tree descriptor */)
 {
-    /* desc: the tree descriptor */
     ct_data *tree         = desc->dyn_tree;
     const ct_data *stree  = desc->stat_desc->static_tree;
     int elems             = desc->stat_desc->elems;
@@ -591,9 +407,9 @@ local void build_tree(deflate_state *s, tree_desc *desc)
 
         /* Create a new node father of n and m */
         tree[node].Freq = tree[n].Freq + tree[m].Freq;
-        s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?
-                                s->depth[n] : s->depth[m]) + 1);
-        tree[n].Dad = tree[m].Dad = (ush)node;
+        s->depth[node] = (unsigned char)((s->depth[n] >= s->depth[m] ?
+                                          s->depth[n] : s->depth[m]) + 1);
+        tree[n].Dad = tree[m].Dad = (unsigned short)node;
 #ifdef DUMP_BL_TREE
         if (tree == s->bl_tree) {
             fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
@@ -621,10 +437,11 @@ local void build_tree(deflate_state *s, tree_desc *desc)
  * Scan a literal or distance tree to determine the frequencies of the codes
  * in the bit length tree.
  */
-local void scan_tree (deflate_state *s, ct_data *tree, int max_code)
+static void scan_tree(
+    deflate_state *s,
+    ct_data *tree,   /* the tree to be scanned */
+    int max_code     /* and its largest code of non zero frequency */)
 {
-    /* tree: the tree to be scanned */
-    /* max_code: and its largest code of non zero frequency */
     int n;                     /* iterates over all tree elements */
     int prevlen = -1;          /* last emitted length */
     int curlen;                /* length of current code */
@@ -634,7 +451,7 @@ local void scan_tree (deflate_state *s, ct_data *tree, int max_code)
     int min_count = 4;         /* min repeat count */
 
     if (nextlen == 0) max_count = 138, min_count = 3;
-    tree[max_code+1].Len = (ush)0xffff; /* guard */
+    tree[max_code+1].Len = (unsigned short)0xffff; /* guard */
 
     for (n = 0; n <= max_code; n++) {
         curlen = nextlen; nextlen = tree[n+1].Len;
@@ -665,10 +482,11 @@ local void scan_tree (deflate_state *s, ct_data *tree, int max_code)
  * Send a literal or distance tree in compressed form, using the codes in
  * bl_tree.
  */
-local void send_tree (deflate_state *s, ct_data *tree, int max_code)
+static void send_tree(
+    deflate_state *s,
+    ct_data *tree,      /* the tree to be scanned */
+    int max_code        /* and its largest code of non zero frequency */)
 {
-    /* tree: the tree to be scanned */
-    /* max_code and its largest code of non zero frequency */
     int n;                     /* iterates over all tree elements */
     int prevlen = -1;          /* last emitted length */
     int curlen;                /* length of current code */
@@ -715,7 +533,7 @@ local void send_tree (deflate_state *s, ct_data *tree, int max_code)
  * Construct the Huffman tree for the bit lengths and return the index in
  * bl_order of the last bit length code to send.
  */
-local int build_bl_tree(deflate_state *s)
+static int build_bl_tree(deflate_state *s)
 {
     int max_blindex;  /* index of last bit length code of non zero freq */
 
@@ -749,7 +567,9 @@ local int build_bl_tree(deflate_state *s)
  * lengths of the bit length codes, the literal tree and the distance tree.
  * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
  */
-local void send_all_trees(deflate_state *s, int lcodes, int dcodes, int blcodes)
+static void send_all_trees(
+    deflate_state *s,
+    int lcodes, int dcodes, int blcodes /* number of codes for each tree */)
 {
     int rank;                    /* index in bl_order */
 
@@ -776,17 +596,18 @@ local void send_all_trees(deflate_state *s, int lcodes, int dcodes, int blcodes)
 /* ===========================================================================
  * Send a stored block
  */
-void ZLIB_INTERNAL _tr_stored_block(deflate_state *s,
-                                    char *buf,      /* input block */
-                                    ulg stored_len, /* length of input block */
-                                    int last)        /* one if this is the last block for a file */
+void ZLIB_INTERNAL _tr_stored_block(
+    deflate_state *s,
+    char *buf,                  /* input block */
+    unsigned long stored_len,   /* length of input block */
+    int last                    /* one if this is the last block for a file */)
 {
     send_bits(s, (STORED_BLOCK<<1)+last, 3);    /* send block type */
 #ifdef DEBUG
-    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
+    s->compressed_len = (s->compressed_len + 3 + 7) & (unsigned long)~7L;
     s->compressed_len += (stored_len + 4) << 3;
 #endif
-    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
+    copy_block(s, buf, (unsigned int)stored_len, 1); /* with header */
 }
 
 /* ===========================================================================
@@ -815,12 +636,13 @@ void ZLIB_INTERNAL _tr_align(deflate_state *s)
  * Determine the best encoding for the current block: dynamic trees, static
  * trees or store, and output the encoded block to the zip file.
  */
-void ZLIB_INTERNAL _tr_flush_block(deflate_state *s, char *buf, ulg stored_len, int last)
+void ZLIB_INTERNAL _tr_flush_block(
+    deflate_state *s,
+    char *buf,                  /* input block, or NULL if too old */
+    unsigned long stored_len,   /* length of input block */
+    int last                    /* one if this is the last block for a file */)
 {
-    /* buf: input block, or NULL if too old */
-    /* stored_len: length of input block */
-    /* last: one if this is the last block for a file */
-    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
+    unsigned long opt_lenb, static_lenb; /* opt_len and static_len in bytes */
     int max_blindex = 0;  /* index of last bit length code of non zero freq */
 
     /* Build the Huffman trees unless a stored block is forced */
@@ -899,7 +721,7 @@ void ZLIB_INTERNAL _tr_flush_block(deflate_state *s, char *buf, ulg stored_len,
     }
     Assert (s->compressed_len == s->bits_sent, "bad compressed size");
     /* The above check is made mod 2^32, for files larger than 512 MB
-     * and uLong implemented on 32 bits.
+     * and unsigned long implemented on 32 bits.
      */
     init_block(s);
 
@@ -917,12 +739,13 @@ void ZLIB_INTERNAL _tr_flush_block(deflate_state *s, char *buf, ulg stored_len,
  * Save the match info and tally the frequency counts. Return true if
  * the current block must be flushed.
  */
-int ZLIB_INTERNAL _tr_tally (deflate_state *s, unsigned dist, unsigned lc)
+int ZLIB_INTERNAL _tr_tally(
+    deflate_state *s,
+    unsigned int dist, /* distance of matched string */
+    unsigned int lc /* match length-MIN_MATCH or unmatched char (if dist==0) */)
 {
-    /* dist: distance of matched string */
-    /* lc: match length-MIN_MATCH or unmatched char (if dist==0) */
-    s->d_buf[s->last_lit] = (ush)dist;
-    s->l_buf[s->last_lit++] = (uch)lc;
+    s->d_buf[s->last_lit] = (unsigned short)dist;
+    s->l_buf[s->last_lit++] = (unsigned char)lc;
     if (dist == 0) {
         /* lc is the unmatched char */
         s->dyn_ltree[lc].Freq++;
@@ -930,9 +753,9 @@ int ZLIB_INTERNAL _tr_tally (deflate_state *s, unsigned dist, unsigned lc)
         s->matches++;
         /* Here, lc is the match length - MIN_MATCH */
         dist--;             /* dist = match distance - 1 */
-        Assert((ush)dist < (ush)MAX_DIST(s) &&
-               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
-               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
+        Assert((unsigned short)dist < (unsigned short)MAX_DIST(s) &&
+               (unsigned short)lc <= (unsigned short)(MAX_MATCH-MIN_MATCH) &&
+               (unsigned short)d_code(dist) < (unsigned short)D_CODES,  "_tr_tally: bad match");
 
         s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
         s->dyn_dtree[d_code(dist)].Freq++;
@@ -942,11 +765,11 @@ int ZLIB_INTERNAL _tr_tally (deflate_state *s, unsigned dist, unsigned lc)
     /* Try to guess if it is profitable to stop the current block here */
     if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
         /* Compute an upper bound for the compressed length */
-        ulg out_length = (ulg)s->last_lit*8L;
-        ulg in_length = (ulg)((long)s->strstart - s->block_start);
+        unsigned long out_length = (unsigned long)s->last_lit*8L;
+        unsigned long in_length = (unsigned long)((long)s->strstart - s->block_start);
         int dcode;
         for (dcode = 0; dcode < D_CODES; dcode++) {
-            out_length += (ulg)s->dyn_dtree[dcode].Freq *
+            out_length += (unsigned long)s->dyn_dtree[dcode].Freq *
                 (5L+extra_dbits[dcode]);
         }
         out_length >>= 3;
@@ -966,15 +789,16 @@ int ZLIB_INTERNAL _tr_tally (deflate_state *s, unsigned dist, unsigned lc)
 /* ===========================================================================
  * Send the block data compressed using the given Huffman trees
  */
-local void compress_block(deflate_state *s, const ct_data *ltree, const ct_data *dtree)
+static void compress_block(
+    deflate_state *s,
+    const ct_data *ltree, /* literal tree */
+    const ct_data *dtree  /* distance tree */)
 {
-    /* ltree: literal tree */
-    /* dtree: distance tree */
-    unsigned dist;      /* distance of matched string */
-    int lc;             /* match length or unmatched char (if dist == 0) */
-    unsigned lx = 0;    /* running index in l_buf */
-    unsigned code;      /* the code to send */
-    int extra;          /* number of extra bits to send */
+    unsigned int dist;    /* distance of matched string */
+    int lc;               /* match length or unmatched char (if dist == 0) */
+    unsigned int lx = 0;  /* running index in l_buf */
+    unsigned int code;    /* the code to send */
+    int extra;            /* number of extra bits to send */
 
     if (s->last_lit != 0) do {
         dist = s->d_buf[lx];
@@ -1004,7 +828,7 @@ local void compress_block(deflate_state *s, const ct_data *ltree, const ct_data
         } /* literal or match pair ? */
 
         /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
-        Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
+        Assert((unsigned int)(s->pending) < s->lit_bufsize + 2*lx,
                "pendingBuf overflow");
 
     } while (lx < s->last_lit);
@@ -1025,7 +849,7 @@ local void compress_block(deflate_state *s, const ct_data *ltree, const ct_data
  *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
  * IN assertion: the fields Freq of dyn_ltree are set.
  */
-local int detect_data_type(deflate_state *s)
+static int detect_data_type(deflate_state *s)
 {
     /* black_mask is the bit mask of black-listed bytes
      * set bits 0..6, 14..25, and 28..31
@@ -1058,11 +882,11 @@ local int detect_data_type(deflate_state *s)
  * method would use a table)
  * IN assertion: 1 <= len <= 15
  */
-local unsigned bi_reverse(unsigned code, int len)
+static unsigned int bi_reverse(
+    unsigned int code, /* the value to invert */
+    int len            /* its bit length */)
 {
-    /* code: the value to invert */
-    /* len: its bit length */
-    register unsigned res = 0;
+    unsigned int res = 0;
     do {
         res |= code & 1;
         code >>= 1, res <<= 1;
@@ -1073,14 +897,14 @@ local unsigned bi_reverse(unsigned code, int len)
 /* ===========================================================================
  * Flush the bit buffer, keeping at most 7 bits in it.
  */
-local void bi_flush(deflate_state *s)
+static void bi_flush(deflate_state *s)
 {
     if (s->bi_valid == 16) {
         put_short(s, s->bi_buf);
         s->bi_buf = 0;
         s->bi_valid = 0;
     } else if (s->bi_valid >= 8) {
-        put_byte(s, (Byte)s->bi_buf);
+        put_byte(s, (unsigned char)s->bi_buf);
         s->bi_buf >>= 8;
         s->bi_valid -= 8;
     }
@@ -1094,7 +918,7 @@ ZLIB_INTERNAL void bi_windup(deflate_state *s)
     if (s->bi_valid > 8) {
         put_short(s, s->bi_buf);
     } else if (s->bi_valid > 0) {
-        put_byte(s, (Byte)s->bi_buf);
+        put_byte(s, (unsigned char)s->bi_buf);
     }
     s->bi_buf = 0;
     s->bi_valid = 0;
@@ -1107,22 +931,23 @@ ZLIB_INTERNAL void bi_windup(deflate_state *s)
  * Copy a stored block, storing first the length and its
  * one's complement if requested.
  */
-local void copy_block(deflate_state *s, char *buf, unsigned len, int header)
+static void copy_block(
+    deflate_state *s,
+    char          *buf,    /* the input data */
+    unsigned int   len,    /* its length */
+    int            header  /* true if block header must be written */)
 {
-    /* buf: the input data */
-    /* len: its length */
-    /* header: true if block header must be written */
     bi_windup(s);        /* align on byte boundary */
 
     if (header) {
-        put_short(s, (ush)len);
-        put_short(s, (ush)~len);
+        put_short(s, (unsigned short)len);
+        put_short(s, (unsigned short)~len);
 #ifdef DEBUG
         s->bits_sent += 2*16;
 #endif
     }
 #ifdef DEBUG
-    s->bits_sent += (ulg)len<<3;
+    s->bits_sent += (unsigned long)len<<3;
 #endif
     while (len--) {
         put_byte(s, *buf++);
diff --git a/trees.h b/trees.h
index 9a4ce94..864d3f4 100644
--- a/trees.h
+++ b/trees.h
@@ -61,7 +61,7 @@ ZLIB_INTERNAL const ct_data static_ltree[L_CODES+2] = {
 {{163},{  8}}, {{ 99},{  8}}, {{227},{  8}}
 };
 
-local const ct_data static_dtree[D_CODES] = {
+static const ct_data static_dtree[D_CODES] = {
 {{ 0},{ 5}}, {{16},{ 5}}, {{ 8},{ 5}}, {{24},{ 5}}, {{ 4},{ 5}},
 {{20},{ 5}}, {{12},{ 5}}, {{28},{ 5}}, {{ 2},{ 5}}, {{18},{ 5}},
 {{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},
@@ -70,7 +70,7 @@ local const ct_data static_dtree[D_CODES] = {
 {{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}
 };
 
-const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {
+const unsigned char ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {
  0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
@@ -99,7 +99,7 @@ const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {
 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
 };
 
-const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {
+const unsigned char ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {
  0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
@@ -115,12 +115,12 @@ const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {
 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
 };
 
-local const int base_length[LENGTH_CODES] = {
+static const int base_length[LENGTH_CODES] = {
 0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
 64, 80, 96, 112, 128, 160, 192, 224, 0
 };
 
-local const int base_dist[D_CODES] = {
+static const int base_dist[D_CODES] = {
     0,     1,     2,     3,     4,     6,     8,    12,    16,    24,
    32,    48,    64,    96,   128,   192,   256,   384,   512,   768,
  1024,  1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576
diff --git a/uncompr.c b/uncompr.c
index fada0c6..4fd8706 100644
--- a/uncompr.c
+++ b/uncompr.c
@@ -21,20 +21,19 @@
    enough memory, Z_BUF_ERROR if there was not enough room in the output
    buffer, or Z_DATA_ERROR if the input data was corrupted.
 */
-int ZEXPORT uncompress (dest, destLen, source, sourceLen)
-    Byte *dest;
-    uLong *destLen;
-    const Byte *source;
-    uLong sourceLen;
+int ZEXPORT uncompress(unsigned char *dest,
+                       unsigned long *destLen,
+                       const unsigned char *source,
+                       unsigned long sourceLen)
 {
     z_stream stream;
     int err;
 
-    stream.next_in = (z_const Byte *)source;
-    stream.avail_in = (uInt)sourceLen;
+    stream.next_in = (const unsigned char *)source;
+    stream.avail_in = (unsigned int)sourceLen;
     stream.next_out = dest;
-    stream.avail_out = (uInt)*destLen;
-    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
+    stream.avail_out = (unsigned int)*destLen;
+    if ((unsigned long)stream.avail_out != *destLen) return Z_BUF_ERROR;
 
     stream.zalloc = (alloc_func)0;
     stream.zfree = (free_func)0;
diff --git a/zconf.h b/zconf.h
index 4a4beaf..6b05ec4 100644
--- a/zconf.h
+++ b/zconf.h
@@ -8,194 +8,36 @@
 #ifndef ZCONF_H
 #define ZCONF_H
 
-/*
- * If you *really* need a unique prefix for all types and library functions,
- * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
- * Even better than compiling with -DZ_PREFIX would be to use configure to set
- * this permanently in zconf.h using "./configure --zprefix".
- */
-#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */
-#  define Z_PREFIX_SET
-
-/* all linked symbols */
-#  define _dist_code            z__dist_code
-#  define _length_code          z__length_code
-#  define _tr_align             z__tr_align
-#  define _tr_flush_bits        z__tr_flush_bits
-#  define _tr_flush_block       z__tr_flush_block
-#  define _tr_init              z__tr_init
-#  define _tr_stored_block      z__tr_stored_block
-#  define _tr_tally             z__tr_tally
-#  define adler32               z_adler32
-#  define adler32_combine       z_adler32_combine
-#  define adler32_combine64     z_adler32_combine64
-#  ifndef Z_SOLO
-#    define compress              z_compress
-#    define compress2             z_compress2
-#    define compressBound         z_compressBound
-#  endif
-#  define crc32                 z_crc32
-#  define crc32_combine         z_crc32_combine
-#  define crc32_combine64       z_crc32_combine64
-#  define deflate               z_deflate
-#  define deflateBound          z_deflateBound
-#  define deflateCopy           z_deflateCopy
-#  define deflateEnd            z_deflateEnd
-#  define deflateInit2_         z_deflateInit2_
-#  define deflateInit_          z_deflateInit_
-#  define deflateParams         z_deflateParams
-#  define deflatePending        z_deflatePending
-#  define deflatePrime          z_deflatePrime
-#  define deflateReset          z_deflateReset
-#  define deflateResetKeep      z_deflateResetKeep
-#  define deflateSetDictionary  z_deflateSetDictionary
-#  define deflateSetHeader      z_deflateSetHeader
-#  define deflateTune           z_deflateTune
-#  define deflate_copyright     z_deflate_copyright
-#  define get_crc_table         z_get_crc_table
-#  ifndef Z_SOLO
-#    define gz_error              z_gz_error
-#    define gz_intmax             z_gz_intmax
-#    define gz_strwinerror        z_gz_strwinerror
-#    define gzbuffer              z_gzbuffer
-#    define gzclearerr            z_gzclearerr
-#    define gzclose               z_gzclose
-#    define gzclose_r             z_gzclose_r
-#    define gzclose_w             z_gzclose_w
-#    define gzdirect              z_gzdirect
-#    define gzdopen               z_gzdopen
-#    define gzeof                 z_gzeof
-#    define gzerror               z_gzerror
-#    define gzflush               z_gzflush
-#    define gzgetc                z_gzgetc
-#    define gzgetc_               z_gzgetc_
-#    define gzgets                z_gzgets
-#    define gzoffset              z_gzoffset
-#    define gzoffset64            z_gzoffset64
-#    define gzopen                z_gzopen
-#    define gzopen64              z_gzopen64
-#    ifdef _WIN32
-#      define gzopen_w              z_gzopen_w
-#    endif
-#    define gzprintf              z_gzprintf
-#    define gzvprintf             z_gzvprintf
-#    define gzputc                z_gzputc
-#    define gzputs                z_gzputs
-#    define gzread                z_gzread
-#    define gzrewind              z_gzrewind
-#    define gzseek                z_gzseek
-#    define gzseek64              z_gzseek64
-#    define gzsetparams           z_gzsetparams
-#    define gztell                z_gztell
-#    define gztell64              z_gztell64
-#    define gzungetc              z_gzungetc
-#    define gzwrite               z_gzwrite
-#  endif
-#  define inflate               z_inflate
-#  define inflateBack           z_inflateBack
-#  define inflateBackEnd        z_inflateBackEnd
-#  define inflateBackInit_      z_inflateBackInit_
-#  define inflateCopy           z_inflateCopy
-#  define inflateEnd            z_inflateEnd
-#  define inflateGetHeader      z_inflateGetHeader
-#  define inflateInit2_         z_inflateInit2_
-#  define inflateInit_          z_inflateInit_
-#  define inflateMark           z_inflateMark
-#  define inflatePrime          z_inflatePrime
-#  define inflateReset          z_inflateReset
-#  define inflateReset2         z_inflateReset2
-#  define inflateSetDictionary  z_inflateSetDictionary
-#  define inflateGetDictionary  z_inflateGetDictionary
-#  define inflateSync           z_inflateSync
-#  define inflateSyncPoint      z_inflateSyncPoint
-#  define inflateUndermine      z_inflateUndermine
-#  define inflateResetKeep      z_inflateResetKeep
-#  define inflate_copyright     z_inflate_copyright
-#  define inflate_fast          z_inflate_fast
-#  define inflate_table         z_inflate_table
-#  ifndef Z_SOLO
-#    define uncompress            z_uncompress
-#  endif
-#  define zError                z_zError
-#  ifndef Z_SOLO
-#    define zcalloc               z_zcalloc
-#    define zcfree                z_zcfree
-#  endif
-#  define zlibCompileFlags      z_zlibCompileFlags
-#  define zlibVersion           z_zlibVersion
-
-/* all zlib typedefs in zlib.h and zconf.h */
-#  define Byte                  z_Byte
-#  define Bytef                 z_Bytef
-#  define alloc_func            z_alloc_func
-#  define charf                 z_charf
-#  define free_func             z_free_func
-#  ifndef Z_SOLO
-#    define gzFile                z_gzFile
-#  endif
-#  define gz_header             z_gz_header
-#  define gz_headerp            z_gz_headerp
-#  define in_func               z_in_func
-#  define intf                  z_intf
-#  define out_func              z_out_func
-#  define uInt                  z_uInt
-#  define uIntf                 z_uIntf
-#  define uLong                 z_uLong
-#  define uLongf                z_uLongf
-#  define voidp                 z_voidp
-#  define voidpc                z_voidpc
-#  define voidpf                z_voidpf
-
-/* all zlib structs in zlib.h and zconf.h */
-#  define gz_header_s           z_gz_header_s
-#  define internal_state        z_internal_state
-
-#endif
-
-#if defined(_WINDOWS) && !defined(WINDOWS)
-#  define WINDOWS
-#endif
-#if defined(_WIN32) || defined(__WIN32__)
-#  ifndef WIN32
-#    define WIN32
-#  endif
-#endif
-
-#ifdef __STDC_VERSION__
-#  if __STDC_VERSION__ >= 199901L
-#    ifndef STDC99
-#      define STDC99
-#    endif
-#  endif
-#endif
-
-#if defined(ZLIB_CONST) && !defined(z_const)
+#include <sys/types.h>
+
+#include <limits.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <unistd.h>
+
+/* Transition the public interface to const if requested by the application.
+   libz itself is always built with const. */
+#ifndef z_const
 #  define z_const const
 #else
 #  define z_const
 #endif
 
 /* Maximum value for memLevel in deflateInit2 */
-#ifndef MAX_MEM_LEVEL
-#  define MAX_MEM_LEVEL 9
-#endif
+#define MAX_MEM_LEVEL 9
 
-/* Maximum value for windowBits in deflateInit2 and inflateInit2.
- * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
- * created by gzip. (Files created by minigzip can still be extracted by
- * gzip.)
- */
-#ifndef MAX_WBITS
-#  define MAX_WBITS   15 /* 32K LZ77 window */
-#endif
+/* Maximum value for windowBits in deflateInit2 and inflateInit2. */
+#define MAX_WBITS   15 /* 32K LZ77 window */
 
 /* The memory requirements for deflate are (in bytes):
             (1 << (windowBits+2)) +  (1 << (memLevel+9))
  that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
  plus a few kilobytes for small objects. For example, if you want to reduce
- the default memory requirements from 256K to 128K, compile with
-     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
- Of course this will generally degrade compression (there's no free lunch).
+ the default memory requirements from 256K to 128K, define MAX_WBITS to 14 and
+ define MAX_MEM_LEVEL to 7. Of course this will generally degrade compression
+ (there's no free lunch).
 
    The memory requirements for inflate are (in bytes) 1 << windowBits
  that is, 32K for windowBits=15 (default value) plus a few kilobytes
@@ -204,39 +46,17 @@
 
                         /* Type declarations */
 
-/* OF() definition is kept for compatibility purposes */
-#ifndef OF /* function prototypes */
-#  define OF(args)  args
-#endif
-
-#ifndef Z_ARG /* function prototypes for stdarg */
-#  define Z_ARG(args)  args
-#endif
-
-#if defined(WINDOWS) || defined(WIN32)
+#ifdef _WIN32
    /* If building or using zlib as a DLL, define ZLIB_DLL.
     * This is not mandatory, but it offers a little performance increase.
     */
 #  ifdef ZLIB_DLL
-#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
-#      ifdef ZLIB_INTERNAL
-#        define ZEXTERN extern __declspec(dllexport)
-#      else
-#        define ZEXTERN extern __declspec(dllimport)
-#      endif
+#    ifdef ZLIB_INTERNAL
+#      define ZEXTERN extern __declspec(dllexport)
+#    else
+#      define ZEXTERN extern __declspec(dllimport)
 #    endif
 #  endif  /* ZLIB_DLL */
-   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
-    * define ZLIB_WINAPI.
-    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
-    */
-#  ifdef ZLIB_WINAPI
-#    include <windows.h>
-     /* No need for _export, use ZLIB.DEF instead. */
-     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
-#    define ZEXPORT WINAPI
-#    define ZEXPORTVA WINAPIV
-#  endif
 #endif
 
 #ifndef ZEXTERN
@@ -249,110 +69,6 @@
 #  define ZEXPORTVA
 #endif
 
-#if !defined(__MACTYPES__)
-typedef unsigned char  Byte;  /* 8 bits */
-#endif
-typedef unsigned int   uInt;  /* 16 bits or more */
-typedef unsigned long  uLong; /* 32 bits or more */
-
-typedef Byte  Bytef;
-typedef char  charf;
-typedef int   intf;
-typedef uInt  uIntf;
-typedef uLong uLongf;
-
-typedef void const *voidpc;
-typedef void       *voidpf;
-typedef void       *voidp;
-
-#if !defined(Z_U4) && !defined(Z_SOLO)
-#  include <limits.h>
-#  if (UINT_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned
-#  elif (ULONG_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned long
-#  elif (USHRT_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned short
-#  endif
-#endif
-
-#ifdef Z_U4
-   typedef Z_U4 z_crc_t;
-#else
-   typedef unsigned long z_crc_t;
-#endif
-
-#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_UNISTD_H
-#endif
-
-#ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_STDARG_H
-#endif
-
-#ifndef Z_SOLO
-#  include <sys/types.h>      /* for off_t */
-#  include <stdarg.h>         /* for va_list */
-#endif
-
-#ifdef _WIN32
-#  ifndef Z_SOLO
-#    include <stddef.h>         /* for wchar_t */
-#  endif
-#endif
-
-/* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
- * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
- * though the former does not conform to the LFS document), but considering
- * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
- * equivalently requesting no 64-bit operations
- */
-#if defined(_LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1
-#  undef _LARGEFILE64_SOURCE
-#endif
-
-#ifndef Z_SOLO
-#  if defined(Z_HAVE_UNISTD_H) || defined(_LARGEFILE64_SOURCE)
-#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */
-#    ifdef VMS
-#      include <unixio.h>       /* for off_t */
-#    endif
-#    ifndef z_off_t
-#      define z_off_t off_t
-#    endif
-#  endif
-#endif
-
-#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0
-#  define Z_LFS64
-#endif
-
-#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)
-#  define Z_LARGE64
-#endif
-
-#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)
-#  define Z_WANT64
-#endif
-
-#if !defined(SEEK_SET) && !defined(Z_SOLO)
-#  define SEEK_SET        0       /* Seek from beginning of file.  */
-#  define SEEK_CUR        1       /* Seek from current position.  */
-#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
-#endif
-
-#ifndef z_off_t
-#  define z_off_t long
-#endif
-
-#if !defined(_WIN32) && defined(Z_LARGE64)
-#  define z_off64_t off64_t
-#else
-#  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)
-#    define z_off64_t __int64
-#  else
-#    define z_off64_t z_off_t
-#  endif
-#endif
+typedef uint32_t z_crc_t;
 
 #endif /* ZCONF_H */
diff --git a/zconf.h.in b/zconf.h.in
index 4a4beaf..6b05ec4 100644
--- a/zconf.h.in
+++ b/zconf.h.in
@@ -8,194 +8,36 @@
 #ifndef ZCONF_H
 #define ZCONF_H
 
-/*
- * If you *really* need a unique prefix for all types and library functions,
- * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
- * Even better than compiling with -DZ_PREFIX would be to use configure to set
- * this permanently in zconf.h using "./configure --zprefix".
- */
-#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */
-#  define Z_PREFIX_SET
-
-/* all linked symbols */
-#  define _dist_code            z__dist_code
-#  define _length_code          z__length_code
-#  define _tr_align             z__tr_align
-#  define _tr_flush_bits        z__tr_flush_bits
-#  define _tr_flush_block       z__tr_flush_block
-#  define _tr_init              z__tr_init
-#  define _tr_stored_block      z__tr_stored_block
-#  define _tr_tally             z__tr_tally
-#  define adler32               z_adler32
-#  define adler32_combine       z_adler32_combine
-#  define adler32_combine64     z_adler32_combine64
-#  ifndef Z_SOLO
-#    define compress              z_compress
-#    define compress2             z_compress2
-#    define compressBound         z_compressBound
-#  endif
-#  define crc32                 z_crc32
-#  define crc32_combine         z_crc32_combine
-#  define crc32_combine64       z_crc32_combine64
-#  define deflate               z_deflate
-#  define deflateBound          z_deflateBound
-#  define deflateCopy           z_deflateCopy
-#  define deflateEnd            z_deflateEnd
-#  define deflateInit2_         z_deflateInit2_
-#  define deflateInit_          z_deflateInit_
-#  define deflateParams         z_deflateParams
-#  define deflatePending        z_deflatePending
-#  define deflatePrime          z_deflatePrime
-#  define deflateReset          z_deflateReset
-#  define deflateResetKeep      z_deflateResetKeep
-#  define deflateSetDictionary  z_deflateSetDictionary
-#  define deflateSetHeader      z_deflateSetHeader
-#  define deflateTune           z_deflateTune
-#  define deflate_copyright     z_deflate_copyright
-#  define get_crc_table         z_get_crc_table
-#  ifndef Z_SOLO
-#    define gz_error              z_gz_error
-#    define gz_intmax             z_gz_intmax
-#    define gz_strwinerror        z_gz_strwinerror
-#    define gzbuffer              z_gzbuffer
-#    define gzclearerr            z_gzclearerr
-#    define gzclose               z_gzclose
-#    define gzclose_r             z_gzclose_r
-#    define gzclose_w             z_gzclose_w
-#    define gzdirect              z_gzdirect
-#    define gzdopen               z_gzdopen
-#    define gzeof                 z_gzeof
-#    define gzerror               z_gzerror
-#    define gzflush               z_gzflush
-#    define gzgetc                z_gzgetc
-#    define gzgetc_               z_gzgetc_
-#    define gzgets                z_gzgets
-#    define gzoffset              z_gzoffset
-#    define gzoffset64            z_gzoffset64
-#    define gzopen                z_gzopen
-#    define gzopen64              z_gzopen64
-#    ifdef _WIN32
-#      define gzopen_w              z_gzopen_w
-#    endif
-#    define gzprintf              z_gzprintf
-#    define gzvprintf             z_gzvprintf
-#    define gzputc                z_gzputc
-#    define gzputs                z_gzputs
-#    define gzread                z_gzread
-#    define gzrewind              z_gzrewind
-#    define gzseek                z_gzseek
-#    define gzseek64              z_gzseek64
-#    define gzsetparams           z_gzsetparams
-#    define gztell                z_gztell
-#    define gztell64              z_gztell64
-#    define gzungetc              z_gzungetc
-#    define gzwrite               z_gzwrite
-#  endif
-#  define inflate               z_inflate
-#  define inflateBack           z_inflateBack
-#  define inflateBackEnd        z_inflateBackEnd
-#  define inflateBackInit_      z_inflateBackInit_
-#  define inflateCopy           z_inflateCopy
-#  define inflateEnd            z_inflateEnd
-#  define inflateGetHeader      z_inflateGetHeader
-#  define inflateInit2_         z_inflateInit2_
-#  define inflateInit_          z_inflateInit_
-#  define inflateMark           z_inflateMark
-#  define inflatePrime          z_inflatePrime
-#  define inflateReset          z_inflateReset
-#  define inflateReset2         z_inflateReset2
-#  define inflateSetDictionary  z_inflateSetDictionary
-#  define inflateGetDictionary  z_inflateGetDictionary
-#  define inflateSync           z_inflateSync
-#  define inflateSyncPoint      z_inflateSyncPoint
-#  define inflateUndermine      z_inflateUndermine
-#  define inflateResetKeep      z_inflateResetKeep
-#  define inflate_copyright     z_inflate_copyright
-#  define inflate_fast          z_inflate_fast
-#  define inflate_table         z_inflate_table
-#  ifndef Z_SOLO
-#    define uncompress            z_uncompress
-#  endif
-#  define zError                z_zError
-#  ifndef Z_SOLO
-#    define zcalloc               z_zcalloc
-#    define zcfree                z_zcfree
-#  endif
-#  define zlibCompileFlags      z_zlibCompileFlags
-#  define zlibVersion           z_zlibVersion
-
-/* all zlib typedefs in zlib.h and zconf.h */
-#  define Byte                  z_Byte
-#  define Bytef                 z_Bytef
-#  define alloc_func            z_alloc_func
-#  define charf                 z_charf
-#  define free_func             z_free_func
-#  ifndef Z_SOLO
-#    define gzFile                z_gzFile
-#  endif
-#  define gz_header             z_gz_header
-#  define gz_headerp            z_gz_headerp
-#  define in_func               z_in_func
-#  define intf                  z_intf
-#  define out_func              z_out_func
-#  define uInt                  z_uInt
-#  define uIntf                 z_uIntf
-#  define uLong                 z_uLong
-#  define uLongf                z_uLongf
-#  define voidp                 z_voidp
-#  define voidpc                z_voidpc
-#  define voidpf                z_voidpf
-
-/* all zlib structs in zlib.h and zconf.h */
-#  define gz_header_s           z_gz_header_s
-#  define internal_state        z_internal_state
-
-#endif
-
-#if defined(_WINDOWS) && !defined(WINDOWS)
-#  define WINDOWS
-#endif
-#if defined(_WIN32) || defined(__WIN32__)
-#  ifndef WIN32
-#    define WIN32
-#  endif
-#endif
-
-#ifdef __STDC_VERSION__
-#  if __STDC_VERSION__ >= 199901L
-#    ifndef STDC99
-#      define STDC99
-#    endif
-#  endif
-#endif
-
-#if defined(ZLIB_CONST) && !defined(z_const)
+#include <sys/types.h>
+
+#include <limits.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <unistd.h>
+
+/* Transition the public interface to const if requested by the application.
+   libz itself is always built with const. */
+#ifndef z_const
 #  define z_const const
 #else
 #  define z_const
 #endif
 
 /* Maximum value for memLevel in deflateInit2 */
-#ifndef MAX_MEM_LEVEL
-#  define MAX_MEM_LEVEL 9
-#endif
+#define MAX_MEM_LEVEL 9
 
-/* Maximum value for windowBits in deflateInit2 and inflateInit2.
- * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
- * created by gzip. (Files created by minigzip can still be extracted by
- * gzip.)
- */
-#ifndef MAX_WBITS
-#  define MAX_WBITS   15 /* 32K LZ77 window */
-#endif
+/* Maximum value for windowBits in deflateInit2 and inflateInit2. */
+#define MAX_WBITS   15 /* 32K LZ77 window */
 
 /* The memory requirements for deflate are (in bytes):
             (1 << (windowBits+2)) +  (1 << (memLevel+9))
  that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
  plus a few kilobytes for small objects. For example, if you want to reduce
- the default memory requirements from 256K to 128K, compile with
-     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
- Of course this will generally degrade compression (there's no free lunch).
+ the default memory requirements from 256K to 128K, define MAX_WBITS to 14 and
+ define MAX_MEM_LEVEL to 7. Of course this will generally degrade compression
+ (there's no free lunch).
 
    The memory requirements for inflate are (in bytes) 1 << windowBits
  that is, 32K for windowBits=15 (default value) plus a few kilobytes
@@ -204,39 +46,17 @@
 
                         /* Type declarations */
 
-/* OF() definition is kept for compatibility purposes */
-#ifndef OF /* function prototypes */
-#  define OF(args)  args
-#endif
-
-#ifndef Z_ARG /* function prototypes for stdarg */
-#  define Z_ARG(args)  args
-#endif
-
-#if defined(WINDOWS) || defined(WIN32)
+#ifdef _WIN32
    /* If building or using zlib as a DLL, define ZLIB_DLL.
     * This is not mandatory, but it offers a little performance increase.
     */
 #  ifdef ZLIB_DLL
-#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
-#      ifdef ZLIB_INTERNAL
-#        define ZEXTERN extern __declspec(dllexport)
-#      else
-#        define ZEXTERN extern __declspec(dllimport)
-#      endif
+#    ifdef ZLIB_INTERNAL
+#      define ZEXTERN extern __declspec(dllexport)
+#    else
+#      define ZEXTERN extern __declspec(dllimport)
 #    endif
 #  endif  /* ZLIB_DLL */
-   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
-    * define ZLIB_WINAPI.
-    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
-    */
-#  ifdef ZLIB_WINAPI
-#    include <windows.h>
-     /* No need for _export, use ZLIB.DEF instead. */
-     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
-#    define ZEXPORT WINAPI
-#    define ZEXPORTVA WINAPIV
-#  endif
 #endif
 
 #ifndef ZEXTERN
@@ -249,110 +69,6 @@
 #  define ZEXPORTVA
 #endif
 
-#if !defined(__MACTYPES__)
-typedef unsigned char  Byte;  /* 8 bits */
-#endif
-typedef unsigned int   uInt;  /* 16 bits or more */
-typedef unsigned long  uLong; /* 32 bits or more */
-
-typedef Byte  Bytef;
-typedef char  charf;
-typedef int   intf;
-typedef uInt  uIntf;
-typedef uLong uLongf;
-
-typedef void const *voidpc;
-typedef void       *voidpf;
-typedef void       *voidp;
-
-#if !defined(Z_U4) && !defined(Z_SOLO)
-#  include <limits.h>
-#  if (UINT_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned
-#  elif (ULONG_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned long
-#  elif (USHRT_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned short
-#  endif
-#endif
-
-#ifdef Z_U4
-   typedef Z_U4 z_crc_t;
-#else
-   typedef unsigned long z_crc_t;
-#endif
-
-#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_UNISTD_H
-#endif
-
-#ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_STDARG_H
-#endif
-
-#ifndef Z_SOLO
-#  include <sys/types.h>      /* for off_t */
-#  include <stdarg.h>         /* for va_list */
-#endif
-
-#ifdef _WIN32
-#  ifndef Z_SOLO
-#    include <stddef.h>         /* for wchar_t */
-#  endif
-#endif
-
-/* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
- * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
- * though the former does not conform to the LFS document), but considering
- * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
- * equivalently requesting no 64-bit operations
- */
-#if defined(_LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1
-#  undef _LARGEFILE64_SOURCE
-#endif
-
-#ifndef Z_SOLO
-#  if defined(Z_HAVE_UNISTD_H) || defined(_LARGEFILE64_SOURCE)
-#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */
-#    ifdef VMS
-#      include <unixio.h>       /* for off_t */
-#    endif
-#    ifndef z_off_t
-#      define z_off_t off_t
-#    endif
-#  endif
-#endif
-
-#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0
-#  define Z_LFS64
-#endif
-
-#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)
-#  define Z_LARGE64
-#endif
-
-#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)
-#  define Z_WANT64
-#endif
-
-#if !defined(SEEK_SET) && !defined(Z_SOLO)
-#  define SEEK_SET        0       /* Seek from beginning of file.  */
-#  define SEEK_CUR        1       /* Seek from current position.  */
-#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
-#endif
-
-#ifndef z_off_t
-#  define z_off_t long
-#endif
-
-#if !defined(_WIN32) && defined(Z_LARGE64)
-#  define z_off64_t off64_t
-#else
-#  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)
-#    define z_off64_t __int64
-#  else
-#    define z_off64_t z_off_t
-#  endif
-#endif
+typedef uint32_t z_crc_t;
 
 #endif /* ZCONF_H */
diff --git a/zlib.h b/zlib.h
index 5488524..0b8a3ca 100644
--- a/zlib.h
+++ b/zlib.h
@@ -84,30 +84,30 @@ extern "C" {
   even in case of corrupted input.
 */
 
-typedef void *(*alloc_func) (void *opaque, uInt items, uInt size);
-typedef void  (*free_func)  (void *opaque, void *address);
+typedef void* (*alloc_func)(void* opaque, unsigned int items, unsigned int size);
+typedef void   (*free_func)(void* opaque, void* address);
 
 struct internal_state;
 
 typedef struct z_stream_s {
-    z_const Byte *next_in;     /* next input byte */
-    uInt     avail_in;  /* number of bytes available at next_in */
-    uLong    total_in;  /* total number of input bytes read so far */
+    z_const unsigned char *next_in;  /* next input byte */
+    unsigned int           avail_in; /* number of bytes available at next_in */
+    unsigned long          total_in; /* total number of input bytes read so far */
 
-    Byte    *next_out; /* next output byte should be put there */
-    uInt     avail_out; /* remaining free space at next_out */
-    uLong    total_out; /* total number of bytes output so far */
+    unsigned char *next_out;  /* next output byte should be put there */
+    unsigned int   avail_out; /* remaining free space at next_out */
+    unsigned long  total_out; /* total number of bytes output so far */
 
-    z_const char *msg;  /* last error message, NULL if no error */
+    z_const char          *msg;   /* last error message, NULL if no error */
     struct internal_state *state; /* not visible by applications */
 
-    alloc_func zalloc;  /* used to allocate the internal state */
-    free_func  zfree;   /* used to free the internal state */
-    void      *opaque;  /* private data object passed to zalloc and zfree */
+    alloc_func zalloc; /* used to allocate the internal state */
+    free_func  zfree;  /* used to free the internal state */
+    void      *opaque; /* private data object passed to zalloc and zfree */
 
-    int     data_type;  /* best guess about the data type: binary or text */
-    uLong   adler;      /* adler32 value of the uncompressed data */
-    uLong   reserved;   /* reserved for future use */
+    int             data_type; /* best guess about the data type: binary or text */
+    unsigned long   adler;     /* adler32 value of the uncompressed data */
+    unsigned long   reserved;  /* reserved for future use */
 } z_stream;
 
 typedef z_stream *z_streamp; // Obsolete type, retained for compatability only
@@ -117,20 +117,20 @@ typedef z_stream *z_streamp; // Obsolete type, retained for compatability only
   for more details on the meanings of these fields.
 */
 typedef struct gz_header_s {
-    int     text;       /* true if compressed data believed to be text */
-    uLong   time;       /* modification time */
-    int     xflags;     /* extra flags (not used when writing a gzip file) */
-    int     os;         /* operating system */
-    Byte   *extra;     /* pointer to extra field or Z_NULL if none */
-    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */
-    uInt    extra_max;  /* space at extra (only when reading header) */
-    Byte   *name;      /* pointer to zero-terminated file name or Z_NULL */
-    uInt    name_max;   /* space at name (only when reading header) */
-    Byte   *comment;   /* pointer to zero-terminated comment or Z_NULL */
-    uInt    comm_max;   /* space at comment (only when reading header) */
-    int     hcrc;       /* true if there was or will be a header crc */
-    int     done;       /* true when done reading gzip header (not used
-                           when writing a gzip file) */
+    int            text;      /* true if compressed data believed to be text */
+    unsigned long  time;      /* modification time */
+    int            xflags;    /* extra flags (not used when writing a gzip file) */
+    int            os;        /* operating system */
+    unsigned char *extra;     /* pointer to extra field or NULL if none */
+    unsigned int   extra_len; /* extra field length (valid if extra != NULL) */
+    unsigned int   extra_max; /* space at extra (only when reading header) */
+    unsigned char *name;      /* pointer to zero-terminated file name or NULL */
+    unsigned int   name_max;  /* space at name (only when reading header) */
+    unsigned char *comment;   /* pointer to zero-terminated comment or NULL */
+    unsigned int   comm_max;  /* space at comment (only when reading header) */
+    int            hcrc;      /* true if there was or will be a header crc */
+    int            done;      /* true when done reading gzip header (not used
+                                 when writing a gzip file) */
 } gz_header;
 
 typedef gz_header *gz_headerp;
@@ -147,7 +147,7 @@ typedef gz_header *gz_headerp;
    memory management.  The compression library attaches no meaning to the
    opaque value.
 
-     zalloc must return Z_NULL if there is not enough memory for the object.
+     zalloc must return NULL if there is not enough memory for the object.
    If zlib is used in a multi-threaded application, zalloc and zfree must be
    thread safe.
 
@@ -203,15 +203,13 @@ typedef gz_header *gz_headerp;
 #define Z_DEFLATED   8
 /* The deflate compression method (the only one supported in this version) */
 
-#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
-
 #define zlib_version zlibVersion()
 /* for compatibility with versions < 1.0.2 */
 
 
                         /* basic functions */
 
-ZEXTERN const char * ZEXPORT zlibVersion (void);
+ZEXTERN const char * ZEXPORT zlibVersion(void);
 /* The application can compare zlibVersion and ZLIB_VERSION for consistency.
    If the first character differs, the library code actually used is not
    compatible with the zlib.h header file used by the application.  This check
@@ -223,7 +221,7 @@ ZEXTERN int ZEXPORT deflateInit (z_stream *strm, int level);
 
      Initializes the internal stream state for compression.  The fields
    zalloc, zfree and opaque must be initialized before by the caller.  If
-   zalloc and zfree are set to Z_NULL, deflateInit updates them to use default
+   zalloc and zfree are set to NULL, deflateInit updates them to use default
    allocation functions.
 
      The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
@@ -241,7 +239,7 @@ ZEXTERN int ZEXPORT deflateInit (z_stream *strm, int level);
 */
 
 
-ZEXTERN int ZEXPORT deflate (z_stream *strm, int flush);
+ZEXTERN int ZEXPORT deflate(z_stream *strm, int flush);
 /*
     deflate compresses as much data as possible, and stops when the input
   buffer becomes empty or the output buffer becomes full.  It may introduce
@@ -341,14 +339,14 @@ ZEXTERN int ZEXPORT deflate (z_stream *strm, int flush);
   processed or more output produced), Z_STREAM_END if all input has been
   consumed and all output has been produced (only when flush is set to
   Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
-  if next_in or next_out was Z_NULL), Z_BUF_ERROR if no progress is possible
+  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
   (for example avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not
   fatal, and deflate() can be called again with more input and more output
   space to continue compressing.
 */
 
 
-ZEXTERN int ZEXPORT deflateEnd (z_stream *strm);
+ZEXTERN int ZEXPORT deflateEnd(z_stream *strm);
 /*
      All dynamically allocated data structures for this stream are freed.
    This function discards any unprocessed input and does not flush any pending
@@ -367,11 +365,11 @@ ZEXTERN int ZEXPORT inflateInit (z_stream *strm);
 
      Initializes the internal stream state for decompression.  The fields
    next_in, avail_in, zalloc, zfree and opaque must be initialized before by
-   the caller.  If next_in is not Z_NULL and avail_in is large enough (the
+   the caller.  If next_in is not NULL and avail_in is large enough (the
    exact value depends on the compression method), inflateInit determines the
    compression method from the zlib header and allocates all data structures
    accordingly; otherwise the allocation will be deferred to the first call of
-   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
+   inflate.  If zalloc and zfree are set to NULL, inflateInit updates them to
    use default allocation functions.
 
      inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
@@ -387,7 +385,7 @@ ZEXTERN int ZEXPORT inflateInit (z_stream *strm);
 */
 
 
-ZEXTERN int ZEXPORT inflate (z_stream *strm, int flush);
+ZEXTERN int ZEXPORT inflate(z_stream *strm, int flush);
 /*
     inflate decompresses as much data as possible, and stops when the input
   buffer becomes empty or the output buffer becomes full.  It may introduce
@@ -485,7 +483,7 @@ ZEXTERN int ZEXPORT inflate (z_stream *strm, int flush);
   instead use raw inflate, see inflateInit2() below, or inflateBack() and
   perform their own processing of the gzip header and trailer.  When processing
   gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output
-  producted so far.  The CRC-32 is checked against the gzip trailer.
+  produced so far.  The CRC-32 is checked against the gzip trailer.
 
     inflate() returns Z_OK if some progress has been made (more input processed
   or more output produced), Z_STREAM_END if the end of the compressed data has
@@ -493,7 +491,7 @@ ZEXTERN int ZEXPORT inflate (z_stream *strm, int flush);
   preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
   corrupted (input stream not conforming to the zlib format or incorrect check
   value), Z_STREAM_ERROR if the stream structure was inconsistent (for example
-  next_in or next_out was Z_NULL), Z_MEM_ERROR if there was not enough memory,
+  next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,
   Z_BUF_ERROR if no progress is possible or if there was not enough room in the
   output buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and
   inflate() can be called again with more input and more output space to
@@ -503,7 +501,7 @@ ZEXTERN int ZEXPORT inflate (z_stream *strm, int flush);
 */
 
 
-ZEXTERN int ZEXPORT inflateEnd (z_stream *strm);
+ZEXTERN int ZEXPORT inflateEnd(z_stream *strm);
 /*
      All dynamically allocated data structures for this stream are freed.
    This function discards any unprocessed input and does not flush any pending
@@ -522,12 +520,12 @@ ZEXTERN int ZEXPORT inflateEnd (z_stream *strm);
 */
 
 /*
-ZEXTERN int ZEXPORT deflateInit2 (z_stream *strm,
-                                     int  level,
-                                     int  method,
-                                     int  windowBits,
-                                     int  memLevel,
-                                     int  strategy);
+ZEXTERN int ZEXPORT deflateInit2(z_stream *strm,
+                                 int level,
+                                 int method,
+                                 int windowBits,
+                                 int memLevel,
+                                 int strategy);
 
      This is another version of deflateInit with more compression options.  The
    fields next_in, zalloc, zfree and opaque must be initialized before by the
@@ -582,9 +580,9 @@ ZEXTERN int ZEXPORT deflateInit2 (z_stream *strm,
    compression: this will be done by deflate().
 */
 
-ZEXTERN int ZEXPORT deflateSetDictionary (z_stream *strm,
-                                             const Byte *dictionary,
-                                             uInt  dictLength);
+ZEXTERN int ZEXPORT deflateSetDictionary(z_stream *strm,
+                                         const unsigned char *dictionary,
+                                         unsigned int dictLength);
 /*
      Initializes the compression dictionary from the given byte sequence
    without producing any compressed output.  When using the zlib format, this
@@ -620,14 +618,14 @@ ZEXTERN int ZEXPORT deflateSetDictionary (z_stream *strm,
    adler32 value is not computed and strm->adler is not set.
 
      deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
-   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
+   parameter is invalid (e.g.  dictionary being NULL) or the stream state is
    inconsistent (for example if deflate has already been called for this stream
    or if not at a block boundary for raw deflate).  deflateSetDictionary does
    not perform any compression: this will be done by deflate().
 */
 
-ZEXTERN int ZEXPORT deflateCopy (z_stream *dest,
-                                    z_stream *source);
+ZEXTERN int ZEXPORT deflateCopy(z_stream *dest,
+                                z_stream *source);
 /*
      Sets the destination stream as a complete copy of the source stream.
 
@@ -640,11 +638,11 @@ ZEXTERN int ZEXPORT deflateCopy (z_stream *dest,
 
      deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
    enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
+   (such as zalloc being NULL).  msg is left unchanged in both source and
    destination.
 */
 
-ZEXTERN int ZEXPORT deflateReset (z_stream *strm);
+ZEXTERN int ZEXPORT deflateReset(z_stream *strm);
 /*
      This function is equivalent to deflateEnd followed by deflateInit,
    but does not free and reallocate all the internal compression state.  The
@@ -652,12 +650,12 @@ ZEXTERN int ZEXPORT deflateReset (z_stream *strm);
    may have been set by deflateInit2.
 
      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL).
+   stream state was inconsistent (such as zalloc or state being NULL).
 */
 
-ZEXTERN int ZEXPORT deflateParams (z_stream *strm,
-                                      int level,
-                                      int strategy);
+ZEXTERN int ZEXPORT deflateParams(z_stream *strm,
+                                  int level,
+                                  int strategy);
 /*
      Dynamically update the compression level and compression strategy.  The
    interpretation of level and strategy is as in deflateInit2.  This can be
@@ -676,11 +674,11 @@ ZEXTERN int ZEXPORT deflateParams (z_stream *strm,
    strm->avail_out was zero.
 */
 
-ZEXTERN int ZEXPORT deflateTune (z_stream *strm,
-                                    int good_length,
-                                    int max_lazy,
-                                    int nice_length,
-                                    int max_chain);
+ZEXTERN int ZEXPORT deflateTune(z_stream *strm,
+                                int good_length,
+                                int max_lazy,
+                                int nice_length,
+                                int max_chain);
 /*
      Fine tune deflate's internal compression parameters.  This should only be
    used by someone who understands the algorithm used by zlib's deflate for
@@ -693,8 +691,8 @@ ZEXTERN int ZEXPORT deflateTune (z_stream *strm,
    returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
  */
 
-ZEXTERN uLong ZEXPORT deflateBound (z_stream *strm,
-                                       uLong sourceLen);
+ZEXTERN unsigned long ZEXPORT deflateBound(z_stream *strm,
+                                           unsigned long sourceLen);
 /*
      deflateBound() returns an upper bound on the compressed size after
    deflation of sourceLen bytes.  It must be called after deflateInit() or
@@ -708,24 +706,24 @@ ZEXTERN uLong ZEXPORT deflateBound (z_stream *strm,
    than Z_FINISH or Z_NO_FLUSH are used.
 */
 
-ZEXTERN int ZEXPORT deflatePending (z_stream *strm,
-                                       unsigned *pending,
-                                       int *bits);
+ZEXTERN int ZEXPORT deflatePending(z_stream *strm,
+                                   unsigned int *pending,
+                                   int *bits);
 /*
      deflatePending() returns the number of bytes and bits of output that have
    been generated, but not yet provided in the available output.  The bytes not
    provided would be due to the available output space having being consumed.
    The number of bits of output not provided are between 0 and 7, where they
    await more bits to join them in order to fill out a full byte.  If pending
-   or bits are Z_NULL, then those values are not set.
+   or bits are NULL, then those values are not set.
 
      deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source
    stream state was inconsistent.
  */
 
-ZEXTERN int ZEXPORT deflatePrime (z_stream *strm,
-                                     int bits,
-                                     int value);
+ZEXTERN int ZEXPORT deflatePrime(z_stream *strm,
+                                 int bits,
+                                 int value);
 /*
      deflatePrime() inserts bits in the deflate output stream.  The intent
    is that this function is used to start off the deflate output with the bits
@@ -740,8 +738,8 @@ ZEXTERN int ZEXPORT deflatePrime (z_stream *strm,
    source stream state was inconsistent.
 */
 
-ZEXTERN int ZEXPORT deflateSetHeader (z_stream *strm,
-                                         gz_headerp head);
+ZEXTERN int ZEXPORT deflateSetHeader(z_stream *strm,
+                                     gz_header *head);
 /*
      deflateSetHeader() provides gzip header information for when a gzip
    stream is requested by deflateInit2().  deflateSetHeader() may be called
@@ -749,8 +747,8 @@ ZEXTERN int ZEXPORT deflateSetHeader (z_stream *strm,
    deflate().  The text, time, os, extra field, name, and comment information
    in the provided gz_header structure are written to the gzip header (xflag is
    ignored -- the extra flags are set according to the compression level).  The
-   caller must assure that, if not Z_NULL, name and comment are terminated with
-   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
+   caller must assure that, if not NULL, name and comment are terminated with
+   a zero byte, and that if extra is not NULL, that extra_len bytes are
    available there.  If hcrc is true, a gzip header crc is included.  Note that
    the current versions of the command-line version of gzip (up through version
    1.3.x) do not support header crc's, and will report that it is a "multi-part
@@ -765,8 +763,8 @@ ZEXTERN int ZEXPORT deflateSetHeader (z_stream *strm,
 */
 
 /*
-ZEXTERN int ZEXPORT inflateInit2 (z_stream *strm,
-                                     int  windowBits);
+ZEXTERN int ZEXPORT inflateInit2(z_stream *strm,
+                                 int  windowBits);
 
      This is another version of inflateInit with an extra parameter.  The
    fields next_in, avail_in, zalloc, zfree and opaque must be initialized
@@ -814,9 +812,9 @@ ZEXTERN int ZEXPORT inflateInit2 (z_stream *strm,
    deferred until inflate() is called.
 */
 
-ZEXTERN int ZEXPORT inflateSetDictionary (z_stream *strm,
-                                             const Byte *dictionary,
-                                             uInt  dictLength);
+ZEXTERN int ZEXPORT inflateSetDictionary(z_stream *strm,
+                                         const unsigned char *dictionary,
+                                         unsigned int dictLength);
 /*
      Initializes the decompression dictionary from the given uncompressed byte
    sequence.  This function must be called immediately after a call of inflate,
@@ -830,29 +828,29 @@ ZEXTERN int ZEXPORT inflateSetDictionary (z_stream *strm,
    that was used for compression is provided.
 
      inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
-   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
+   parameter is invalid (e.g.  dictionary being NULL) or the stream state is
    inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
    expected one (incorrect adler32 value).  inflateSetDictionary does not
    perform any decompression: this will be done by subsequent calls of
    inflate().
 */
 
-ZEXTERN int ZEXPORT inflateGetDictionary (z_stream *strm,
-                                             Byte *dictionary,
-                                             uInt  *dictLength);
+ZEXTERN int ZEXPORT inflateGetDictionary(z_stream *strm,
+                                         unsigned char *dictionary,
+                                         unsigned int *dictLength);
 /*
      Returns the sliding dictionary being maintained by inflate.  dictLength is
    set to the number of bytes in the dictionary, and that many bytes are copied
    to dictionary.  dictionary must have enough space, where 32768 bytes is
    always enough.  If inflateGetDictionary() is called with dictionary equal to
-   Z_NULL, then only the dictionary length is returned, and nothing is copied.
-   Similary, if dictLength is Z_NULL, then it is not set.
+   NULL, then only the dictionary length is returned, and nothing is copied.
+   Similary, if dictLength is NULL, then it is not set.
 
      inflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the
    stream state is inconsistent.
 */
 
-ZEXTERN int ZEXPORT inflateSync (z_stream *strm);
+ZEXTERN int ZEXPORT inflateSync(z_stream *strm);
 /*
      Skips invalid compressed data until a possible full flush point (see above
    for the description of deflate with Z_FULL_FLUSH) can be found, or until all
@@ -871,8 +869,8 @@ ZEXTERN int ZEXPORT inflateSync (z_stream *strm);
    input each time, until success or end of the input data.
 */
 
-ZEXTERN int ZEXPORT inflateCopy (z_stream *dest,
-                                    z_stream *source);
+ZEXTERN int ZEXPORT inflateCopy(z_stream *dest,
+                                z_stream *source);
 /*
      Sets the destination stream as a complete copy of the source stream.
 
@@ -883,35 +881,35 @@ ZEXTERN int ZEXPORT inflateCopy (z_stream *dest,
 
      inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
    enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
+   (such as zalloc being NULL).  msg is left unchanged in both source and
    destination.
 */
 
-ZEXTERN int ZEXPORT inflateReset (z_stream *strm);
+ZEXTERN int ZEXPORT inflateReset(z_stream *strm);
 /*
      This function is equivalent to inflateEnd followed by inflateInit,
    but does not free and reallocate all the internal decompression state.  The
    stream will keep attributes that may have been set by inflateInit2.
 
      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL).
+   stream state was inconsistent (such as zalloc or state being NULL).
 */
 
-ZEXTERN int ZEXPORT inflateReset2 (z_stream *strm,
-                                      int windowBits);
+ZEXTERN int ZEXPORT inflateReset2(z_stream *strm,
+                                  int windowBits);
 /*
      This function is the same as inflateReset, but it also permits changing
    the wrap and window size requests.  The windowBits parameter is interpreted
    the same as it is for inflateInit2.
 
      inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL), or if
+   stream state was inconsistent (such as zalloc or state being NULL), or if
    the windowBits parameter is invalid.
 */
 
-ZEXTERN int ZEXPORT inflatePrime (z_stream *strm,
-                                     int bits,
-                                     int value);
+ZEXTERN int ZEXPORT inflatePrime(z_stream *strm,
+                                 int bits,
+                                 int value);
 /*
      This function inserts bits in the inflate input stream.  The intent is
    that this function is used to start inflating at a bit position in the
@@ -930,7 +928,7 @@ ZEXTERN int ZEXPORT inflatePrime (z_stream *strm,
    stream state was inconsistent.
 */
 
-ZEXTERN long ZEXPORT inflateMark (z_stream *strm);
+ZEXTERN long ZEXPORT inflateMark(z_stream *strm);
 /*
      This function returns two values, one in the lower 16 bits of the return
    value, and the other in the remaining upper bits, obtained by shifting the
@@ -958,8 +956,8 @@ ZEXTERN long ZEXPORT inflateMark (z_stream *strm);
    source stream state was inconsistent.
 */
 
-ZEXTERN int ZEXPORT inflateGetHeader (z_stream *strm,
-                                         gz_headerp head);
+ZEXTERN int ZEXPORT inflateGetHeader(z_stream *strm,
+                                     gz_headerp head);
 /*
      inflateGetHeader() requests that gzip header information be stored in the
    provided gz_header structure.  inflateGetHeader() may be called after
@@ -973,16 +971,16 @@ ZEXTERN int ZEXPORT inflateGetHeader (z_stream *strm,
 
      The text, time, xflags, and os fields are filled in with the gzip header
    contents.  hcrc is set to true if there is a header CRC.  (The header CRC
-   was valid if done is set to one.) If extra is not Z_NULL, then extra_max
+   was valid if done is set to one.) If extra is not NULL, then extra_max
    contains the maximum number of bytes to write to extra.  Once done is true,
    extra_len contains the actual extra field length, and extra contains the
    extra field, or that field truncated if extra_max is less than extra_len.
-   If name is not Z_NULL, then up to name_max characters are written there,
+   If name is not NULL, then up to name_max characters are written there,
    terminated with a zero unless the length is greater than name_max.  If
-   comment is not Z_NULL, then up to comm_max characters are written there,
+   comment is not NULL, then up to comm_max characters are written there,
    terminated with a zero unless the length is greater than comm_max.  When any
-   of extra, name, or comment are not Z_NULL and the respective field is not
-   present in the header, then that field is set to Z_NULL to signal its
+   of extra, name, or comment are not NULL and the respective field is not
+   present in the header, then that field is set to NULL to signal its
    absence.  This allows the use of deflateSetHeader() with the returned
    structure to duplicate the header.  However if those fields are set to
    allocated memory, then the application will need to save those pointers
@@ -999,12 +997,12 @@ ZEXTERN int ZEXPORT inflateGetHeader (z_stream *strm,
 */
 
 /*
-ZEXTERN int ZEXPORT inflateBackInit (z_stream *strm, int windowBits,
-                                        unsigned char *window);
+ZEXTERN int ZEXPORT inflateBackInit(z_stream *strm, int windowBits,
+                                    unsigned char *window);
 
      Initialize the internal stream state for decompression using inflateBack()
    calls.  The fields zalloc, zfree and opaque in strm must be initialized
-   before the call.  If zalloc and zfree are Z_NULL, then the default library-
+   before the call.  If zalloc and zfree are NULL, then the default library-
    derived memory allocation routines are used.  windowBits is the base two
    logarithm of the window size, in the range 8..15.  window is a caller
    supplied buffer of that size.  Except for special applications where it is
@@ -1020,13 +1018,12 @@ ZEXTERN int ZEXPORT inflateBackInit (z_stream *strm, int windowBits,
    the version of the header file.
 */
 
-typedef unsigned (*in_func) (void *,
-                                z_const unsigned char * *);
-typedef int (*out_func) (void *, unsigned char *, unsigned);
+typedef unsigned int (*in_func)(void *, z_const unsigned char **);
+typedef int (*out_func)(void *, unsigned char *, unsigned int);
 
-ZEXTERN int ZEXPORT inflateBack (z_stream *strm,
-                                    in_func in, void *in_desc,
-                                    out_func out, void *out_desc);
+ZEXTERN int ZEXPORT inflateBack(z_stream *strm,
+                                in_func in, void *in_desc,
+                                out_func out, void *out_desc);
 /*
      inflateBack() does a raw inflate with a single call using a call-back
    interface for input and output.  This is potentially more efficient than
@@ -1070,8 +1067,8 @@ ZEXTERN int ZEXPORT inflateBack (z_stream *strm,
      For convenience, inflateBack() can be provided input on the first call by
    setting strm->next_in and strm->avail_in.  If that input is exhausted, then
    in() will be called.  Therefore strm->next_in must be initialized before
-   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
-   immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
+   calling inflateBack().  If strm->next_in is NULL, then in() will be called
+   immediately for input.  If strm->next_in is not NULL, then strm->avail_in
    must also be initialized, and then if strm->avail_in is not zero, input will
    initially be taken from strm->next_in[0 ..  strm->avail_in - 1].
 
@@ -1087,14 +1084,14 @@ ZEXTERN int ZEXPORT inflateBack (z_stream *strm,
    in the deflate stream (in which case strm->msg is set to indicate the nature
    of the error), or Z_STREAM_ERROR if the stream was not properly initialized.
    In the case of Z_BUF_ERROR, an input or output error can be distinguished
-   using strm->next_in which will be Z_NULL only if in() returned an error.  If
-   strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning
+   using strm->next_in which will be NULL only if in() returned an error.  If
+   strm->next_in is not NULL, then the Z_BUF_ERROR was due to out() returning
    non-zero.  (in() will always be called before out(), so strm->next_in is
    assured to be defined if out() returns non-zero.) Note that inflateBack()
    cannot return Z_OK.
 */
 
-ZEXTERN int ZEXPORT inflateBackEnd (z_stream *strm);
+ZEXTERN int ZEXPORT inflateBackEnd(z_stream *strm);
 /*
      All memory allocated by inflateBackInit() is freed.
 
@@ -1102,14 +1099,14 @@ ZEXTERN int ZEXPORT inflateBackEnd (z_stream *strm);
    state was inconsistent.
 */
 
-ZEXTERN uLong ZEXPORT zlibCompileFlags (void);
+ZEXTERN unsigned long ZEXPORT zlibCompileFlags(void);
 /* Return flags indicating compile-time options.
 
     Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
-     1.0: size of uInt
-     3.2: size of uLong
-     5.4: size of void * (pointer)
-     7.6: size of z_off_t
+     1.0: size of unsigned int
+     3.2: size of unsigned long
+     5.4: size of void*
+     7.6: size of off_t
 
     Compiler, assembler, and debug options:
      8: DEBUG
@@ -1143,8 +1140,6 @@ ZEXTERN uLong ZEXPORT zlibCompileFlags (void);
      27-31: 0 (reserved)
  */
 
-#ifndef Z_SOLO
-
                         /* utility functions */
 
 /*
@@ -1155,8 +1150,8 @@ ZEXTERN uLong ZEXPORT zlibCompileFlags (void);
    you need special options.
 */
 
-ZEXTERN int ZEXPORT compress (Byte *dest,   uLong *destLen,
-                                 const Byte *source, uLong sourceLen);
+ZEXTERN int ZEXPORT compress(unsigned char *dest, unsigned long *destLen,
+                             const unsigned char *source, unsigned long sourceLen);
 /*
      Compresses the source buffer into the destination buffer.  sourceLen is
    the byte length of the source buffer.  Upon entry, destLen is the total size
@@ -1169,9 +1164,9 @@ ZEXTERN int ZEXPORT compress (Byte *dest,   uLong *destLen,
    buffer.
 */
 
-ZEXTERN int ZEXPORT compress2 (Byte *dest,   uLong *destLen,
-                                  const Byte *source, uLong sourceLen,
-                                  int level);
+ZEXTERN int ZEXPORT compress2(unsigned char *dest, unsigned long *destLen,
+                              const unsigned char *source, unsigned long sourceLen,
+                              int level);
 /*
      Compresses the source buffer into the destination buffer.  The level
    parameter has the same meaning as in deflateInit.  sourceLen is the byte
@@ -1185,15 +1180,15 @@ ZEXTERN int ZEXPORT compress2 (Byte *dest,   uLong *destLen,
    Z_STREAM_ERROR if the level parameter is invalid.
 */
 
-ZEXTERN uLong ZEXPORT compressBound (uLong sourceLen);
+ZEXTERN unsigned long ZEXPORT compressBound(unsigned long sourceLen);
 /*
      compressBound() returns an upper bound on the compressed size after
    compress() or compress2() on sourceLen bytes.  It would be used before a
    compress() or compress2() call to allocate the destination buffer.
 */
 
-ZEXTERN int ZEXPORT uncompress (Byte *dest,   uLong *destLen,
-                                   const Byte *source, uLong sourceLen);
+ZEXTERN int ZEXPORT uncompress(unsigned char *dest, unsigned long *destLen,
+                               const unsigned char *source, unsigned long sourceLen);
 /*
      Decompresses the source buffer into the destination buffer.  sourceLen is
    the byte length of the source buffer.  Upon entry, destLen is the total size
@@ -1222,7 +1217,7 @@ ZEXTERN int ZEXPORT uncompress (Byte *dest,   uLong *destLen,
 typedef struct gzFile_s *gzFile;    /* semi-opaque gzip file descriptor */
 
 /*
-ZEXTERN gzFile ZEXPORT gzopen (const char *path, const char *mode);
+ZEXTERN gzFile ZEXPORT gzopen(const char *path, const char *mode);
 
      Opens a gzip (.gz) file for reading or writing.  The mode parameter is as
    in fopen ("rb" or "wb") but can also include a compression level ("wb9") or
@@ -1259,7 +1254,7 @@ ZEXTERN gzFile ZEXPORT gzopen (const char *path, const char *mode);
    file could not be opened.
 */
 
-ZEXTERN gzFile ZEXPORT gzdopen (int fd, const char *mode);
+ZEXTERN gzFile ZEXPORT gzdopen(int fd, const char *mode);
 /*
      gzdopen associates a gzFile with the file descriptor fd.  File descriptors
    are obtained from calls like open, dup, creat, pipe or fileno (if the file
@@ -1282,7 +1277,7 @@ ZEXTERN gzFile ZEXPORT gzdopen (int fd, const char *mode);
    will not detect if fd is invalid (unless fd is -1).
 */
 
-ZEXTERN int ZEXPORT gzbuffer (gzFile file, unsigned size);
+ZEXTERN int ZEXPORT gzbuffer(gzFile file, unsigned int size);
 /*
      Set the internal buffer size used by this library's functions.  The
    default buffer size is 8192 bytes.  This function must be called after
@@ -1299,7 +1294,7 @@ ZEXTERN int ZEXPORT gzbuffer (gzFile file, unsigned size);
    too late.
 */
 
-ZEXTERN int ZEXPORT gzsetparams (gzFile file, int level, int strategy);
+ZEXTERN int ZEXPORT gzsetparams(gzFile file, int level, int strategy);
 /*
      Dynamically update the compression level or strategy.  See the description
    of deflateInit2 for the meaning of these parameters.
@@ -1308,7 +1303,7 @@ ZEXTERN int ZEXPORT gzsetparams (gzFile file, int level, int strategy);
    opened for writing.
 */
 
-ZEXTERN int ZEXPORT gzread (gzFile file, void *buf, unsigned len);
+ZEXTERN int ZEXPORT gzread(gzFile file, void* buf, unsigned int len);
 /*
      Reads the given number of uncompressed bytes from the compressed file.  If
    the input file is not in gzip format, gzread copies the given number of
@@ -1336,14 +1331,16 @@ ZEXTERN int ZEXPORT gzread (gzFile file, void *buf, unsigned len);
    len for end of file, or -1 for error.
 */
 
-ZEXTERN int ZEXPORT gzwrite (gzFile file, void const *buf, unsigned len);
+ZEXTERN int ZEXPORT gzwrite(gzFile file,
+                            const void *buf,
+                            unsigned int len);
 /*
      Writes the given number of uncompressed bytes into the compressed file.
    gzwrite returns the number of uncompressed bytes written or 0 in case of
    error.
 */
 
-ZEXTERN int ZEXPORTVA gzprintf Z_ARG((gzFile file, const char *format, ...));
+ZEXTERN int ZEXPORTVA gzprintf(gzFile file, const char *format, ...);
 /*
      Converts, formats, and writes the arguments to the compressed file under
    control of the format string, as in fprintf.  gzprintf returns the number of
@@ -1358,7 +1355,7 @@ ZEXTERN int ZEXPORTVA gzprintf Z_ARG((gzFile file, const char *format, ...));
    zlibCompileFlags().
 */
 
-ZEXTERN int ZEXPORT gzputs (gzFile file, const char *s);
+ZEXTERN int ZEXPORT gzputs(gzFile file, const char *s);
 /*
      Writes the given null-terminated string to the compressed file, excluding
    the terminating null character.
@@ -1366,7 +1363,7 @@ ZEXTERN int ZEXPORT gzputs (gzFile file, const char *s);
      gzputs returns the number of characters written, or -1 in case of error.
 */
 
-ZEXTERN char * ZEXPORT gzgets (gzFile file, char *buf, int len);
+ZEXTERN char * ZEXPORT gzgets(gzFile file, char *buf, int len);
 /*
      Reads bytes from the compressed file until len-1 characters are read, or a
    newline character is read and transferred to buf, or an end-of-file
@@ -1379,13 +1376,13 @@ ZEXTERN char * ZEXPORT gzgets (gzFile file, char *buf, int len);
    buf are indeterminate.
 */
 
-ZEXTERN int ZEXPORT gzputc (gzFile file, int c);
+ZEXTERN int ZEXPORT gzputc(gzFile file, int c);
 /*
      Writes c, converted to an unsigned char, into the compressed file.  gzputc
    returns the value that was written, or -1 in case of error.
 */
 
-ZEXTERN int ZEXPORT gzgetc (gzFile file);
+ZEXTERN int ZEXPORT gzgetc(gzFile file);
 /*
      Reads one byte from the compressed file.  gzgetc returns this byte or -1
    in case of end of file or error.  This is implemented as a macro for speed.
@@ -1394,7 +1391,7 @@ ZEXTERN int ZEXPORT gzgetc (gzFile file);
    points to has been clobbered or not.
 */
 
-ZEXTERN int ZEXPORT gzungetc (int c, gzFile file);
+ZEXTERN int ZEXPORT gzungetc(int c, gzFile file);
 /*
      Push one character back onto the stream to be read as the first character
    on the next read.  At least one character of push-back is allowed.
@@ -1406,7 +1403,7 @@ ZEXTERN int ZEXPORT gzungetc (int c, gzFile file);
    gzseek() or gzrewind().
 */
 
-ZEXTERN int ZEXPORT gzflush (gzFile file, int flush);
+ZEXTERN int ZEXPORT gzflush(gzFile file, int flush);
 /*
      Flushes all pending output into the compressed file.  The parameter flush
    is as in the deflate() function.  The return value is the zlib error number
@@ -1415,15 +1412,15 @@ ZEXTERN int ZEXPORT gzflush (gzFile file, int flush);
      If the flush parameter is Z_FINISH, the remaining data is written and the
    gzip stream is completed in the output.  If gzwrite() is called again, a new
    gzip stream will be started in the output.  gzread() is able to read such
-   concatented gzip streams.
+   concatenated gzip streams.
 
      gzflush should be called only when strictly necessary because it will
    degrade compression if called too often.
 */
 
 /*
-ZEXTERN z_off_t ZEXPORT gzseek (gzFile file,
-                                   z_off_t offset, int whence);
+ZEXTERN off_t ZEXPORT gzseek(gzFile file,
+                             off_t offset, int whence);
 
      Sets the starting position for the next gzread or gzwrite on the given
    compressed file.  The offset represents a number of bytes in the
@@ -1441,7 +1438,7 @@ ZEXTERN z_off_t ZEXPORT gzseek (gzFile file,
    would be before the current position.
 */
 
-ZEXTERN int ZEXPORT    gzrewind (gzFile file);
+ZEXTERN int ZEXPORT gzrewind(gzFile file);
 /*
      Rewinds the given file. This function is supported only for reading.
 
@@ -1449,7 +1446,7 @@ ZEXTERN int ZEXPORT    gzrewind (gzFile file);
 */
 
 /*
-ZEXTERN z_off_t ZEXPORT    gztell (gzFile file);
+ZEXTERN off_t ZEXPORT gztell(gzFile file);
 
      Returns the starting position for the next gzread or gzwrite on the given
    compressed file.  This position represents a number of bytes in the
@@ -1460,7 +1457,7 @@ ZEXTERN z_off_t ZEXPORT    gztell (gzFile file);
 */
 
 /*
-ZEXTERN z_off_t ZEXPORT gzoffset (gzFile file);
+ZEXTERN off_t ZEXPORT gzoffset(gzFile file);
 
      Returns the current offset in the file being read or written.  This offset
    includes the count of bytes that precede the gzip stream, for example when
@@ -1469,7 +1466,7 @@ ZEXTERN z_off_t ZEXPORT gzoffset (gzFile file);
    for a progress indicator.  On error, gzoffset() returns -1.
 */
 
-ZEXTERN int ZEXPORT gzeof (gzFile file);
+ZEXTERN int ZEXPORT gzeof(gzFile file);
 /*
      Returns true (1) if the end-of-file indicator has been set while reading,
    false (0) otherwise.  Note that the end-of-file indicator is set only if the
@@ -1484,7 +1481,7 @@ ZEXTERN int ZEXPORT gzeof (gzFile file);
    has grown since the previous end of file was detected.
 */
 
-ZEXTERN int ZEXPORT gzdirect (gzFile file);
+ZEXTERN int ZEXPORT gzdirect(gzFile file);
 /*
      Returns true (1) if file is being copied directly while reading, or false
    (0) if file is a gzip stream being decompressed.
@@ -1505,7 +1502,7 @@ ZEXTERN int ZEXPORT gzdirect (gzFile file);
    gzip file reading and decompression, which may not be desired.)
 */
 
-ZEXTERN int ZEXPORT    gzclose (gzFile file);
+ZEXTERN int ZEXPORT gzclose(gzFile file);
 /*
      Flushes all pending output if necessary, closes the compressed file and
    deallocates the (de)compression state.  Note that once file is closed, you
@@ -1518,8 +1515,8 @@ ZEXTERN int ZEXPORT    gzclose (gzFile file);
    last read ended in the middle of a gzip stream, or Z_OK on success.
 */
 
-ZEXTERN int ZEXPORT gzclose_r (gzFile file);
-ZEXTERN int ZEXPORT gzclose_w (gzFile file);
+ZEXTERN int ZEXPORT gzclose_r(gzFile file);
+ZEXTERN int ZEXPORT gzclose_w(gzFile file);
 /*
      Same as gzclose(), but gzclose_r() is only for use when reading, and
    gzclose_w() is only for use when writing or appending.  The advantage to
@@ -1530,7 +1527,7 @@ ZEXTERN int ZEXPORT gzclose_w (gzFile file);
    zlib library.
 */
 
-ZEXTERN const char * ZEXPORT gzerror (gzFile file, int *errnum);
+ZEXTERN const char * ZEXPORT gzerror(gzFile file, int *errnum);
 /*
      Returns the error message for the last error which occurred on the given
    compressed file.  errnum is set to zlib error number.  If an error occurred
@@ -1546,15 +1543,13 @@ ZEXTERN const char * ZEXPORT gzerror (gzFile file, int *errnum);
    functions above that do not distinguish those cases in their return values.
 */
 
-ZEXTERN void ZEXPORT gzclearerr (gzFile file);
+ZEXTERN void ZEXPORT gzclearerr(gzFile file);
 /*
      Clears the error and end-of-file flags for file.  This is analogous to the
    clearerr() function in stdio.  This is useful for continuing to read a gzip
    file that is being written concurrently.
 */
 
-#endif /* !Z_SOLO */
-
                         /* checksum functions */
 
 /*
@@ -1563,10 +1558,12 @@ ZEXTERN void ZEXPORT gzclearerr (gzFile file);
    library.
 */
 
-ZEXTERN uLong ZEXPORT adler32 (uLong adler, const Byte *buf, uInt len);
+ZEXTERN unsigned long ZEXPORT adler32(unsigned long adler,
+                                      const unsigned char *buf,
+                                      unsigned int len);
 /*
      Update a running Adler-32 checksum with the bytes buf[0..len-1] and
-   return the updated checksum.  If buf is Z_NULL, this function returns the
+   return the updated checksum.  If buf is NULL, this function returns the
    required initial value for the checksum.
 
      An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
@@ -1574,7 +1571,7 @@ ZEXTERN uLong ZEXPORT adler32 (uLong adler, const Byte *buf, uInt len);
 
    Usage example:
 
-     uLong adler = adler32(0L, Z_NULL, 0);
+     unsigned long adler = adler32(0L, NULL, 0);
 
      while (read_buffer(buffer, length) != EOF) {
        adler = adler32(adler, buffer, length);
@@ -1583,27 +1580,30 @@ ZEXTERN uLong ZEXPORT adler32 (uLong adler, const Byte *buf, uInt len);
 */
 
 /*
-ZEXTERN uLong ZEXPORT adler32_combine (uLong adler1, uLong adler2,
-                                          z_off_t len2);
+ZEXTERN unsigned long ZEXPORT adler32_combine(unsigned long adler1,
+                                              unsigned long adler2,
+                                              off_t len2);
 
      Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
    and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
    each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
    seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note
-   that the z_off_t type (like off_t) is a signed integer.  If len2 is
-   negative, the result has no meaning or utility.
+   that the off_t type is a signed integer.  If len2 is negative, the result has
+   no meaning or utility.
 */
 
-ZEXTERN uLong ZEXPORT crc32   (uLong crc, const Byte *buf, uInt len);
+ZEXTERN unsigned long ZEXPORT crc32(unsigned long crc,
+                                    const unsigned char* buf,
+                                    unsigned int len);
 /*
      Update a running CRC-32 with the bytes buf[0..len-1] and return the
-   updated CRC-32.  If buf is Z_NULL, this function returns the required
+   updated CRC-32.  If buf is NULL, this function returns the required
    initial value for the crc.  Pre- and post-conditioning (one's complement) is
    performed within this function so it shouldn't be done by the application.
 
    Usage example:
 
-     uLong crc = crc32(0L, Z_NULL, 0);
+     unsigned long crc = crc32(0L, NULL, 0);
 
      while (read_buffer(buffer, length) != EOF) {
        crc = crc32(crc, buffer, length);
@@ -1612,7 +1612,9 @@ ZEXTERN uLong ZEXPORT crc32   (uLong crc, const Byte *buf, uInt len);
 */
 
 /*
-ZEXTERN uLong ZEXPORT crc32_combine (uLong crc1, uLong crc2, z_off_t len2);
+ZEXTERN unsigned long ZEXPORT crc32_combine(unsigned long crc1,
+                                            unsigned long crc2,
+                                            off_t len2);
 
      Combine two CRC-32 check values into one.  For two sequences of bytes,
    seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
@@ -1627,13 +1629,20 @@ ZEXTERN uLong ZEXPORT crc32_combine (uLong crc1, uLong crc2, z_off_t len2);
 /* deflateInit and inflateInit are macros to allow checking the zlib version
  * and the compiler's view of z_stream:
  */
-ZEXTERN int ZEXPORT deflateInit_ (z_stream *strm, int level, const char *version, int stream_size);
-ZEXTERN int ZEXPORT inflateInit_ (z_stream *strm, const char *version, int stream_size);
-ZEXTERN int ZEXPORT deflateInit2_ (z_stream *strm, int  level, int  method, int windowBits, int memLevel,
-                                   int strategy, const char *version, int stream_size);
-ZEXTERN int ZEXPORT inflateInit2_ (z_stream *strm, int  windowBits, const char *version, int stream_size);
-ZEXTERN int ZEXPORT inflateBackInit_ (z_stream *strm, int windowBits, unsigned char *window,
-                                      const char *version, int stream_size);
+ZEXTERN int ZEXPORT deflateInit_(z_stream *strm, int level,
+                                 const char *version, int stream_size);
+ZEXTERN int ZEXPORT inflateInit_(z_stream *strm,
+                                 const char *version, int stream_size);
+ZEXTERN int ZEXPORT deflateInit2_(z_stream *strm, int level, int method,
+                                  int windowBits, int memLevel,
+                                  int strategy, const char *version,
+                                  int stream_size);
+ZEXTERN int ZEXPORT inflateInit2_(z_stream *strm, int  windowBits,
+                                  const char *version, int stream_size);
+ZEXTERN int ZEXPORT inflateBackInit_(z_stream *strm, int windowBits,
+                                     unsigned char *window,
+                                     const char *version,
+                                     int stream_size);
 #define deflateInit(strm, level) \
         deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))
 #define inflateInit(strm) \
@@ -1648,98 +1657,36 @@ ZEXTERN int ZEXPORT inflateBackInit_ (z_stream *strm, int windowBits, unsigned c
         inflateBackInit_((strm), (windowBits), (window), \
                       ZLIB_VERSION, (int)sizeof(z_stream))
 
-#ifndef Z_SOLO
-
-/* gzgetc() macro and its supporting function and exposed data structure.  Note
- * that the real internal state is much larger than the exposed structure.
- * This abbreviated structure exposes just enough for the gzgetc() macro.  The
- * user should not mess with these exposed elements, since their names or
- * behavior could change in the future, perhaps even capriciously.  They can
- * only be used by the gzgetc() macro.  You have been warned.
- */
-struct gzFile_s {
-    unsigned have;
-    unsigned char *next;
-    z_off64_t pos;
-};
-ZEXTERN int ZEXPORT gzgetc_ (gzFile file);  /* backward compatibility */
-#ifdef Z_PREFIX_SET
-#  undef z_gzgetc
-#  define z_gzgetc(g) \
-          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : gzgetc(g))
-#else
-#  define gzgetc(g) \
-          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : gzgetc(g))
-#endif
-
-/* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or
- * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if
- * both are true, the application gets the *64 functions, and the regular
- * functions are changed to 64 bits) -- in case these are set on systems
- * without large file support, _LFS64_LARGEFILE must also be true
- */
-#ifdef Z_LARGE64
-   ZEXTERN gzFile ZEXPORT gzopen64 (const char *, const char *);
-   ZEXTERN z_off64_t ZEXPORT gzseek64 (gzFile, z_off64_t, int);
-   ZEXTERN z_off64_t ZEXPORT gztell64 (gzFile);
-   ZEXTERN z_off64_t ZEXPORT gzoffset64 (gzFile);
-   ZEXTERN uLong ZEXPORT adler32_combine64 (uLong, uLong, z_off64_t);
-   ZEXTERN uLong ZEXPORT crc32_combine64 (uLong, uLong, z_off64_t);
-#endif
-
-#if !defined(ZLIB_INTERNAL) && defined(Z_WANT64)
-#  ifdef Z_PREFIX_SET
-#    define z_gzopen z_gzopen64
-#    define z_gzseek z_gzseek64
-#    define z_gztell z_gztell64
-#    define z_gzoffset z_gzoffset64
-#    define z_adler32_combine z_adler32_combine64
-#    define z_crc32_combine z_crc32_combine64
-#  else
-#    define gzopen gzopen64
-#    define gzseek gzseek64
-#    define gztell gztell64
-#    define gzoffset gzoffset64
-#    define adler32_combine adler32_combine64
-#    define crc32_combine crc32_combine64
-#  endif
-#  ifndef Z_LARGE64
-     ZEXTERN gzFile ZEXPORT gzopen64 (const char *, const char *);
-     ZEXTERN z_off_t ZEXPORT gzseek64 (gzFile, z_off_t, int);
-     ZEXTERN z_off_t ZEXPORT gztell64 (gzFile);
-     ZEXTERN z_off_t ZEXPORT gzoffset64 (gzFile);
-     ZEXTERN uLong ZEXPORT adler32_combine64 (uLong, uLong, z_off_t);
-     ZEXTERN uLong ZEXPORT crc32_combine64 (uLong, uLong, z_off_t);
-#  endif
-#else
-   ZEXTERN gzFile ZEXPORT gzopen (const char *, const char *);
-   ZEXTERN z_off_t ZEXPORT gzseek (gzFile, z_off_t, int);
-   ZEXTERN z_off_t ZEXPORT gztell (gzFile);
-   ZEXTERN z_off_t ZEXPORT gzoffset (gzFile);
-   ZEXTERN uLong ZEXPORT adler32_combine (uLong, uLong, z_off_t);
-   ZEXTERN uLong ZEXPORT crc32_combine (uLong, uLong, z_off_t);
-#endif
-
-#else /* Z_SOLO */
-
-   ZEXTERN uLong ZEXPORT adler32_combine (uLong, uLong, z_off_t);
-   ZEXTERN uLong ZEXPORT crc32_combine (uLong, uLong, z_off_t);
-
-#endif /* !Z_SOLO */
+// #define gzopen gzopen64
+// #define gzseek gzseek64
+// #define gztell gztell64
+// #define gzoffset gzoffset64
+// #define adler32_combine adler32_combine64
+// #define crc32_combine crc32_combine64
+ZEXTERN gzFile ZEXPORT gzopen(const char *, const char *);
+ZEXTERN off_t ZEXPORT gzseek(gzFile, off_t, int);
+ZEXTERN off_t ZEXPORT gztell(gzFile);
+ZEXTERN off_t ZEXPORT gzoffset(gzFile);
+ZEXTERN unsigned long ZEXPORT adler32_combine(unsigned long, unsigned long, off_t);
+ZEXTERN unsigned long ZEXPORT crc32_combine(unsigned long, unsigned long, off_t);
+
+ZEXTERN gzFile ZEXPORT gzopen64(const char *, const char *);
+ZEXTERN off_t ZEXPORT gzseek64(gzFile, off_t, int);
+ZEXTERN off_t ZEXPORT gztell64(gzFile);
+ZEXTERN off_t ZEXPORT gzoffset64(gzFile);
+ZEXTERN unsigned long ZEXPORT adler32_combine64(unsigned long, unsigned long, off_t);
+ZEXTERN unsigned long ZEXPORT crc32_combine64(unsigned long, unsigned long, off_t);
 
 /* undocumented functions */
-ZEXTERN const char   * ZEXPORT zError           (int);
-ZEXTERN int            ZEXPORT inflateSyncPoint (z_stream *);
-ZEXTERN const z_crc_t * ZEXPORT get_crc_table   (void);
-ZEXTERN int            ZEXPORT inflateUndermine (z_stream *, int);
-ZEXTERN int            ZEXPORT inflateResetKeep (z_stream *);
-ZEXTERN int            ZEXPORT deflateResetKeep (z_stream *);
-#if defined(_WIN32) && !defined(Z_SOLO)
-ZEXTERN gzFile         ZEXPORT gzopen_w (const wchar_t *path, const char *mode);
-#endif
-#ifndef Z_SOLO
-ZEXTERN int            ZEXPORTVA gzvprintf Z_ARG((gzFile file, const char *format, va_list va));
-#endif
+ZEXTERN const char    * ZEXPORT zError(int);
+ZEXTERN int             ZEXPORT inflateSyncPoint(z_stream *);
+ZEXTERN const z_crc_t * ZEXPORT get_crc_table(void);
+ZEXTERN int             ZEXPORT inflateUndermine(z_stream *, int);
+ZEXTERN int             ZEXPORT inflateResetKeep(z_stream *);
+ZEXTERN int             ZEXPORT deflateResetKeep(z_stream *);
+ZEXTERN int             ZEXPORTVA gzvprintf(gzFile file,
+                                            const char *format,
+                                            va_list va);
 
 #ifdef __cplusplus
 }
diff --git a/zutil.c b/zutil.c
index ada99dd..fffc2c9 100644
--- a/zutil.c
+++ b/zutil.c
@@ -5,12 +5,17 @@
 
 /* @(#) $Id$ */
 
+#include <errno.h>
+#include <limits.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
 #include "zutil.h"
-#ifndef Z_SOLO
-#  include "gzguts.h"
-#endif
+#include "gzguts.h"
 
-z_const char * const z_errmsg[10] = {
+ZLIB_INTERNAL
+const char * const z_errmsg[10] = {
 "need dictionary",     /* Z_NEED_DICT       2  */
 "stream end",          /* Z_STREAM_END      1  */
 "",                    /* Z_OK              0  */
@@ -25,23 +30,23 @@ z_const char * const z_errmsg[10] = {
 const char zlibng_string[] =
    " zlib-ng 1.9.9 forked from zlib 1.2.8 ";
 
-const char * ZEXPORT zlibVersion()
+const char * ZEXPORT zlibVersion(void)
 {
     return ZLIB_VERSION;
 }
 
-uLong ZEXPORT zlibCompileFlags()
+unsigned long ZEXPORT zlibCompileFlags()
 {
-    uLong flags;
+    unsigned long flags;
 
     flags = 0;
-    switch ((int)(sizeof(uInt))) {
+    switch ((int)(sizeof(unsigned int))) {
     case 2:     break;
-    case 4:     flags += 1;     break;
-    case 8:     flags += 2;     break;
-    default:    flags += 3;
+    case 4:     flags += 1 << 0;        break;
+    case 8:     flags += 2 << 0;        break;
+    default:    flags += 3 << 0;
     }
-    switch ((int)(sizeof(uLong))) {
+    switch ((int)(sizeof(unsigned long))) {
     case 2:     break;
     case 4:     flags += 1 << 2;        break;
     case 8:     flags += 2 << 2;        break;
@@ -53,7 +58,7 @@ uLong ZEXPORT zlibCompileFlags()
     case 8:     flags += 2 << 4;        break;
     default:    flags += 3 << 4;
     }
-    switch ((int)(sizeof(z_off_t))) {
+    switch ((int)(sizeof(off_t))) {
     case 2:     break;
     case 4:     flags += 1 << 6;        break;
     case 8:     flags += 2 << 6;        break;
@@ -62,24 +67,10 @@ uLong ZEXPORT zlibCompileFlags()
 #ifdef DEBUG
     flags += 1 << 8;
 #endif
-#ifdef ZLIB_WINAPI
-    flags += 1 << 10;
-#endif
-#ifdef BUILDFIXED
-    flags += 1 << 12;
-#endif
-#ifdef DYNAMIC_CRC_TABLE
-    flags += 1 << 13;
-#endif
-#ifdef NO_GZCOMPRESS
-    flags += 1L << 16;
-#endif
-#ifdef NO_GZIP
-    flags += 1L << 17;
-#endif
-#ifdef PKZIP_BUG_WORKAROUND
-    flags += 1L << 20;
-#endif
+    /* The operating system must have modern and secure printf functions. */
+    flags += 0L << 24;
+    flags += 0L << 25;
+    flags += 0L << 26;
     return flags;
 }
 
@@ -90,8 +81,8 @@ uLong ZEXPORT zlibCompileFlags()
 #  endif
 int ZLIB_INTERNAL z_verbose = verbose;
 
-void ZLIB_INTERNAL z_error (m)
-    char *m;
+/* TODO. This should be a const char *. */
+void ZLIB_INTERNAL z_error(char *m)
 {
     fprintf(stderr, "%s\n", m);
     exit(1);
@@ -101,29 +92,59 @@ void ZLIB_INTERNAL z_error (m)
 /* exported to allow conversion of error code to string for compress() and
  * uncompress()
  */
-const char * ZEXPORT zError(err)
-    int err;
+const char * ZEXPORT zError(int err)
 {
     return ERR_MSG(err);
 }
 
-#ifndef Z_SOLO
-
-#ifndef MY_ZCALLOC /* Any system without a special alloc function */
-
-void ZLIB_INTERNAL *zcalloc (void *opaque, unsigned items, unsigned size)
+/* This function is only for outward appearances in case an application looks
+   too closely at strm->zalloc. The internal allocator (z_stream_alloc) notices
+   if this one is used and uses the system allocator instead. */
+void* ZLIB_INTERNAL zcalloc(void *opaque, unsigned int items, unsigned int size)
 {
     if (opaque) items += size - size; /* make compiler happy */
-    return sizeof(uInt) > 2 ? (void *)malloc(items * size) :
+    return sizeof(unsigned int) > 2 ? (void *)malloc(items * size) :
                               (void *)calloc(items, size);
 }
 
-void ZLIB_INTERNAL zcfree (void *opaque, void *ptr)
+/* This function is only for outward appearances in case an application looks
+   too closely at strm->zfree. The internal deallocator (z_stream_free) notices
+   if this one is used and uses the system deallocator instead. */
+void ZLIB_INTERNAL zcfree(void *opaque, void *ptr)
 {
     free(ptr);
     if (opaque) return; /* make compiler happy */
 }
 
-#endif /* MY_ZCALLOC */
+void* ZLIB_INTERNAL z_stream_alloc(z_stream *strm, size_t size)
+{
+    if (strm->zalloc == (alloc_func)0 || strm->zalloc == zcalloc)
+        return malloc(size);
+#if UINT_MAX < SIZE_MAX
+    /* Don't trust the application's allocation function that has unsigned int
+       parameters to handle multiplication-check-and-promotion-to-size_t
+       properly. */
+    if (UINT_MAX < size)
+        return NULL;
+#endif
+    return strm->zalloc(strm->opaque, (unsigned int) size, 1);
+}
 
-#endif /* !Z_SOLO */
+void* ZLIB_INTERNAL z_stream_allocarray(z_stream *strm, size_t nmemb, size_t size)
+{
+    if (size && nmemb && SIZE_MAX / size < nmemb)
+        return errno = ENOMEM, (void*) NULL;
+    return z_stream_alloc(strm, nmemb * size);
+}
+
+void ZLIB_INTERNAL z_stream_free(z_stream *strm, void* ptr)
+{
+    if (strm->zfree == (free_func)0 || strm->zfree == zcfree) {
+        free(ptr);
+        return;
+    }
+    /* Don't trust the application to do null-checks in the deallocator. */
+    if (!ptr)
+        return;
+    strm->zfree(strm->opaque, ptr);
+}
diff --git a/zutil.h b/zutil.h
index ca0d5bc..847a82a 100644
--- a/zutil.h
+++ b/zutil.h
@@ -21,34 +21,14 @@
 
 #include "zlib.h"
 
-#ifndef Z_SOLO
-#  include <stddef.h>
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-
-#ifdef Z_SOLO
-   typedef long ptrdiff_t;  /* guess -- will be caught if guess is wrong */
-#endif
+#include <stddef.h>
+#include <string.h>
+#include <stdlib.h>
 
-#ifndef local
-#  define local static
-#endif
-/* compile with -Dlocal if your debugger can't find static symbols */
-
-typedef unsigned char  uch;
-typedef unsigned short ush;
-typedef unsigned long  ulg;
-
-extern z_const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
-/* (size given to avoid silly warnings with Visual C++) */
+extern const char * const z_errmsg[]; /* indexed by 2-zlib_error */
 
 #define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]
 
-#define ERR_RETURN(strm,err) \
-  return (strm->msg = ERR_MSG(err), (err))
-/* To be used only when the state is known to be valid */
-
         /* common constants */
 
 #ifndef DEF_WBITS
@@ -76,26 +56,8 @@ extern z_const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
 
         /* target dependencies */
 
-#ifdef WIN32
-#  ifndef __CYGWIN__  /* Cygwin is Unix, not Win32 */
-#    define OS_CODE  0x0b
-#  endif
-#endif
-
-#if (defined(_MSC_VER) && (_MSC_VER > 600))
-#  define fdopen(fd,type)  _fdopen(fd,type)
-#endif
-
-/* provide prototypes for these when building zlib without LFS */
-#if !defined(_WIN32) && (!defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0)
-    ZEXTERN uLong ZEXPORT adler32_combine64 (uLong, uLong, z_off_t);
-    ZEXTERN uLong ZEXPORT crc32_combine64 (uLong, uLong, z_off_t);
-#endif
-
-/* MS Visual Studio does not allow inline in C, only C++.
-   But it provides __inline instead, so use that. */
-#if defined(_MSC_VER) && !defined(inline)
-#  define inline __inline
+#ifdef __MINGW32__
+#  define OS_CODE  0x0b
 #endif
 
         /* common defaults */
@@ -114,7 +76,7 @@ extern z_const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
 #ifdef DEBUG
 #  include <stdio.h>
    extern int ZLIB_INTERNAL z_verbose;
-   extern void ZLIB_INTERNAL z_error (char *m);
+   extern void ZLIB_INTERNAL z_error(char *m);
 #  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
 #  define Trace(x) {if (z_verbose>=0) fprintf x ;}
 #  define Tracev(x) {if (z_verbose>0) fprintf x ;}
@@ -130,15 +92,12 @@ extern z_const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
 #  define Tracecv(c,x)
 #endif
 
-#ifndef Z_SOLO
-   void ZLIB_INTERNAL *zcalloc (void *opaque, unsigned items, unsigned size);
-   void ZLIB_INTERNAL  zcfree  (void *opaque, void *ptr);
-#endif
+void* ZLIB_INTERNAL zcalloc(void* opaque, unsigned int items, unsigned int size);
+void ZLIB_INTERNAL zcfree(void* opaque, void* ptr);
 
-#define ZALLOC(strm, items, size) \
-           (*((strm)->zalloc))((strm)->opaque, (items), (size))
-#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (void *)(addr))
-#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}
+void* ZLIB_INTERNAL z_stream_alloc(z_stream *strm, size_t size);
+void* ZLIB_INTERNAL z_stream_allocarray(z_stream *strm, size_t nmemb, size_t size);
+void ZLIB_INTERNAL z_stream_free(z_stream *strm, void* ptr);
 
 /* Reverse the bytes in a 32-bit value. Use compiler intrinsics when
    possible to take advantage of hardware implementations. */
-- 
2.4.0

