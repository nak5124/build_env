From 5972c05526d60e24c1b38f1e239cdbf883d140bd Mon Sep 17 00:00:00 2001
From: Yuta NAKAI <nak5124@live.jp>
Date: Sun, 26 Apr 2015 09:53:07 +0900
Subject: [PATCH 18/24] gcc/diagnostic-color.c: Enable color diagnostic on
 Windows.

---
 gcc/Makefile.in        |  5 +--
 gcc/diagnostic-color.c | 90 ++++++++++++++++++++++++++++++++++++++++++++++----
 2 files changed, 86 insertions(+), 9 deletions(-)

diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index 8eb6a9f..49a5e14 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -1031,10 +1031,11 @@ BUILD_LIBDEPS= $(BUILD_LIBIBERTY)
 
 # How to link with both our special library facilities
 # and the system's installed libraries.
+NTDLL = -lntdll
 LIBS = @LIBS@ libcommon.a $(CPPLIB) $(LIBINTL) $(LIBICONV) $(LIBBACKTRACE) \
-	$(LIBIBERTY) $(LIBDECNUMBER) $(HOST_LIBS)
+	$(LIBIBERTY) $(LIBDECNUMBER) $(HOST_LIBS) $(NTDLL)
 BACKENDLIBS = $(ISLLIBS) $(GMPLIBS) $(PLUGINLIBS) $(HOST_LIBS) \
-	$(ZLIB)
+	$(ZLIB) $(NTDLL)
 # Any system libraries needed just for GNAT.
 SYSLIBS = @GNAT_LIBEXC@
 
diff --git a/gcc/diagnostic-color.c b/gcc/diagnostic-color.c
index f76c87b..c683c67 100644
--- a/gcc/diagnostic-color.c
+++ b/gcc/diagnostic-color.c
@@ -264,20 +264,97 @@ parse_gcc_colors (void)
       return true;
 }
 
-#if defined(_WIN32)
-bool
-colorize_init (diagnostic_color_rule_t)
+#ifdef __MINGW32__
+#include <windows.h>
+#include <winternl.h>
+
+typedef struct {
+    HANDLE osfhnd;
+    char osflags;
+} ioinfo;
+
+extern __declspec(dllimport) ioinfo *__pioinfo[];
+
+static size_t sizeof_ioinfo = 0;
+
+#define IOINFO_L2E 5
+#define IOINFO_ARRAY_ELTS (1 << IOINFO_L2E)
+
+#define FPIPE 0x08
+#define FDEV  0x40
+
+static inline ioinfo* _pioinfo(int fd)
 {
-  return false;
+    return (ioinfo*)((char*)__pioinfo[fd >> IOINFO_L2E] + (fd & (IOINFO_ARRAY_ELTS - 1)) * sizeof_ioinfo);
 }
-#else
+
+static int init_sizeof_ioinfo()
+{
+    int istty, wastty;
+    /* don't init twice */
+    if (sizeof_ioinfo)
+        return sizeof_ioinfo >= 256;
+
+    sizeof_ioinfo = sizeof(ioinfo);
+    wastty = _isatty(1);
+
+    while(sizeof_ioinfo < 256) {
+        /* toggle FDEV flag, check isatty, then toggle back */
+        _pioinfo(1)->osflags ^= FDEV;
+        istty = _isatty(1);
+        _pioinfo(1)->osflags ^= FDEV;
+        /* return if we found the correct size */
+        if(istty != wastty)
+            return 0;
+        sizeof_ioinfo += sizeof(void*);
+    }
+    fprintf(stderr, "Tweaking file descriptors doesn't work with this MSVCRT.dll");
+    return 1;
+}
+
+static void detect_msys_tty(int fd)
+{
+    ULONG result;
+    BYTE buffer[1024];
+    POBJECT_NAME_INFORMATION nameinfo = (POBJECT_NAME_INFORMATION)buffer;
+    PWSTR name;
+
+    /* check if fd is a pipe */
+    HANDLE h = (HANDLE)_get_osfhandle(fd);
+    if(GetFileType(h) != FILE_TYPE_PIPE)
+        return;
+
+    /* get pipe name */
+    if(!NT_SUCCESS(NtQueryObject(h, ObjectNameInformation, buffer, sizeof(buffer) - 2, &result)))
+        return;
+    name = nameinfo->Name.Buffer;
+    name[nameinfo->Name.Length] = 0;
+
+    /* check if this could be a msys pty pipe ('msys-XXXX-ptyN-XX') */
+    if(!wcsstr(name, L"msys-") || !wcsstr(name, L"-pty"))
+        return;
+
+    /* init ioinfo size if we haven't done so */
+    if(init_sizeof_ioinfo())
+        return;
+
+    /* set FDEV flag, reset FPIPE flag */
+    _pioinfo(fd)->osflags &= ~FPIPE;
+    _pioinfo(fd)->osflags |= FDEV;
+}
+#endif
 
 /* Return true if we should use color when in auto mode, false otherwise. */
 static bool
 should_colorize (void)
 {
   char const *t = getenv ("TERM");
-  return t && strcmp (t, "dumb") != 0 && isatty (STDERR_FILENO);
+#ifdef __MINGW32__
+  detect_msys_tty(STDERR_FILENO);
+  return t && strcmp (t, "dumb") && _isatty (STDERR_FILENO);
+#else
+  return t && strcmp (t, "dumb") && isatty (STDERR_FILENO);
+#endif
 }
 
 
@@ -299,4 +376,3 @@ colorize_init (diagnostic_color_rule_t rule)
       gcc_unreachable ();
     }
 }
-#endif
-- 
2.8.1

