diff -urN aotuv_old/configure.ac aotuv_new/configure.ac
--- aotuv_old/configure.ac	2014-05-06 23:56:58.000000000 +0900
+++ aotuv_new/configure.ac	2015-01-09 23:49:03.122727500 +0900
@@ -5,7 +5,7 @@
 dnl ------------------------------------------------
 
 
-AC_INIT([libvorbis],[1.3.4],[vorbis-dev@xiph.org])
+AC_INIT([libvorbis],[1.3.5],[vorbis-dev@xiph.org])
 
 AC_CONFIG_SRCDIR([lib/mdct.c])
 
@@ -24,15 +24,15 @@
 dnl - interfaces removed -> AGE = 0
 
 V_LIB_CURRENT=4
-V_LIB_REVISION=7
+V_LIB_REVISION=8
 V_LIB_AGE=4
 
 VF_LIB_CURRENT=6
-VF_LIB_REVISION=6
+VF_LIB_REVISION=7
 VF_LIB_AGE=3
 
 VE_LIB_CURRENT=2
-VE_LIB_REVISION=10
+VE_LIB_REVISION=11
 VE_LIB_AGE=0
 
 AC_SUBST(V_LIB_CURRENT)
diff -urN aotuv_old/doc/04-codec.tex aotuv_new/doc/04-codec.tex
--- aotuv_old/doc/04-codec.tex	2014-05-06 23:56:58.000000000 +0900
+++ aotuv_new/doc/04-codec.tex	2015-01-09 23:49:43.274024000 +0900
@@ -590,7 +590,7 @@
 data to be returned is:
 
 \begin{programlisting}
-window\_blocksize(previous\_window)/4+window\_blocksize(current\_window)/4
+window_blocksize(previous_window)/4+window_blocksize(current_window)/4
 \end{programlisting}
 
 from the center (element windowsize/2) of the previous window to the
diff -urN aotuv_old/doc/10-tables.tex aotuv_new/doc/10-tables.tex
--- aotuv_old/doc/10-tables.tex	2014-05-06 23:56:58.000000000 +0900
+++ aotuv_new/doc/10-tables.tex	2015-01-09 23:50:34.530955800 +0900
@@ -6,7 +6,7 @@
 \subsection{floor1\_inverse\_dB\_table} \label{vorbis:spec:floor1:inverse:dB:table}
 
 The vector \varname{[floor1\_inverse\_dB\_table]} is a 256 element static
-lookup table consiting of the following values (read left to right
+lookup table consisting of the following values (read left to right
 then top to bottom):
 
 \begin{Verbatim}
diff -urN aotuv_old/examples/seeking_example.c aotuv_new/examples/seeking_example.c
--- aotuv_old/examples/seeking_example.c	2014-05-05 01:44:50.000000000 +0900
+++ aotuv_new/examples/seeking_example.c	2015-01-09 23:54:22.768010200 +0900
@@ -127,7 +127,7 @@
         exit(1);
       }
     }
-    
+
     /* because we want to do sample-level verification that the seek
        does what it claimed, decode the entire file into memory */
     pcmlength=ov_pcm_total(&ov,-1);
@@ -148,12 +148,12 @@
       fprintf(stderr,"\rloading.... [%ld left]              ",
               (long)((pcmlength>>hs)*2-i));
     }
-    
+
     {
       ogg_int64_t length=ov.end;
       fprintf(stderr,"\rtesting raw seeking to random places in %ld bytes....\n",
              (long)length);
-    
+
       for(i=0;i<1000;i++){
         ogg_int64_t val=(double)rand()/RAND_MAX*length;
         fprintf(stderr,"\r\t%d [raw position %ld]...     ",i,(long)val);
@@ -172,9 +172,9 @@
     {
       fprintf(stderr,"testing pcm page seeking to random places in %ld samples....\n",
              (long)pcmlength);
-    
+
       for(i=0;i<1000;i++){
-        ogg_int64_t val=(double)rand()/RAND_MAX*pcmlength;
+        ogg_int64_t val= i==0?(ogg_int64_t)0:(double)rand()/RAND_MAX*pcmlength;
         fprintf(stderr,"\r\t%d [pcm position %ld]...     ",i,(long)val);
         ret=ov_pcm_seek_page(&ov,val);
         if(ret<0){
@@ -189,11 +189,10 @@
 
     fprintf(stderr,"\r");
     {
-      fprintf(stderr,"testing pcm exact seeking to random places in %ld samples....\n",
-             (long)pcmlength);
-    
+      fprintf(stderr,"testing pcm exact seeking to random places in %f seconds....\n",
+             timelength);
       for(i=0;i<1000;i++){
-        ogg_int64_t val=(double)rand()/RAND_MAX*pcmlength;
+        ogg_int64_t val= i==0?(ogg_int64_t)0:(double)rand()/RAND_MAX*pcmlength;
         fprintf(stderr,"\r\t%d [pcm position %ld]...     ",i,(long)val);
         ret=ov_pcm_seek(&ov,val);
         if(ret<0){
diff -urN aotuv_old/lib/info.c aotuv_new/lib/info.c
--- aotuv_old/lib/info.c	2014-05-06 23:56:58.000000000 +0900
+++ aotuv_new/lib/info.c	2015-01-09 23:57:47.406714800 +0900
@@ -5,7 +5,7 @@
  * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
  * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
  *                                                                  *
- * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2010             *
+ * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2015             *
  * by the Xiph.Org Foundation http://www.xiph.org/                  *
  *                                                                  *
  ********************************************************************
@@ -31,7 +31,7 @@
 #include "misc.h"
 #include "os.h"
 
-#define GENERAL_VENDOR_STRING "aoTuV Beta 6.03 (2014)"
+#define GENERAL_VENDOR_STRING "aoTuV Beta 6.03 (2015)"
 #define ENCODE_VENDOR_STRING "AO; aoTuV [20110424] (based on Xiph.Org's libVorbis)"
 
 /* helpers */
@@ -272,7 +272,6 @@
 static int _vorbis_unpack_books(vorbis_info *vi,oggpack_buffer *opb){
   codec_setup_info     *ci=vi->codec_setup;
   int i;
-  if(!ci)return(OV_EFAULT);
 
   /* codebooks */
   ci->books=oggpack_read(opb,8)+1;
@@ -411,6 +410,10 @@
           /* um... we didn't get the initial header */
           return(OV_EBADHEADER);
         }
+        if(vc->vendor!=NULL){
+          /* previously initialized comment header */
+          return(OV_EBADHEADER);
+        }
 
         return(_vorbis_unpack_comment(vc,&opb));
 
@@ -419,6 +422,14 @@
           /* um... we didn;t get the initial header or comments yet */
           return(OV_EBADHEADER);
         }
+        if(vi->codec_setup==NULL){
+          /* improperly initialized vorbis_info */
+          return(OV_EFAULT);
+        }
+        if(((codec_setup_info *)vi->codec_setup)->books>0){
+          /* previously initialized setup header */
+          return(OV_EBADHEADER);
+        }
 
         return(_vorbis_unpack_books(vi,&opb));
 
diff -urN aotuv_old/lib/synthesis.c aotuv_new/lib/synthesis.c
--- aotuv_old/lib/synthesis.c	2014-05-05 01:44:50.000000000 +0900
+++ aotuv_new/lib/synthesis.c	2015-01-09 23:58:47.902175000 +0900
@@ -5,7 +5,7 @@
  * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
  * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
  *                                                                  *
- * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
+ * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2015             *
  * by the Xiph.Org Foundation http://www.xiph.org/                  *
  *                                                                  *
  ********************************************************************
@@ -164,7 +164,7 @@
     /* read our mode and pre/post windowsize */
     mode=oggpack_read(&opb,modebits);
   }
-  if(mode==-1)return(OV_EBADPACKET);
+  if(mode==-1 || !ci->mode_param[mode])return(OV_EBADPACKET);
   return(ci->blocksizes[ci->mode_param[mode]->blockflag]);
 }
 
diff -urN aotuv_old/lib/vorbisenc.c aotuv_new/lib/vorbisenc.c
--- aotuv_old/lib/vorbisenc.c	2014-05-06 23:49:42.000000000 +0900
+++ aotuv_new/lib/vorbisenc.c	2015-01-10 00:00:13.445067800 +0900
@@ -953,6 +953,8 @@
                             long  channels,
                             long  rate,
                             float quality){
+  if(rate <= 0) return OV_EINVAL;
+
   codec_setup_info *ci=vi->codec_setup;
   highlevel_encode_setup *hi=&ci->hi;
 
@@ -998,6 +1000,8 @@
                                 long nominal_bitrate,
                                 long min_bitrate){
 
+  if(rate <= 0) return OV_EINVAL;
+
   codec_setup_info *ci=vi->codec_setup;
   highlevel_encode_setup *hi=&ci->hi;
   double tnominal=nominal_bitrate;
diff -urN aotuv_old/lib/vorbisfile.c aotuv_new/lib/vorbisfile.c
--- aotuv_old/lib/vorbisfile.c	2014-05-06 23:56:58.000000000 +0900
+++ aotuv_new/lib/vorbisfile.c	2015-01-10 00:15:53.281870200 +0900
@@ -5,7 +5,7 @@
  * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
  * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
  *                                                                  *
- * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
+ * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2014             *
  * by the Xiph.Org Foundation http://www.xiph.org/                  *
  *                                                                  *
  ********************************************************************
@@ -80,11 +80,14 @@
 /* save a tiny smidge of verbosity to make the code more readable */
 static int _seek_helper(OggVorbis_File *vf,ogg_int64_t offset){
   if(vf->datasource){
-    if(!(vf->callbacks.seek_func)||
-       (vf->callbacks.seek_func)(vf->datasource, offset, SEEK_SET) == -1)
-      return OV_EREAD;
-    vf->offset=offset;
-    ogg_sync_reset(&vf->oy);
+    /* only seek if the file position isn't already there */
+    if(vf->offset != offset){
+      if(!(vf->callbacks.seek_func)||
+         (vf->callbacks.seek_func)(vf->datasource, offset, SEEK_SET) == -1)
+        return OV_EREAD;
+      vf->offset=offset;
+      ogg_sync_reset(&vf->oy);
+    }
   }else{
     /* shouldn't happen unless someone writes a broken callback */
     return OV_EFAULT;
@@ -138,14 +141,12 @@
   }
 }
 
-/* find the latest page beginning before the current stream cursor
-   position. Much dirtier than the above as Ogg doesn't have any
-   backward search linkage.  no 'readp' as it will certainly have to
-   read. */
+/* find the latest page beginning before the passed in position. Much
+   dirtier than the above as Ogg doesn't have any backward search
+   linkage.  no 'readp' as it will certainly have to read. */
 /* returns offset or OV_EREAD, OV_FAULT */
-static ogg_int64_t _get_prev_page(OggVorbis_File *vf,ogg_page *og){
-  ogg_int64_t begin=vf->offset;
-  ogg_int64_t end=begin;
+static ogg_int64_t _get_prev_page(OggVorbis_File *vf,ogg_int64_t begin,ogg_page *og){
+  ogg_int64_t end = begin;
   ogg_int64_t ret;
   ogg_int64_t offset=-1;
 
@@ -220,11 +221,10 @@
    info of last page of the matching serial number instead of the very
    last page.  If no page of the specified serialno is seen, it will
    return the info of last page and alter *serialno.  */
-static ogg_int64_t _get_prev_page_serial(OggVorbis_File *vf,
+static ogg_int64_t _get_prev_page_serial(OggVorbis_File *vf, ogg_int64_t begin,
                                          long *serial_list, int serial_n,
                                          int *serialno, ogg_int64_t *granpos){
   ogg_page og;
-  ogg_int64_t begin=vf->offset;
   ogg_int64_t end=begin;
   ogg_int64_t ret;
 
@@ -494,10 +494,10 @@
        down to (or just started with) a single link.  Now we need to
        find the last vorbis page belonging to the first vorbis stream
        for this link. */
-
+    searched = end;
     while(endserial != serialno){
       endserial = serialno;
-      vf->offset=_get_prev_page_serial(vf,currentno_list,currentnos,&endserial,&endgran);
+      searched=_get_prev_page_serial(vf,searched,currentno_list,currentnos,&endserial,&endgran);
     }
 
     vf->links=m+1;
@@ -518,10 +518,15 @@
 
   }else{
 
+    /* last page is not in the starting stream's serial number list,
+       so we have multiple links.  Find where the stream that begins
+       our bisection ends. */
+
     long *next_serialno_list=NULL;
     int next_serialnos=0;
     vorbis_info vi;
     vorbis_comment vc;
+    int testserial = serialno+1;
 
     /* the below guards against garbage seperating the last and
        first pages of two links. */
@@ -534,10 +539,8 @@
         bisect=(searched+endsearched)/2;
       }
 
-      if(bisect != vf->offset){
-        ret=_seek_helper(vf,bisect);
-        if(ret)return(ret);
-      }
+      ret=_seek_helper(vf,bisect);
+      if(ret)return(ret);
 
       last=_get_next_page(vf,&og,-1);
       if(last==OV_EREAD)return(OV_EREAD);
@@ -550,28 +553,22 @@
     }
 
     /* Bisection point found */
-
     /* for the time being, fetch end PCM offset the simple way */
-    {
-      int testserial = serialno+1;
-      vf->offset = next;
-      while(testserial != serialno){
-        testserial = serialno;
-        vf->offset=_get_prev_page_serial(vf,currentno_list,currentnos,&testserial,&searchgran);
-      }
+    searched = next;
+    while(testserial != serialno){
+      testserial = serialno;
+      searched = _get_prev_page_serial(vf,searched,currentno_list,currentnos,&testserial,&searchgran);
     }
 
-    if(vf->offset!=next){
-      ret=_seek_helper(vf,next);
-      if(ret)return(ret);
-    }
+    ret=_seek_helper(vf,next);
+    if(ret)return(ret);
 
     ret=_fetch_headers(vf,&vi,&vc,&next_serialno_list,&next_serialnos,NULL);
     if(ret)return(ret);
     serialno = vf->os.serialno;
     dataoffset = vf->offset;
 
-    /* this will consume a page, however the next bistection always
+    /* this will consume a page, however the next bisection always
        starts with a raw seek */
     pcmoffset = _initial_pcmoffset(vf,&vi);
 
@@ -638,11 +635,11 @@
   /* Get the offset of the last page of the physical bitstream, or, if
      we're lucky the last vorbis page of this link as most OggVorbis
      files will contain a single logical bitstream */
-  end=_get_prev_page_serial(vf,vf->serialnos+2,vf->serialnos[1],&endserial,&endgran);
+  end=_get_prev_page_serial(vf,vf->end,vf->serialnos+2,vf->serialnos[1],&endserial,&endgran);
   if(end<0)return(end);
 
   /* now determine bitstream structure recursively */
-  if(_bisect_forward_serialno(vf,0,dataoffset,vf->offset,endgran,endserial,
+  if(_bisect_forward_serialno(vf,0,dataoffset,end,endgran,endserial,
                               vf->serialnos+2,vf->serialnos[1],0)<0)return(OV_EREAD);
 
   vf->offsets[0]=0;
@@ -1421,22 +1418,41 @@
     if(pos>=total)break;
   }
 
-  /* search within the logical bitstream for the page with the highest
-     pcm_pos preceding (or equal to) pos.  There is a danger here;
-     missing pages or incorrect frame number information in the
-     bitstream could make our task impossible.  Account for that (it
-     would be an error condition) */
+  /* Search within the logical bitstream for the page with the highest
+     pcm_pos preceding pos.  If we're looking for a position on the
+     first page, bisection will halt without finding our position as
+     it's before the first explicit granulepos fencepost. That case is
+     handled separately below.
+
+     There is a danger here; missing pages or incorrect frame number
+     information in the bitstream could make our task impossible.
+     Account for that (it would be an error condition) */
+
+  /* new search algorithm originally by HB (Nicholas Vinen) */
 
-  /* new search algorithm by HB (Nicholas Vinen) */
   {
     ogg_int64_t end=vf->offsets[link+1];
-    ogg_int64_t begin=vf->offsets[link];
+    ogg_int64_t begin=vf->dataoffsets[link];
     ogg_int64_t begintime = vf->pcmlengths[link*2];
     ogg_int64_t endtime = vf->pcmlengths[link*2+1]+begintime;
     ogg_int64_t target=pos-total+begintime;
-    ogg_int64_t best=begin;
+    ogg_int64_t best=-1;
+    int         got_page=0;
 
     ogg_page og;
+
+    /* if we have only one page, there will be no bisection.  Grab the page here */
+    if(begin==end){
+      result=_seek_helper(vf,begin);
+      if(result) goto seek_error;
+
+      result=_get_next_page(vf,&og,1);
+      if(result<0) goto seek_error;
+
+      got_page=1;
+    }
+
+    /* bisection loop */
     while(begin<end){
       ogg_int64_t bisect;
 
@@ -1451,51 +1467,80 @@
           bisect=begin;
       }
 
-      if(bisect!=vf->offset){
-        result=_seek_helper(vf,bisect);
-        if(result) goto seek_error;
-      }
+      result=_seek_helper(vf,bisect);
+      if(result) goto seek_error;
 
+      /* read loop within the bisection loop */
       while(begin<end){
         result=_get_next_page(vf,&og,end-vf->offset);
         if(result==OV_EREAD) goto seek_error;
         if(result<0){
+          /* there is no next page! */
           if(bisect<=begin+1)
-            end=begin; /* found it */
+              /* No bisection left to perform.  We've either found the
+                 best candidate already or failed. Exit loop. */
+            end=begin;
           else{
+            /* We tried to load a fraction of the last page; back up a
+               bit and try to get the whole last page */
             if(bisect==0) goto seek_error;
             bisect-=CHUNKSIZE;
+
+            /* don't repeat/loop on a read we've already performed */
             if(bisect<=begin)bisect=begin+1;
+
+            /* seek and cntinue bisection */
             result=_seek_helper(vf,bisect);
             if(result) goto seek_error;
           }
         }else{
           ogg_int64_t granulepos;
+          got_page=1;
 
+          /* got a page. analyze it */
+          /* only consider pages from primary vorbis stream */
           if(ogg_page_serialno(&og)!=vf->serialnos[link])
             continue;
 
+          /* only consider pages with the granulepos set */
           granulepos=ogg_page_granulepos(&og);
           if(granulepos==-1)continue;
 
           if(granulepos<target){
+            /* this page is a successful candidate! Set state */
+
             best=result;  /* raw offset of packet with granulepos */
             begin=vf->offset; /* raw offset of next page */
             begintime=granulepos;
 
+            /* if we're before our target but within a short distance,
+               don't bisect; read forward */
             if(target-begintime>44100)break;
-            bisect=begin; /* *not* begin + 1 */
+
+            bisect=begin; /* *not* begin + 1 as above */
           }else{
-            if(bisect<=begin+1)
-              end=begin;  /* found it */
-            else{
-              if(end==vf->offset){ /* we're pretty close - we'd be stuck in */
+
+            /* This is one of our pages, but the granpos is
+               post-target; it is not a bisection return
+               candidate. (The only way we'd use it is if it's the
+               first page in the stream; we handle that case later
+               outside the bisection) */
+            if(bisect<=begin+1){
+              /* No bisection left to perform.  We've either found the
+                 best candidate already or failed. Exit loop. */
+              end=begin;
+            }else{
+              if(end==vf->offset){
+                /* bisection read to the end; use the known page
+                   boundary (result) to update bisection, back up a
+                   little bit, and try again */
                 end=result;
-                bisect-=CHUNKSIZE; /* an endless loop otherwise. */
+                bisect-=CHUNKSIZE;
                 if(bisect<=begin)bisect=begin+1;
                 result=_seek_helper(vf,bisect);
                 if(result) goto seek_error;
               }else{
+                /* Normal bisection */
                 end=bisect;
                 endtime=granulepos;
                 break;
@@ -1506,9 +1551,46 @@
       }
     }
 
-    /* found our page. seek to it, update pcm offset. Easier case than
-       raw_seek, don't keep packets preceding granulepos. */
-    {
+    /* Out of bisection: did it 'fail?' */
+    if(best == -1){
+
+      /* Check the 'looking for data in first page' special case;
+         bisection would 'fail' because our search target was before the
+         first PCM granule position fencepost. */
+
+      if(got_page &&
+         begin == vf->dataoffsets[link] &&
+         ogg_page_serialno(&og)==vf->serialnos[link]){
+
+        /* Yes, this is the beginning-of-stream case. We already have
+           our page, right at the beginning of PCM data.  Set state
+           and return. */
+
+        vf->pcm_offset=total;
+
+        if(link!=vf->current_link){
+          /* Different link; dump entire decode machine */
+          _decode_clear(vf);
+
+          vf->current_link=link;
+          vf->current_serialno=vf->serialnos[link];
+          vf->ready_state=STREAMSET;
+
+        }else{
+          vorbis_synthesis_restart(&vf->vd);
+        }
+
+        ogg_stream_reset_serialno(&vf->os,vf->current_serialno);
+        ogg_stream_pagein(&vf->os,&og);
+
+      }else
+        goto seek_error;
+
+    }else{
+
+      /* Bisection found our page. seek to it, update pcm offset. Easier case than
+         raw_seek, don't keep packets preceding granulepos. */
+
       ogg_page og;
       ogg_packet op;
 
@@ -1538,23 +1620,23 @@
       while(1){
         result=ogg_stream_packetpeek(&vf->os,&op);
         if(result==0){
-          /* !!! the packet finishing this page originated on a
-             preceding page. Keep fetching previous pages until we
-             get one with a granulepos or without the 'continued' flag
-             set.  Then just use raw_seek for simplicity. */
-
-          result=_seek_helper(vf,best);
-          if(result<0) goto seek_error;
-
-          while(1){
-            result=_get_prev_page(vf,&og);
+          /* No packet returned; we exited the bisection with 'best'
+             pointing to a page with a granule position, so the packet
+             finishing this page ('best') originated on a preceding
+             page. Keep fetching previous pages until we get one with
+             a granulepos or without the 'continued' flag set.  Then
+             just use raw_seek for simplicity. */
+          /* Do not rewind past the beginning of link data; if we do,
+             it's either a bug or a broken stream */
+          result=best;
+          while(result>vf->dataoffsets[link]){
+            result=_get_prev_page(vf,result,&og);
             if(result<0) goto seek_error;
             if(ogg_page_serialno(&og)==vf->current_serialno &&
                (ogg_page_granulepos(&og)>-1 ||
                 !ogg_page_continued(&og))){
               return ov_raw_seek(vf,result);
             }
-            vf->offset=result;
           }
         }
         if(result<0){
